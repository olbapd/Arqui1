CCS PCM C Compiler, Version 5.088d, 1               12-Nov-19 19:27
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\and-h\MPLABXProjects\AccessControl.X\build\default\production\main.lst

               ROM used:   2645 words (32%)
                           Largest free fragment is 2048
               RAM used:   37 (10%) at main() level
                           59 (16%) worst case
               Stack used: 5 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... /**
....................  * Costa Rica Institute of Technology
....................  * Computer Engineering
....................  * CE-4301 Computer Architecture I
....................  * 
....................  * Students: Andre Herrera
....................  *           Jose Rivera
....................  * 
....................  * Door system for PIC6F877 with CCS library. Symple door control,
....................  * open and close the door if the temperature is normal.  
....................  * 
.................... */
.................... 
.................... //16F877 Library, adds new functions to 16F877
.................... #include<16f877.h>
.................... //////////// Standard Header file for the PIC16F877 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  34
000C:  RETLW  35
000D:  RETLW  36
000E:  RETLW  37
000F:  RETLW  38
0010:  RETLW  39
0011:  RETLW  2A
0012:  RETLW  30
0013:  RETLW  23
0014:  BCF    0A.0
0015:  BCF    0A.1
0016:  BCF    0A.2
0017:  ADDWF  02,F
0018:  RETLW  00
0019:  DATA 46,39
001A:  DATA 69,32
001B:  DATA E7,32
001C:  DATA A0,20
001D:  DATA E3,31
001E:  DATA E5,39
001F:  DATA 73,00
0020:  DATA 53,3A
0021:  DATA 61,39
0022:  DATA F4,34
0023:  DATA EE,33
0024:  DATA 2E,17
0025:  DATA 2E,00
0026:  DATA 0C,10
0027:  DATA F4,32
0028:  DATA 63,36
0029:  DATA 61,10
002A:  DATA CE,37
002B:  DATA 3D,10
002C:  DATA A5,31
002D:  DATA 00,00
002E:  DATA D4,22
002F:  DATA 4D,28
0030:  DATA 3A,10
0031:  DATA 25,33
0032:  DATA A0,21
0033:  DATA 20,00
0034:  DATA 0C,10
0035:  DATA 49,37
0036:  DATA F3,32
0037:  DATA 72,3A
0038:  DATA 00,01
0039:  DATA D0,30
003A:  DATA F3,39
003B:  DATA F7,37
003C:  DATA 72,32
003D:  DATA 00,01
003E:  DATA D2,32
003F:  DATA 61,32
0040:  DATA 69,37
0041:  DATA 67,17
0042:  DATA 2E,17
0043:  DATA 00,01
0044:  DATA 0C,10
0045:  DATA 49,37
0046:  DATA F6,30
0047:  DATA EC,34
0048:  DATA 64,00
0049:  DATA D0,30
004A:  DATA F3,39
004B:  DATA F7,37
004C:  DATA 72,32
004D:  DATA 00,01
004E:  DATA 0C,10
004F:  DATA CB,32
0050:  DATA 79,1D
0051:  DATA A0,12
0052:  DATA 63,00
0053:  DATA 0C,10
0054:  DATA D0,30
0055:  DATA F3,39
0056:  DATA F7,37
0057:  DATA 72,32
0058:  DATA A0,22
0059:  DATA 72,39
005A:  DATA 6F,39
005B:  DATA 00,01
005C:  DATA C3,27
005D:  DATA C4,22
005E:  DATA A0,12
005F:  DATA 73,10
0060:  DATA D4,22
0061:  DATA 4D,28
0062:  DATA 3A,10
0063:  DATA 25,33
0064:  DATA 00,00
0065:  DATA 0C,00
0066:  DATA D7,30
0067:  DATA 69,3A
0068:  DATA 2C,10
0069:  DATA E8,34
006A:  DATA 67,34
006B:  DATA 20,3A
006C:  DATA E5,36
006D:  DATA 70,00
006E:  DATA 0C,00
006F:  DATA 0C,10
0070:  DATA D3,3A
0071:  DATA F0,32
0072:  DATA F2,3A
0073:  DATA F3,32
0074:  DATA 72,10
0075:  DATA CD,37
0076:  DATA E4,32
0077:  DATA 00,01
0078:  DATA 0C,00
*
015C:  MOVF   0B,W
015D:  MOVWF  3C
015E:  BCF    0B.7
015F:  BSF    03.5
0160:  BSF    03.6
0161:  BSF    0C.7
0162:  BSF    0C.0
0163:  NOP
0164:  NOP
0165:  BCF    03.5
0166:  BCF    03.6
0167:  BTFSC  3C.7
0168:  BSF    0B.7
0169:  BSF    03.6
016A:  MOVF   0C,W
016B:  ANDLW  7F
016C:  BTFSC  03.2
016D:  GOTO   1B0
016E:  BCF    03.6
016F:  MOVWF  3C
0170:  BSF    03.6
0171:  MOVF   0D,W
0172:  BCF    03.6
0173:  MOVWF  3D
0174:  BSF    03.6
0175:  MOVF   0F,W
0176:  BCF    03.6
0177:  MOVWF  3E
0178:  MOVF   3C,W
0179:  MOVWF  49
017A:  CALL   130
017B:  MOVF   3D,W
017C:  BSF    03.6
017D:  MOVWF  0D
017E:  BCF    03.6
017F:  MOVF   3E,W
0180:  BSF    03.6
0181:  MOVWF  0F
0182:  BCF    03.6
0183:  MOVF   0B,W
0184:  MOVWF  3F
0185:  BCF    0B.7
0186:  BSF    03.5
0187:  BSF    03.6
0188:  BSF    0C.7
0189:  BSF    0C.0
018A:  NOP
018B:  NOP
018C:  BCF    03.5
018D:  BCF    03.6
018E:  BTFSC  3F.7
018F:  BSF    0B.7
0190:  BSF    03.6
0191:  RLF    0C,W
0192:  RLF    0E,W
0193:  ANDLW  7F
0194:  BTFSC  03.2
0195:  GOTO   1B0
0196:  BCF    03.6
0197:  MOVWF  3C
0198:  BSF    03.6
0199:  MOVF   0D,W
019A:  BCF    03.6
019B:  MOVWF  3D
019C:  BSF    03.6
019D:  MOVF   0F,W
019E:  BCF    03.6
019F:  MOVWF  3E
01A0:  MOVF   3C,W
01A1:  MOVWF  49
01A2:  CALL   130
01A3:  MOVF   3D,W
01A4:  BSF    03.6
01A5:  MOVWF  0D
01A6:  BCF    03.6
01A7:  MOVF   3E,W
01A8:  BSF    03.6
01A9:  MOVWF  0F
01AA:  INCF   0D,F
01AB:  BTFSC  03.2
01AC:  INCF   0F,F
01AD:  BCF    03.6
01AE:  GOTO   15C
01AF:  BSF    03.6
01B0:  BCF    03.6
01B1:  RETURN
01B2:  MOVF   0B,W
01B3:  MOVWF  3D
01B4:  BCF    0B.7
01B5:  BSF    03.5
01B6:  BSF    03.6
01B7:  BSF    0C.7
01B8:  BSF    0C.0
01B9:  NOP
01BA:  NOP
01BB:  BCF    03.5
01BC:  BCF    03.6
01BD:  BTFSC  3D.7
01BE:  BSF    0B.7
01BF:  BTFSC  03.0
01C0:  GOTO   1E9
01C1:  BSF    03.6
01C2:  MOVF   0C,W
01C3:  ANDLW  7F
01C4:  BCF    03.6
01C5:  MOVWF  3D
01C6:  BSF    03.6
01C7:  MOVF   0D,W
01C8:  BCF    03.6
01C9:  MOVWF  3E
01CA:  BSF    03.6
01CB:  MOVF   0F,W
01CC:  BCF    03.6
01CD:  MOVWF  3F
01CE:  MOVF   3D,W
01CF:  MOVWF  49
01D0:  CALL   130
01D1:  MOVF   3E,W
01D2:  BSF    03.6
01D3:  MOVWF  0D
01D4:  BCF    03.6
01D5:  MOVF   3F,W
01D6:  BSF    03.6
01D7:  MOVWF  0F
01D8:  BCF    03.6
01D9:  MOVF   0B,W
01DA:  MOVWF  40
01DB:  BCF    0B.7
01DC:  BSF    03.5
01DD:  BSF    03.6
01DE:  BSF    0C.7
01DF:  BSF    0C.0
01E0:  NOP
01E1:  NOP
01E2:  BCF    03.5
01E3:  BCF    03.6
01E4:  BTFSC  40.7
01E5:  BSF    0B.7
01E6:  DECFSZ 3C,F
01E7:  GOTO   1E9
01E8:  GOTO   208
01E9:  BSF    03.6
01EA:  RLF    0C,W
01EB:  RLF    0E,W
01EC:  ANDLW  7F
01ED:  BCF    03.6
01EE:  MOVWF  3D
01EF:  BSF    03.6
01F0:  MOVF   0D,W
01F1:  BCF    03.6
01F2:  MOVWF  3E
01F3:  BSF    03.6
01F4:  MOVF   0F,W
01F5:  BCF    03.6
01F6:  MOVWF  3F
01F7:  MOVF   3D,W
01F8:  MOVWF  49
01F9:  CALL   130
01FA:  MOVF   3E,W
01FB:  BSF    03.6
01FC:  MOVWF  0D
01FD:  BCF    03.6
01FE:  MOVF   3F,W
01FF:  BSF    03.6
0200:  MOVWF  0F
0201:  INCF   0D,F
0202:  BTFSC  03.2
0203:  INCF   0F,F
0204:  BCF    03.0
0205:  BCF    03.6
0206:  DECFSZ 3C,F
0207:  GOTO   1B2
0208:  RETURN
*
020C:  MOVLW  8E
020D:  MOVWF  77
020E:  MOVF   3D,W
020F:  MOVWF  78
0210:  MOVF   3C,W
0211:  MOVWF  79
0212:  CLRF   7A
0213:  MOVF   78,F
0214:  BTFSS  03.2
0215:  GOTO   220
0216:  MOVF   79,W
0217:  MOVWF  78
0218:  CLRF   79
0219:  MOVLW  08
021A:  SUBWF  77,F
021B:  MOVF   78,F
021C:  BTFSS  03.2
021D:  GOTO   220
021E:  CLRF   77
021F:  GOTO   228
0220:  BCF    03.0
0221:  BTFSC  78.7
0222:  GOTO   227
0223:  RLF    79,F
0224:  RLF    78,F
0225:  DECF   77,F
0226:  GOTO   220
0227:  BCF    78.7
0228:  BSF    0A.3
0229:  BCF    0A.4
022A:  GOTO   09A (RETURN)
022B:  MOVF   40,W
022C:  BTFSC  03.2
022D:  GOTO   2F0
022E:  MOVWF  4C
022F:  MOVF   44,W
0230:  BTFSC  03.2
0231:  GOTO   2F0
0232:  SUBWF  4C,F
0233:  BTFSS  03.0
0234:  GOTO   23A
0235:  MOVLW  7F
0236:  ADDWF  4C,F
0237:  BTFSC  03.0
0238:  GOTO   2F0
0239:  GOTO   240
023A:  MOVLW  81
023B:  SUBWF  4C,F
023C:  BTFSS  03.0
023D:  GOTO   2F0
023E:  BTFSC  03.2
023F:  GOTO   2F0
0240:  MOVF   4C,W
0241:  MOVWF  77
0242:  CLRF   78
0243:  CLRF   79
0244:  CLRF   7A
0245:  CLRF   4B
0246:  MOVF   41,W
0247:  MOVWF  4A
0248:  BSF    4A.7
0249:  MOVF   42,W
024A:  MOVWF  49
024B:  MOVF   43,W
024C:  MOVWF  48
024D:  MOVLW  19
024E:  MOVWF  4C
024F:  MOVF   47,W
0250:  SUBWF  48,F
0251:  BTFSC  03.0
0252:  GOTO   263
0253:  MOVLW  01
0254:  SUBWF  49,F
0255:  BTFSC  03.0
0256:  GOTO   263
0257:  SUBWF  4A,F
0258:  BTFSC  03.0
0259:  GOTO   263
025A:  SUBWF  4B,F
025B:  BTFSC  03.0
025C:  GOTO   263
025D:  INCF   4B,F
025E:  INCF   4A,F
025F:  INCF   49,F
0260:  MOVF   47,W
0261:  ADDWF  48,F
0262:  GOTO   295
0263:  MOVF   46,W
0264:  SUBWF  49,F
0265:  BTFSC  03.0
0266:  GOTO   27E
0267:  MOVLW  01
0268:  SUBWF  4A,F
0269:  BTFSC  03.0
026A:  GOTO   27E
026B:  SUBWF  4B,F
026C:  BTFSC  03.0
026D:  GOTO   27E
026E:  INCF   4B,F
026F:  INCF   4A,F
0270:  MOVF   46,W
0271:  ADDWF  49,F
0272:  MOVF   47,W
0273:  ADDWF  48,F
0274:  BTFSS  03.0
0275:  GOTO   295
0276:  INCF   49,F
0277:  BTFSS  03.2
0278:  GOTO   295
0279:  INCF   4A,F
027A:  BTFSS  03.2
027B:  GOTO   295
027C:  INCF   4B,F
027D:  GOTO   295
027E:  MOVF   45,W
027F:  IORLW  80
0280:  SUBWF  4A,F
0281:  BTFSC  03.0
0282:  GOTO   294
0283:  MOVLW  01
0284:  SUBWF  4B,F
0285:  BTFSC  03.0
0286:  GOTO   294
0287:  INCF   4B,F
0288:  MOVF   45,W
0289:  IORLW  80
028A:  ADDWF  4A,F
028B:  MOVF   46,W
028C:  ADDWF  49,F
028D:  BTFSS  03.0
028E:  GOTO   272
028F:  INCF   4A,F
0290:  BTFSS  03.2
0291:  GOTO   272
0292:  INCF   4B,F
0293:  GOTO   272
0294:  BSF    7A.0
0295:  DECFSZ 4C,F
0296:  GOTO   298
0297:  GOTO   2A3
0298:  BCF    03.0
0299:  RLF    48,F
029A:  RLF    49,F
029B:  RLF    4A,F
029C:  RLF    4B,F
029D:  BCF    03.0
029E:  RLF    7A,F
029F:  RLF    79,F
02A0:  RLF    78,F
02A1:  RLF    4D,F
02A2:  GOTO   24F
02A3:  BTFSS  4D.0
02A4:  GOTO   2AB
02A5:  BCF    03.0
02A6:  RRF    78,F
02A7:  RRF    79,F
02A8:  RRF    7A,F
02A9:  RRF    4D,F
02AA:  GOTO   2AE
02AB:  DECF   77,F
02AC:  BTFSC  03.2
02AD:  GOTO   2F0
02AE:  BTFSC  4D.7
02AF:  GOTO   2D7
02B0:  BCF    03.0
02B1:  RLF    48,F
02B2:  RLF    49,F
02B3:  RLF    4A,F
02B4:  RLF    4B,F
02B5:  MOVF   47,W
02B6:  SUBWF  48,F
02B7:  BTFSC  03.0
02B8:  GOTO   2C3
02B9:  MOVLW  01
02BA:  SUBWF  49,F
02BB:  BTFSC  03.0
02BC:  GOTO   2C3
02BD:  SUBWF  4A,F
02BE:  BTFSC  03.0
02BF:  GOTO   2C3
02C0:  SUBWF  4B,F
02C1:  BTFSS  03.0
02C2:  GOTO   2E6
02C3:  MOVF   46,W
02C4:  SUBWF  49,F
02C5:  BTFSC  03.0
02C6:  GOTO   2CE
02C7:  MOVLW  01
02C8:  SUBWF  4A,F
02C9:  BTFSC  03.0
02CA:  GOTO   2CE
02CB:  SUBWF  4B,F
02CC:  BTFSS  03.0
02CD:  GOTO   2E6
02CE:  MOVF   45,W
02CF:  IORLW  80
02D0:  SUBWF  4A,F
02D1:  BTFSC  03.0
02D2:  GOTO   2D7
02D3:  MOVLW  01
02D4:  SUBWF  4B,F
02D5:  BTFSS  03.0
02D6:  GOTO   2E6
02D7:  INCF   7A,F
02D8:  BTFSS  03.2
02D9:  GOTO   2E6
02DA:  INCF   79,F
02DB:  BTFSS  03.2
02DC:  GOTO   2E6
02DD:  INCF   78,F
02DE:  BTFSS  03.2
02DF:  GOTO   2E6
02E0:  INCF   77,F
02E1:  BTFSC  03.2
02E2:  GOTO   2F0
02E3:  RRF    78,F
02E4:  RRF    79,F
02E5:  RRF    7A,F
02E6:  MOVF   41,W
02E7:  MOVWF  4C
02E8:  MOVF   45,W
02E9:  XORWF  4C,F
02EA:  BTFSS  4C.7
02EB:  GOTO   2EE
02EC:  BSF    78.7
02ED:  GOTO   2F4
02EE:  BCF    78.7
02EF:  GOTO   2F4
02F0:  CLRF   77
02F1:  CLRF   78
02F2:  CLRF   79
02F3:  CLRF   7A
02F4:  BSF    0A.3
02F5:  BCF    0A.4
02F6:  GOTO   0B2 (RETURN)
02F7:  MOVF   49,W
02F8:  BTFSC  03.2
02F9:  GOTO   367
02FA:  MOVWF  51
02FB:  MOVF   4D,W
02FC:  BTFSC  03.2
02FD:  GOTO   367
02FE:  ADDWF  51,F
02FF:  BTFSC  03.0
0300:  GOTO   308
0301:  MOVLW  7F
0302:  SUBWF  51,F
0303:  BTFSS  03.0
0304:  GOTO   367
0305:  BTFSC  03.2
0306:  GOTO   367
0307:  GOTO   30C
0308:  MOVLW  81
0309:  ADDWF  51,F
030A:  BTFSC  03.0
030B:  GOTO   367
030C:  MOVF   51,W
030D:  MOVWF  77
030E:  CLRF   78
030F:  CLRF   79
0310:  CLRF   7A
0311:  MOVF   4A,W
0312:  MOVWF  55
0313:  BSF    55.7
0314:  MOVF   4B,W
0315:  MOVWF  54
0316:  MOVF   4C,W
0317:  MOVWF  53
0318:  MOVLW  18
0319:  MOVWF  51
031A:  CLRF   52
031B:  BTFSS  53.0
031C:  GOTO   335
031D:  MOVF   50,W
031E:  ADDWF  7A,F
031F:  BTFSS  03.0
0320:  GOTO   327
0321:  INCF   79,F
0322:  BTFSS  03.2
0323:  GOTO   327
0324:  INCF   78,F
0325:  BTFSC  03.2
0326:  BSF    52.7
0327:  MOVF   4F,W
0328:  ADDWF  79,F
0329:  BTFSS  03.0
032A:  GOTO   32E
032B:  INCF   78,F
032C:  BTFSC  03.2
032D:  BSF    52.7
032E:  MOVF   4E,W
032F:  MOVWF  4B
0330:  BSF    4B.7
0331:  MOVF   4B,W
0332:  ADDWF  78,F
0333:  BTFSC  03.0
0334:  BSF    52.7
0335:  RLF    52,F
0336:  RRF    78,F
0337:  RRF    79,F
0338:  RRF    7A,F
0339:  RRF    55,F
033A:  RRF    54,F
033B:  RRF    53,F
033C:  BCF    03.0
033D:  DECFSZ 51,F
033E:  GOTO   31A
033F:  MOVLW  01
0340:  ADDWF  77,F
0341:  BTFSC  03.0
0342:  GOTO   367
0343:  BTFSC  78.7
0344:  GOTO   34C
0345:  RLF    55,F
0346:  RLF    7A,F
0347:  RLF    79,F
0348:  RLF    78,F
0349:  DECF   77,F
034A:  BTFSC  03.2
034B:  GOTO   367
034C:  BTFSS  55.7
034D:  GOTO   35D
034E:  INCF   7A,F
034F:  BTFSS  03.2
0350:  GOTO   35D
0351:  INCF   79,F
0352:  BTFSS  03.2
0353:  GOTO   35D
0354:  INCF   78,F
0355:  BTFSS  03.2
0356:  GOTO   35D
0357:  RRF    78,F
0358:  RRF    79,F
0359:  RRF    7A,F
035A:  INCF   77,F
035B:  BTFSC  03.2
035C:  GOTO   367
035D:  MOVF   4A,W
035E:  MOVWF  52
035F:  MOVF   4E,W
0360:  XORWF  52,F
0361:  BTFSS  52.7
0362:  GOTO   365
0363:  BSF    78.7
0364:  GOTO   36B
0365:  BCF    78.7
0366:  GOTO   36B
0367:  CLRF   77
0368:  CLRF   78
0369:  CLRF   79
036A:  CLRF   7A
036B:  RETURN
036C:  MOVF   49,W
036D:  SUBLW  B6
036E:  MOVWF  49
036F:  CLRF   7A
0370:  MOVF   4A,W
0371:  MOVWF  4D
0372:  BSF    4A.7
0373:  BCF    03.0
0374:  RRF    4A,F
0375:  RRF    4B,F
0376:  RRF    4C,F
0377:  RRF    7A,F
0378:  RRF    79,F
0379:  RRF    78,F
037A:  RRF    77,F
037B:  DECFSZ 49,F
037C:  GOTO   373
037D:  BTFSS  4D.7
037E:  GOTO   38A
037F:  COMF   77,F
0380:  COMF   78,F
0381:  COMF   79,F
0382:  COMF   7A,F
0383:  INCF   77,F
0384:  BTFSC  03.2
0385:  INCF   78,F
0386:  BTFSC  03.2
0387:  INCF   79,F
0388:  BTFSC  03.2
0389:  INCF   7A,F
038A:  RETURN
038B:  BTFSC  03.1
038C:  GOTO   390
038D:  MOVLW  51
038E:  MOVWF  04
038F:  BCF    03.7
0390:  CLRF   77
0391:  CLRF   78
0392:  CLRF   79
0393:  CLRF   7A
0394:  CLRF   51
0395:  CLRF   52
0396:  CLRF   53
0397:  CLRF   54
0398:  MOVF   50,W
0399:  IORWF  4F,W
039A:  IORWF  4E,W
039B:  IORWF  4D,W
039C:  BTFSC  03.2
039D:  GOTO   3CE
039E:  MOVLW  20
039F:  MOVWF  55
03A0:  BCF    03.0
03A1:  RLF    49,F
03A2:  RLF    4A,F
03A3:  RLF    4B,F
03A4:  RLF    4C,F
03A5:  RLF    51,F
03A6:  RLF    52,F
03A7:  RLF    53,F
03A8:  RLF    54,F
03A9:  MOVF   50,W
03AA:  SUBWF  54,W
03AB:  BTFSS  03.2
03AC:  GOTO   3B7
03AD:  MOVF   4F,W
03AE:  SUBWF  53,W
03AF:  BTFSS  03.2
03B0:  GOTO   3B7
03B1:  MOVF   4E,W
03B2:  SUBWF  52,W
03B3:  BTFSS  03.2
03B4:  GOTO   3B7
03B5:  MOVF   4D,W
03B6:  SUBWF  51,W
03B7:  BTFSS  03.0
03B8:  GOTO   3C8
03B9:  MOVF   4D,W
03BA:  SUBWF  51,F
03BB:  MOVF   4E,W
03BC:  BTFSS  03.0
03BD:  INCFSZ 4E,W
03BE:  SUBWF  52,F
03BF:  MOVF   4F,W
03C0:  BTFSS  03.0
03C1:  INCFSZ 4F,W
03C2:  SUBWF  53,F
03C3:  MOVF   50,W
03C4:  BTFSS  03.0
03C5:  INCFSZ 50,W
03C6:  SUBWF  54,F
03C7:  BSF    03.0
03C8:  RLF    77,F
03C9:  RLF    78,F
03CA:  RLF    79,F
03CB:  RLF    7A,F
03CC:  DECFSZ 55,F
03CD:  GOTO   3A0
03CE:  MOVF   51,W
03CF:  MOVWF  00
03D0:  INCF   04,F
03D1:  MOVF   52,W
03D2:  MOVWF  00
03D3:  INCF   04,F
03D4:  MOVF   53,W
03D5:  MOVWF  00
03D6:  INCF   04,F
03D7:  MOVF   54,W
03D8:  MOVWF  00
03D9:  RETURN
03DA:  MOVF   04,W
03DB:  MOVWF  41
03DC:  MOVF   40,W
03DD:  MOVWF  43
03DE:  BTFSC  03.2
03DF:  GOTO   3F9
03E0:  MOVF   3F,W
03E1:  MOVWF  4C
03E2:  MOVF   3E,W
03E3:  MOVWF  4B
03E4:  MOVF   3D,W
03E5:  MOVWF  4A
03E6:  MOVF   3C,W
03E7:  MOVWF  49
03E8:  CLRF   50
03E9:  CLRF   4F
03EA:  MOVLW  20
03EB:  MOVWF  4E
03EC:  MOVLW  82
03ED:  MOVWF  4D
03EE:  CALL   2F7
03EF:  MOVF   7A,W
03F0:  MOVWF  3F
03F1:  MOVF   79,W
03F2:  MOVWF  3E
03F3:  MOVF   78,W
03F4:  MOVWF  3D
03F5:  MOVF   77,W
03F6:  MOVWF  3C
03F7:  DECFSZ 43,F
03F8:  GOTO   3E0
03F9:  MOVF   3F,W
03FA:  MOVWF  4C
03FB:  MOVF   3E,W
03FC:  MOVWF  4B
03FD:  MOVF   3D,W
03FE:  MOVWF  4A
03FF:  MOVF   3C,W
0400:  MOVWF  49
0401:  CALL   36C
0402:  MOVF   7A,W
0403:  MOVWF  3F
0404:  MOVF   79,W
0405:  MOVWF  3E
0406:  MOVF   78,W
0407:  MOVWF  3D
0408:  MOVF   77,W
0409:  MOVWF  3C
040A:  BTFSS  3F.7
040B:  GOTO   419
040C:  DECF   41,F
040D:  BSF    41.5
040E:  COMF   3C,F
040F:  COMF   3D,F
0410:  COMF   3E,F
0411:  COMF   3F,F
0412:  INCF   3C,F
0413:  BTFSC  03.2
0414:  INCF   3D,F
0415:  BTFSC  03.2
0416:  INCF   3E,F
0417:  BTFSC  03.2
0418:  INCF   3F,F
0419:  MOVLW  3B
041A:  MOVWF  48
041B:  MOVLW  9A
041C:  MOVWF  47
041D:  MOVLW  CA
041E:  MOVWF  46
041F:  CLRF   45
0420:  MOVLW  0A
0421:  MOVWF  43
0422:  MOVF   40,W
0423:  BTFSC  03.2
0424:  INCF   41,F
0425:  BSF    03.1
0426:  MOVLW  3C
0427:  MOVWF  04
0428:  BCF    03.7
0429:  MOVF   3F,W
042A:  MOVWF  4C
042B:  MOVF   3E,W
042C:  MOVWF  4B
042D:  MOVF   3D,W
042E:  MOVWF  4A
042F:  MOVF   3C,W
0430:  MOVWF  49
0431:  MOVF   48,W
0432:  MOVWF  50
0433:  MOVF   47,W
0434:  MOVWF  4F
0435:  MOVF   46,W
0436:  MOVWF  4E
0437:  MOVF   45,W
0438:  MOVWF  4D
0439:  CALL   38B
043A:  MOVF   78,W
043B:  MOVF   77,F
043C:  BTFSS  03.2
043D:  GOTO   451
043E:  INCF   40,W
043F:  SUBWF  43,W
0440:  BTFSC  03.2
0441:  GOTO   451
0442:  MOVF   41,W
0443:  BTFSC  03.2
0444:  GOTO   453
0445:  ANDLW  0F
0446:  SUBWF  43,W
0447:  BTFSC  03.2
0448:  GOTO   44B
0449:  BTFSC  03.0
044A:  GOTO   483
044B:  BTFSC  41.7
044C:  GOTO   483
044D:  BTFSC  41.6
044E:  GOTO   453
044F:  MOVLW  20
0450:  GOTO   47F
0451:  MOVLW  20
0452:  ANDWF  41,F
0453:  BTFSS  41.5
0454:  GOTO   461
0455:  BCF    41.5
0456:  MOVF   40,W
0457:  BTFSS  03.2
0458:  DECF   41,F
0459:  MOVF   77,W
045A:  MOVWF  41
045B:  MOVLW  2D
045C:  MOVWF  49
045D:  CALL   130
045E:  MOVF   41,W
045F:  MOVWF  77
0460:  CLRF   41
0461:  MOVF   40,W
0462:  SUBWF  43,W
0463:  BTFSS  03.2
0464:  GOTO   46F
0465:  MOVF   77,W
0466:  MOVWF  41
0467:  MOVLW  2E
0468:  MOVWF  49
0469:  CALL   130
046A:  MOVF   41,W
046B:  MOVWF  77
046C:  MOVLW  20
046D:  ANDWF  41,F
046E:  MOVLW  00
046F:  MOVLW  30
0470:  BTFSS  41.5
0471:  GOTO   47F
0472:  BCF    41.5
0473:  MOVF   40,W
0474:  BTFSS  03.2
0475:  DECF   41,F
0476:  MOVF   77,W
0477:  MOVWF  41
0478:  MOVLW  2D
0479:  MOVWF  49
047A:  CALL   130
047B:  MOVF   41,W
047C:  MOVWF  77
047D:  CLRF   41
047E:  MOVLW  30
047F:  ADDWF  77,F
0480:  MOVF   77,W
0481:  MOVWF  49
0482:  CALL   130
0483:  BCF    03.1
0484:  MOVF   48,W
0485:  MOVWF  4C
0486:  MOVF   47,W
0487:  MOVWF  4B
0488:  MOVF   46,W
0489:  MOVWF  4A
048A:  MOVF   45,W
048B:  MOVWF  49
048C:  CLRF   50
048D:  CLRF   4F
048E:  CLRF   4E
048F:  MOVLW  0A
0490:  MOVWF  4D
0491:  CALL   38B
0492:  MOVF   7A,W
0493:  MOVWF  48
0494:  MOVF   79,W
0495:  MOVWF  47
0496:  MOVF   78,W
0497:  MOVWF  46
0498:  MOVF   77,W
0499:  MOVWF  45
049A:  DECFSZ 43,F
049B:  GOTO   425
049C:  BSF    0A.3
049D:  BCF    0A.4
049E:  GOTO   0DB (RETURN)
*
04EF:  CLRF   77
04F0:  CLRF   78
04F1:  MOVF   3E,W
04F2:  BCF    03.0
04F3:  BTFSC  3F.0
04F4:  ADDWF  77,F
04F5:  RRF    77,F
04F6:  RRF    78,F
04F7:  BTFSC  3F.1
04F8:  ADDWF  77,F
04F9:  RRF    77,F
04FA:  RRF    78,F
04FB:  BTFSC  3F.2
04FC:  ADDWF  77,F
04FD:  RRF    77,F
04FE:  RRF    78,F
04FF:  BTFSC  3F.3
0500:  ADDWF  77,F
0501:  RRF    77,F
0502:  RRF    78,F
0503:  BTFSC  3F.4
0504:  ADDWF  77,F
0505:  RRF    77,F
0506:  RRF    78,F
0507:  BTFSC  3F.5
0508:  ADDWF  77,F
0509:  RRF    77,F
050A:  RRF    78,F
050B:  BTFSC  3F.6
050C:  ADDWF  77,F
050D:  RRF    77,F
050E:  RRF    78,F
050F:  BTFSC  3F.7
0510:  ADDWF  77,F
0511:  RRF    77,F
0512:  RRF    78,F
*
05AE:  MOVF   0B,W
05AF:  MOVWF  3D
05B0:  BCF    0B.7
05B1:  BSF    03.5
05B2:  BSF    03.6
05B3:  BSF    0C.7
05B4:  BSF    0C.0
05B5:  NOP
05B6:  NOP
05B7:  BCF    03.5
05B8:  BCF    03.6
05B9:  BTFSC  3D.7
05BA:  BSF    0B.7
05BB:  BTFSC  03.0
05BC:  GOTO   5E6
05BD:  BSF    03.6
05BE:  MOVF   0C,W
05BF:  ANDLW  7F
05C0:  BCF    03.6
05C1:  MOVWF  3D
05C2:  BSF    03.6
05C3:  MOVF   0D,W
05C4:  BCF    03.6
05C5:  MOVWF  3E
05C6:  BSF    03.6
05C7:  MOVF   0F,W
05C8:  BCF    03.6
05C9:  MOVWF  3F
05CA:  MOVF   3D,W
05CB:  BTFSS  0C.4
05CC:  GOTO   5CB
05CD:  MOVWF  19
05CE:  MOVF   3E,W
05CF:  BSF    03.6
05D0:  MOVWF  0D
05D1:  BCF    03.6
05D2:  MOVF   3F,W
05D3:  BSF    03.6
05D4:  MOVWF  0F
05D5:  BCF    03.6
05D6:  MOVF   0B,W
05D7:  MOVWF  40
05D8:  BCF    0B.7
05D9:  BSF    03.5
05DA:  BSF    03.6
05DB:  BSF    0C.7
05DC:  BSF    0C.0
05DD:  NOP
05DE:  NOP
05DF:  BCF    03.5
05E0:  BCF    03.6
05E1:  BTFSC  40.7
05E2:  BSF    0B.7
05E3:  DECFSZ 3C,F
05E4:  GOTO   5E6
05E5:  GOTO   606
05E6:  BSF    03.6
05E7:  RLF    0C,W
05E8:  RLF    0E,W
05E9:  ANDLW  7F
05EA:  BCF    03.6
05EB:  MOVWF  3D
05EC:  BSF    03.6
05ED:  MOVF   0D,W
05EE:  BCF    03.6
05EF:  MOVWF  3E
05F0:  BSF    03.6
05F1:  MOVF   0F,W
05F2:  BCF    03.6
05F3:  MOVWF  3F
05F4:  MOVF   3D,W
05F5:  BTFSS  0C.4
05F6:  GOTO   5F5
05F7:  MOVWF  19
05F8:  MOVF   3E,W
05F9:  BSF    03.6
05FA:  MOVWF  0D
05FB:  BCF    03.6
05FC:  MOVF   3F,W
05FD:  BSF    03.6
05FE:  MOVWF  0F
05FF:  INCF   0D,F
0600:  BTFSC  03.2
0601:  INCF   0F,F
0602:  BCF    03.0
0603:  BCF    03.6
0604:  DECFSZ 3C,F
0605:  GOTO   5AE
0606:  RETURN
0607:  MOVF   00,F
0608:  BTFSC  03.2
0609:  GOTO   61D
060A:  CLRF   3D
060B:  MOVF   04,W
060C:  MOVWF  3C
060D:  BCF    3D.0
060E:  BTFSC  03.7
060F:  BSF    3D.0
0610:  MOVF   00,W
0611:  BTFSS  0C.4
0612:  GOTO   611
0613:  MOVWF  19
0614:  MOVF   3C,W
0615:  MOVWF  04
0616:  BCF    03.7
0617:  BTFSC  3D.0
0618:  BSF    03.7
0619:  INCF   04,F
061A:  BTFSC  03.2
061B:  INCF   05,F
061C:  GOTO   607
061D:  BSF    0A.3
061E:  BCF    0A.4
061F:  GOTO   1FE (RETURN)
0620:  MOVF   04,W
0621:  MOVWF  41
0622:  MOVF   40,W
0623:  MOVWF  43
0624:  BTFSC  03.2
0625:  GOTO   63F
0626:  MOVF   3F,W
0627:  MOVWF  4C
0628:  MOVF   3E,W
0629:  MOVWF  4B
062A:  MOVF   3D,W
062B:  MOVWF  4A
062C:  MOVF   3C,W
062D:  MOVWF  49
062E:  CLRF   50
062F:  CLRF   4F
0630:  MOVLW  20
0631:  MOVWF  4E
0632:  MOVLW  82
0633:  MOVWF  4D
0634:  CALL   2F7
0635:  MOVF   7A,W
0636:  MOVWF  3F
0637:  MOVF   79,W
0638:  MOVWF  3E
0639:  MOVF   78,W
063A:  MOVWF  3D
063B:  MOVF   77,W
063C:  MOVWF  3C
063D:  DECFSZ 43,F
063E:  GOTO   626
063F:  MOVF   3F,W
0640:  MOVWF  4C
0641:  MOVF   3E,W
0642:  MOVWF  4B
0643:  MOVF   3D,W
0644:  MOVWF  4A
0645:  MOVF   3C,W
0646:  MOVWF  49
0647:  CALL   36C
0648:  MOVF   7A,W
0649:  MOVWF  3F
064A:  MOVF   79,W
064B:  MOVWF  3E
064C:  MOVF   78,W
064D:  MOVWF  3D
064E:  MOVF   77,W
064F:  MOVWF  3C
0650:  BTFSS  3F.7
0651:  GOTO   65F
0652:  DECF   41,F
0653:  BSF    41.5
0654:  COMF   3C,F
0655:  COMF   3D,F
0656:  COMF   3E,F
0657:  COMF   3F,F
0658:  INCF   3C,F
0659:  BTFSC  03.2
065A:  INCF   3D,F
065B:  BTFSC  03.2
065C:  INCF   3E,F
065D:  BTFSC  03.2
065E:  INCF   3F,F
065F:  MOVLW  3B
0660:  MOVWF  48
0661:  MOVLW  9A
0662:  MOVWF  47
0663:  MOVLW  CA
0664:  MOVWF  46
0665:  CLRF   45
0666:  MOVLW  0A
0667:  MOVWF  43
0668:  MOVF   40,W
0669:  BTFSC  03.2
066A:  INCF   41,F
066B:  BSF    03.1
066C:  MOVLW  3C
066D:  MOVWF  04
066E:  BCF    03.7
066F:  MOVF   3F,W
0670:  MOVWF  4C
0671:  MOVF   3E,W
0672:  MOVWF  4B
0673:  MOVF   3D,W
0674:  MOVWF  4A
0675:  MOVF   3C,W
0676:  MOVWF  49
0677:  MOVF   48,W
0678:  MOVWF  50
0679:  MOVF   47,W
067A:  MOVWF  4F
067B:  MOVF   46,W
067C:  MOVWF  4E
067D:  MOVF   45,W
067E:  MOVWF  4D
067F:  CALL   38B
0680:  MOVF   78,W
0681:  MOVF   77,F
0682:  BTFSS  03.2
0683:  GOTO   697
0684:  INCF   40,W
0685:  SUBWF  43,W
0686:  BTFSC  03.2
0687:  GOTO   697
0688:  MOVF   41,W
0689:  BTFSC  03.2
068A:  GOTO   699
068B:  ANDLW  0F
068C:  SUBWF  43,W
068D:  BTFSC  03.2
068E:  GOTO   691
068F:  BTFSC  03.0
0690:  GOTO   6CD
0691:  BTFSC  41.7
0692:  GOTO   6CD
0693:  BTFSC  41.6
0694:  GOTO   699
0695:  MOVLW  20
0696:  GOTO   6C8
0697:  MOVLW  20
0698:  ANDWF  41,F
0699:  BTFSS  41.5
069A:  GOTO   6A8
069B:  BCF    41.5
069C:  MOVF   40,W
069D:  BTFSS  03.2
069E:  DECF   41,F
069F:  MOVF   77,W
06A0:  MOVWF  41
06A1:  MOVLW  2D
06A2:  BTFSS  0C.4
06A3:  GOTO   6A2
06A4:  MOVWF  19
06A5:  MOVF   41,W
06A6:  MOVWF  77
06A7:  CLRF   41
06A8:  MOVF   40,W
06A9:  SUBWF  43,W
06AA:  BTFSS  03.2
06AB:  GOTO   6B7
06AC:  MOVF   77,W
06AD:  MOVWF  41
06AE:  MOVLW  2E
06AF:  BTFSS  0C.4
06B0:  GOTO   6AF
06B1:  MOVWF  19
06B2:  MOVF   41,W
06B3:  MOVWF  77
06B4:  MOVLW  20
06B5:  ANDWF  41,F
06B6:  MOVLW  00
06B7:  MOVLW  30
06B8:  BTFSS  41.5
06B9:  GOTO   6C8
06BA:  BCF    41.5
06BB:  MOVF   40,W
06BC:  BTFSS  03.2
06BD:  DECF   41,F
06BE:  MOVF   77,W
06BF:  MOVWF  41
06C0:  MOVLW  2D
06C1:  BTFSS  0C.4
06C2:  GOTO   6C1
06C3:  MOVWF  19
06C4:  MOVF   41,W
06C5:  MOVWF  77
06C6:  CLRF   41
06C7:  MOVLW  30
06C8:  ADDWF  77,F
06C9:  MOVF   77,W
06CA:  BTFSS  0C.4
06CB:  GOTO   6CA
06CC:  MOVWF  19
06CD:  BCF    03.1
06CE:  MOVF   48,W
06CF:  MOVWF  4C
06D0:  MOVF   47,W
06D1:  MOVWF  4B
06D2:  MOVF   46,W
06D3:  MOVWF  4A
06D4:  MOVF   45,W
06D5:  MOVWF  49
06D6:  CLRF   50
06D7:  CLRF   4F
06D8:  CLRF   4E
06D9:  MOVLW  0A
06DA:  MOVWF  4D
06DB:  CALL   38B
06DC:  MOVF   7A,W
06DD:  MOVWF  48
06DE:  MOVF   79,W
06DF:  MOVWF  47
06E0:  MOVF   78,W
06E1:  MOVWF  46
06E2:  MOVF   77,W
06E3:  MOVWF  45
06E4:  DECFSZ 43,F
06E5:  GOTO   66B
06E6:  BSF    0A.3
06E7:  BCF    0A.4
06E8:  GOTO   219 (RETURN)
06E9:  MOVF   3D,W
06EA:  MOVWF  44
06EB:  MOVF   41,W
06EC:  XORWF  44,F
06ED:  BTFSS  44.7
06EE:  GOTO   6F4
06EF:  BCF    03.2
06F0:  BCF    03.0
06F1:  BTFSC  3D.7
06F2:  BSF    03.0
06F3:  GOTO   727
06F4:  MOVF   3D,W
06F5:  MOVWF  44
06F6:  MOVF   40,W
06F7:  MOVWF  45
06F8:  MOVF   3C,W
06F9:  SUBWF  45,F
06FA:  BTFSC  03.2
06FB:  GOTO   702
06FC:  BTFSS  44.7
06FD:  GOTO   727
06FE:  MOVF   03,W
06FF:  XORLW  01
0700:  MOVWF  03
0701:  GOTO   727
0702:  MOVF   41,W
0703:  MOVWF  45
0704:  MOVF   3D,W
0705:  SUBWF  45,F
0706:  BTFSC  03.2
0707:  GOTO   70E
0708:  BTFSS  44.7
0709:  GOTO   727
070A:  MOVF   03,W
070B:  XORLW  01
070C:  MOVWF  03
070D:  GOTO   727
070E:  MOVF   42,W
070F:  MOVWF  45
0710:  MOVF   3E,W
0711:  SUBWF  45,F
0712:  BTFSC  03.2
0713:  GOTO   71A
0714:  BTFSS  44.7
0715:  GOTO   727
0716:  MOVF   03,W
0717:  XORLW  01
0718:  MOVWF  03
0719:  GOTO   727
071A:  MOVF   43,W
071B:  MOVWF  45
071C:  MOVF   3F,W
071D:  SUBWF  45,F
071E:  BTFSC  03.2
071F:  GOTO   726
0720:  BTFSS  44.7
0721:  GOTO   727
0722:  MOVF   03,W
0723:  XORLW  01
0724:  MOVWF  03
0725:  GOTO   727
0726:  BCF    03.0
0727:  RETURN
.................... 
.................... #list
.................... 
.................... //Fuses, allow system comm and pin control
.................... #fuses HS,XT,NOWDT,PUT,NOPROTECT,NOLVP,BROWNOUT,NOCPD,NOWRT,NODEBUG
.................... //Allows strings management
.................... #device PASS_STRINGS = IN_RAM
.................... //Indicates pic model
.................... #device *=16
.................... //ADC PIN 
.................... #device adc=10
.................... //Set 4hz clock 
.................... #use delay(clock=4M)
*
0079:  MOVLW  4A
007A:  MOVWF  04
007B:  BCF    03.7
007C:  MOVF   00,W
007D:  BTFSC  03.2
007E:  GOTO   08D
007F:  MOVLW  01
0080:  MOVWF  78
0081:  CLRF   77
0082:  DECFSZ 77,F
0083:  GOTO   082
0084:  DECFSZ 78,F
0085:  GOTO   081
0086:  MOVLW  4A
0087:  MOVWF  77
0088:  DECFSZ 77,F
0089:  GOTO   088
008A:  GOTO   08B
008B:  DECFSZ 00,F
008C:  GOTO   07F
008D:  RETURN
.................... //LCD ports
.................... #define use_portd_lcd true
.................... //Keypad KBD ports
.................... #define use_portb_kbd true
.................... //LCD library
.................... #include<lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
....................    output_float(LCD_DATA5);
....................    output_float(LCD_DATA6);
....................    output_float(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0xF;
*
00A6:  MOVLW  0F
00A7:  BSF    03.5
00A8:  ANDWF  08,W
00A9:  IORLW  F0
00AA:  MOVWF  08
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
00AB:  BCF    03.5
00AC:  BSF    08.2
....................    delay_cycles(1);
00AD:  NOP
....................    lcd_output_enable(1);
00AE:  BSF    08.0
....................    delay_cycles(1);
00AF:  NOP
....................    high = lcd_read_nibble();
00B0:  CALL   09A
00B1:  MOVF   78,W
00B2:  MOVWF  51
....................       
....................    lcd_output_enable(0);
00B3:  BCF    08.0
....................    delay_cycles(1);
00B4:  NOP
....................    lcd_output_enable(1);
00B5:  BSF    08.0
....................    delay_us(1);
00B6:  NOP
....................    low = lcd_read_nibble();
00B7:  CALL   09A
00B8:  MOVF   78,W
00B9:  MOVWF  50
....................       
....................    lcd_output_enable(0);
00BA:  BCF    08.0
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
00BB:  MOVLW  0F
00BC:  BSF    03.5
00BD:  ANDWF  08,W
00BE:  MOVWF  08
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
00BF:  BCF    03.5
00C0:  SWAPF  51,W
00C1:  MOVWF  77
00C2:  MOVLW  F0
00C3:  ANDWF  77,F
00C4:  MOVF   77,W
00C5:  IORWF  50,W
00C6:  MOVWF  78
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
....................    n |= input(LCD_DATA5) << 1;
....................    n |= input(LCD_DATA6) << 2;
....................    n |= input(LCD_DATA7) << 3;
....................    
....................    return(n);
....................   #else
....................    return(lcd.data);
*
009A:  MOVF   08,W
009B:  MOVWF  77
009C:  SWAPF  08,W
009D:  ANDLW  0F
009E:  MOVWF  78
....................   #endif
009F:  RETURN
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
....................    output_bit(LCD_DATA5, bit_test(n, 1));
....................    output_bit(LCD_DATA6, bit_test(n, 2));
....................    output_bit(LCD_DATA7, bit_test(n, 3));
....................   #else      
....................    lcdlat.data = n;
*
008E:  SWAPF  51,W
008F:  ANDLW  F0
0090:  MOVWF  77
0091:  MOVLW  0F
0092:  ANDWF  08,W
0093:  IORWF  77,W
0094:  MOVWF  08
....................   #endif
....................       
....................    delay_cycles(1);
0095:  NOP
....................    lcd_output_enable(1);
0096:  BSF    08.0
....................    delay_us(2);
0097:  GOTO   098
....................    lcd_output_enable(0);
0098:  BCF    08.0
0099:  RETURN
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
00A0:  BSF    03.5
00A1:  BCF    08.0
....................    lcd_rs_tris();
00A2:  BCF    08.1
....................    lcd_rw_tris();
00A3:  BCF    08.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
00A4:  BCF    03.5
00A5:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ;
*
00C7:  MOVF   78,W
00C8:  MOVWF  50
00C9:  BTFSC  50.7
00CA:  GOTO   0A6
....................    lcd_output_rs(address);
00CB:  BTFSS  4E.0
00CC:  BCF    08.1
00CD:  BTFSC  4E.0
00CE:  BSF    08.1
....................    delay_cycles(1);
00CF:  NOP
....................    lcd_output_rw(0);
00D0:  BCF    08.2
....................    delay_cycles(1);
00D1:  NOP
....................    lcd_output_enable(0);
00D2:  BCF    08.0
....................    lcd_send_nibble(n >> 4);
00D3:  SWAPF  4F,W
00D4:  MOVWF  50
00D5:  MOVLW  0F
00D6:  ANDWF  50,F
00D7:  MOVF   50,W
00D8:  MOVWF  51
00D9:  CALL   08E
....................    lcd_send_nibble(n & 0xf);
00DA:  MOVF   4F,W
00DB:  ANDLW  0F
00DC:  MOVWF  50
00DD:  MOVWF  51
00DE:  CALL   08E
00DF:  RETURN
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
00E0:  MOVLW  28
00E1:  MOVWF  3D
00E2:  MOVLW  0C
00E3:  MOVWF  3E
00E4:  MOVLW  01
00E5:  MOVWF  3F
00E6:  MOVLW  06
00E7:  MOVWF  40
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
00E8:  BCF    08.0
....................    lcd_output_rs(0);
00E9:  BCF    08.1
....................    lcd_output_rw(0);
00EA:  BCF    08.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
00EB:  MOVLW  0F
00EC:  BSF    03.5
00ED:  ANDWF  08,W
00EE:  MOVWF  08
....................   #endif
....................    lcd_enable_tris();
00EF:  BCF    08.0
....................    lcd_rs_tris();
00F0:  BCF    08.1
....................    lcd_rw_tris();
00F1:  BCF    08.2
....................  #endif
....................     
....................    delay_ms(15);
00F2:  MOVLW  0F
00F3:  BCF    03.5
00F4:  MOVWF  4A
00F5:  CALL   079
....................    for(i=1;i<=3;++i)
00F6:  MOVLW  01
00F7:  MOVWF  3C
00F8:  MOVF   3C,W
00F9:  SUBLW  03
00FA:  BTFSS  03.0
00FB:  GOTO   104
....................    {
....................        lcd_send_nibble(3);
00FC:  MOVLW  03
00FD:  MOVWF  51
00FE:  CALL   08E
....................        delay_ms(5);
00FF:  MOVLW  05
0100:  MOVWF  4A
0101:  CALL   079
0102:  INCF   3C,F
0103:  GOTO   0F8
....................    }
....................    
....................    lcd_send_nibble(2);
0104:  MOVLW  02
0105:  MOVWF  51
0106:  CALL   08E
....................    delay_ms(5);
0107:  MOVLW  05
0108:  MOVWF  4A
0109:  CALL   079
....................    for(i=0;i<=3;++i)
010A:  CLRF   3C
010B:  MOVF   3C,W
010C:  SUBLW  03
010D:  BTFSS  03.0
010E:  GOTO   11B
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
010F:  MOVLW  3D
0110:  ADDWF  3C,W
0111:  MOVWF  04
0112:  BCF    03.7
0113:  MOVF   00,W
0114:  MOVWF  41
0115:  CLRF   4E
0116:  MOVF   41,W
0117:  MOVWF  4F
0118:  CALL   0A0
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0119:  INCF   3C,F
011A:  GOTO   10B
011B:  BSF    0A.3
011C:  BCF    0A.4
011D:  GOTO   044 (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
011E:  DECFSZ 4B,W
011F:  GOTO   121
0120:  GOTO   124
....................       address=LCD_LINE_TWO;
0121:  MOVLW  40
0122:  MOVWF  4C
0123:  GOTO   125
....................    else
....................       address=0;
0124:  CLRF   4C
....................      
....................    address+=x-1;
0125:  MOVLW  01
0126:  SUBWF  4A,W
0127:  ADDWF  4C,F
....................    lcd_send_byte(0,0x80|address);
0128:  MOVF   4C,W
0129:  IORLW  80
012A:  MOVWF  4D
012B:  CLRF   4E
012C:  MOVF   4D,W
012D:  MOVWF  4F
012E:  CALL   0A0
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
012F:  RETURN
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
0130:  MOVF   49,W
0131:  XORLW  07
0132:  BTFSC  03.2
0133:  GOTO   13E
0134:  XORLW  0B
0135:  BTFSC  03.2
0136:  GOTO   143
0137:  XORLW  06
0138:  BTFSC  03.2
0139:  GOTO   14B
013A:  XORLW  02
013B:  BTFSC  03.2
013C:  GOTO   151
013D:  GOTO   156
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
013E:  MOVLW  01
013F:  MOVWF  4A
0140:  MOVWF  4B
0141:  CALL   11E
0142:  GOTO   15B
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
0143:  CLRF   4E
0144:  MOVLW  01
0145:  MOVWF  4F
0146:  CALL   0A0
....................                      delay_ms(2);
0147:  MOVLW  02
0148:  MOVWF  4A
0149:  CALL   079
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
014A:  GOTO   15B
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
014B:  MOVLW  01
014C:  MOVWF  4A
014D:  MOVLW  02
014E:  MOVWF  4B
014F:  CALL   11E
0150:  GOTO   15B
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
0151:  CLRF   4E
0152:  MOVLW  10
0153:  MOVWF  4F
0154:  CALL   0A0
0155:  GOTO   15B
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
0156:  MOVLW  01
0157:  MOVWF  4E
0158:  MOVF   49,W
0159:  MOVWF  4F
015A:  CALL   0A0
....................      #endif
....................    }
015B:  RETURN
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... //KBD Library
.................... #include<kbd.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             KBD.C                                 ////
.................... ////                  Generic keypad scan driver                       ////
.................... ////                                                                   ////
.................... ////  kbd_init()   Must be called before any other function.           ////
.................... ////                                                                   ////
.................... ////  c = kbd_getc()  Will return a key value if pressed or /0 if not  ////
.................... ////                   This function should be called frequently so as ////
.................... ////                   not to miss a key press.                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////// The following defines the keypad layout on port D
.................... 
.................... // Un-comment the following define to use port B
.................... // #define use_portb_kbd TRUE
.................... 
.................... // Make sure the port used has pull-up resistors (or the LCD) on
.................... // the column pins
.................... 
.................... #if defined use_portb_kbd
....................    #byte kbd = getenv("SFR:PORTB")
.................... #else
....................    #byte kbd = getenv("SFR:PORTD")
.................... #endif
.................... 
.................... #if defined use_portb_kbd
....................    #define set_tris_kbd(x) set_tris_b(x)
.................... #else
....................    #define set_tris_kbd(x) set_tris_d(x)
.................... #endif
.................... 
.................... //Keypad connection:   (for example column 0 is B2)
.................... //                Bx:
.................... 
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad
.................... #define COL0 (1 << 2)
.................... #define COL1 (1 << 3)
.................... #define COL2 (1 << 6)
.................... 
.................... #define ROW0 (1 << 4)
.................... #define ROW1 (1 << 7)
.................... #define ROW2 (1 << 1)
.................... #define ROW3 (1 << 5)
.................... 
.................... #else ////////////////////////////////////////////////// For the black keypad
.................... #define COL0 (1 << 5)
.................... #define COL1 (1 << 6)
.................... #define COL2 (1 << 7)
.................... 
.................... #define ROW0 (1 << 1)
.................... #define ROW1 (1 << 2)
.................... #define ROW2 (1 << 3)
.................... #define ROW3 (1 << 4)
.................... 
.................... #endif
.................... 
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3)
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2)
.................... 
.................... // Keypad layout:
.................... char const KEYS[4][3] = {{'1','2','3'},
....................                          {'4','5','6'},
....................                          {'7','8','9'},
....................                          {'*','0','#'}};
.................... 
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where
....................                                   // n is the number of times you expect
....................                                   // to call kbd_getc each second
.................... 
.................... 
.................... void kbd_init() {
*
0209:  BSF    0A.3
020A:  BCF    0A.4
020B:  GOTO   085 (RETURN)
.................... }
.................... 
.................... char kbd_getc( ) {
....................    static BYTE kbd_call_count;
*
0817:  BCF    03.5
0818:  CLRF   20
....................    static int1 kbd_down;
0819:  BCF    21.0
....................    static char last_key;
081A:  CLRF   22
....................    static BYTE col;
081B:  CLRF   23
.................... 
....................    BYTE kchar;
....................    BYTE row;
.................... 
....................    kchar='\0';
*
049F:  CLRF   3C
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) {
04A0:  INCF   20,F
04A1:  MOVF   20,W
04A2:  SUBLW  21
04A3:  BTFSC  03.0
04A4:  GOTO   520
....................        switch (col) {
04A5:  MOVF   23,W
04A6:  BTFSC  03.2
04A7:  GOTO   4AF
04A8:  XORLW  01
04A9:  BTFSC  03.2
04AA:  GOTO   4B5
04AB:  XORLW  03
04AC:  BTFSC  03.2
04AD:  GOTO   4BB
04AE:  GOTO   4C0
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0);
04AF:  MOVLW  DE
04B0:  BSF    03.5
04B1:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS;
04B2:  BCF    03.5
04B3:  MOVWF  06
....................                     break;
04B4:  GOTO   4C0
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1);
04B5:  MOVLW  BE
04B6:  BSF    03.5
04B7:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS;
04B8:  BCF    03.5
04B9:  MOVWF  06
....................                     break;
04BA:  GOTO   4C0
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2);
04BB:  MOVLW  7E
04BC:  BSF    03.5
04BD:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS;
04BE:  BCF    03.5
04BF:  MOVWF  06
....................                     break;
....................        }
.................... 
....................        if(kbd_down) {
04C0:  BTFSS  21.0
04C1:  GOTO   4CC
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) {
04C2:  MOVF   06,W
04C3:  ANDLW  1E
04C4:  SUBLW  1E
04C5:  BTFSS  03.2
04C6:  GOTO   4CB
....................            kbd_down=FALSE;
04C7:  BCF    21.0
....................            kchar=last_key;
04C8:  MOVF   22,W
04C9:  MOVWF  3C
....................            last_key='\0';
04CA:  CLRF   22
....................          }
....................        } else {
04CB:  GOTO   51F
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) {
04CC:  MOVF   06,W
04CD:  ANDLW  1E
04CE:  SUBLW  1E
04CF:  BTFSC  03.2
04D0:  GOTO   51A
....................              if((kbd & ROW0)==0)
04D1:  MOVF   06,W
04D2:  ANDLW  02
04D3:  BTFSS  03.2
04D4:  GOTO   4D7
....................                row=0;
04D5:  CLRF   3D
04D6:  GOTO   4EB
....................              else if((kbd & ROW1)==0)
04D7:  MOVF   06,W
04D8:  ANDLW  04
04D9:  BTFSS  03.2
04DA:  GOTO   4DE
....................                row=1;
04DB:  MOVLW  01
04DC:  MOVWF  3D
04DD:  GOTO   4EB
....................              else if((kbd & ROW2)==0)
04DE:  MOVF   06,W
04DF:  ANDLW  08
04E0:  BTFSS  03.2
04E1:  GOTO   4E5
....................                row=2;
04E2:  MOVLW  02
04E3:  MOVWF  3D
04E4:  GOTO   4EB
....................              else if((kbd & ROW3)==0)
04E5:  MOVF   06,W
04E6:  ANDLW  10
04E7:  BTFSS  03.2
04E8:  GOTO   4EB
....................                row=3;
04E9:  MOVLW  03
04EA:  MOVWF  3D
....................              last_key =KEYS[row][col];
04EB:  MOVF   3D,W
04EC:  MOVWF  3E
04ED:  MOVLW  03
04EE:  MOVWF  3F
*
0513:  MOVF   23,W
0514:  ADDWF  78,W
0515:  CALL   004
0516:  MOVWF  78
0517:  MOVWF  22
....................              kbd_down = TRUE;
0518:  BSF    21.0
....................           } else {
0519:  GOTO   51F
....................              ++col;
051A:  INCF   23,F
....................              if(col==3)
051B:  MOVF   23,W
051C:  SUBLW  03
051D:  BTFSC  03.2
....................                col=0;
051E:  CLRF   23
....................           }
....................        }
....................       kbd_call_count=0;
051F:  CLRF   20
....................    }
....................   set_tris_kbd(ALL_PINS);
0520:  MOVLW  FE
0521:  BSF    03.5
0522:  MOVWF  06
....................   return(kchar);
0523:  BCF    03.5
0524:  MOVF   3C,W
0525:  MOVWF  78
0526:  RETURN
.................... }
.................... 
.................... //Indicate ADC reading variables
.................... #byte wpug = 0x95 
.................... #byte option_reg = 0x81
.................... #include<stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
*
056B:  MOVF   3D,W
056C:  MOVWF  42
056D:  MOVF   3C,W
056E:  MOVWF  41
056F:  MOVF   42,W
0570:  MOVWF  7A
0571:  MOVF   41,W
0572:  MOVWF  04
0573:  BCF    03.7
0574:  BTFSC  7A.0
0575:  BSF    03.7
0576:  MOVF   00,F
0577:  BTFSC  03.2
0578:  GOTO   57D
0579:  INCF   41,F
057A:  BTFSC  03.2
057B:  INCF   42,F
057C:  GOTO   56F
....................    while(*s2 != '\0' && 0<n)
057D:  MOVF   3F,W
057E:  MOVWF  7A
057F:  MOVF   3E,W
0580:  MOVWF  04
0581:  BCF    03.7
0582:  BTFSC  7A.0
0583:  BSF    03.7
0584:  MOVF   00,F
0585:  BTFSC  03.2
0586:  GOTO   5A1
0587:  MOVF   40,W
0588:  SUBLW  00
0589:  BTFSC  03.0
058A:  GOTO   5A1
....................    {
....................       *s = *s2;
058B:  MOVF   3E,W
058C:  MOVWF  04
058D:  BCF    03.7
058E:  BTFSC  3F.0
058F:  BSF    03.7
0590:  MOVF   00,W
0591:  MOVWF  45
0592:  MOVF   41,W
0593:  MOVWF  04
0594:  BCF    03.7
0595:  BTFSC  42.0
0596:  BSF    03.7
0597:  MOVF   45,W
0598:  MOVWF  00
....................       ++s;
0599:  INCF   41,F
059A:  BTFSC  03.2
059B:  INCF   42,F
....................       ++s2;
059C:  INCF   3E,F
059D:  BTFSC  03.2
059E:  INCF   3F,F
....................       --n;
059F:  DECF   40,F
05A0:  GOTO   57D
....................    }
.................... 
....................    *s = '\0';
05A1:  MOVF   41,W
05A2:  MOVWF  04
05A3:  BCF    03.7
05A4:  BTFSC  42.0
05A5:  BSF    03.7
05A6:  CLRF   00
....................    return(s1);
05A7:  MOVF   3C,W
05A8:  MOVWF  78
05A9:  MOVF   3D,W
05AA:  MOVWF  79
05AB:  BSF    0A.3
05AC:  BCF    0A.4
05AD:  GOTO   1CC (RETURN)
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
*
0527:  MOVF   3F,W
0528:  MOVWF  7A
0529:  MOVF   3E,W
052A:  MOVWF  04
052B:  BCF    03.7
052C:  BTFSC  7A.0
052D:  BSF    03.7
052E:  MOVF   00,W
052F:  MOVWF  42
0530:  MOVF   41,W
0531:  MOVWF  7A
0532:  MOVF   40,W
0533:  MOVWF  04
0534:  BCF    03.7
0535:  BTFSC  7A.0
0536:  BSF    03.7
0537:  MOVF   00,W
0538:  SUBWF  42,W
0539:  BTFSS  03.2
053A:  GOTO   552
....................       if (*s1 == '\0')
053B:  MOVF   3F,W
053C:  MOVWF  7A
053D:  MOVF   3E,W
053E:  MOVWF  04
053F:  BCF    03.7
0540:  BTFSC  7A.0
0541:  BSF    03.7
0542:  MOVF   00,F
0543:  BTFSS  03.2
0544:  GOTO   548
....................          return(0);
0545:  MOVLW  00
0546:  MOVWF  78
0547:  GOTO   56A
0548:  MOVF   3F,W
0549:  MOVWF  7A
054A:  MOVF   3E,W
054B:  INCF   3E,F
054C:  BTFSC  03.2
054D:  INCF   3F,F
054E:  INCF   40,F
054F:  BTFSC  03.2
0550:  INCF   41,F
0551:  GOTO   527
....................    return((*s1 < *s2) ? -1: 1);
0552:  MOVF   3F,W
0553:  MOVWF  7A
0554:  MOVF   3E,W
0555:  MOVWF  04
0556:  BCF    03.7
0557:  BTFSC  3F.0
0558:  BSF    03.7
0559:  MOVF   00,W
055A:  MOVWF  42
055B:  MOVF   41,W
055C:  MOVWF  7A
055D:  MOVF   40,W
055E:  MOVWF  04
055F:  BCF    03.7
0560:  BTFSC  41.0
0561:  BSF    03.7
0562:  MOVF   00,W
0563:  SUBWF  42,W
0564:  BTFSC  03.0
0565:  GOTO   568
0566:  MOVLW  FF
0567:  GOTO   569
0568:  MOVLW  01
0569:  MOVWF  78
056A:  RETURN
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
081C:  CLRF   24
081D:  CLRF   25
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... #include <ctype.h>
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... //Set UART protocol 
.................... #use rs232(baud=9600, xmit=pin_c6, rcv=pin_c7, bits=8)
.................... 
.................... float fridgeTemp; //Temperature 
.................... char k; //Character 
.................... char password[5] = "";//Password array
081E:  CLRF   2B
.................... int doorFlag = 0; //Open & close flag
.................... int userFlag = 0;// Managment Flag
.................... void main()
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  MOVLW  19
0804:  BSF    03.5
0805:  MOVWF  19
0806:  MOVLW  A6
0807:  MOVWF  18
0808:  MOVLW  90
0809:  BCF    03.5
080A:  MOVWF  18
080B:  CLRF   30
080C:  CLRF   31
080D:  MOVLW  FF
080E:  MOVWF  32
080F:  CLRF   34
0810:  CLRF   33
0811:  BSF    03.5
0812:  BSF    1F.0
0813:  BSF    1F.1
0814:  BSF    1F.2
0815:  BCF    1F.3
0816:  BCF    03.7
.................... {
....................     //Normalize output
....................     output_low(PIN_C2);
*
081F:  BCF    32.2
0820:  MOVF   32,W
0821:  BSF    03.5
0822:  MOVWF  07
0823:  BCF    03.5
0824:  BCF    07.2
....................     output_low(PIN_C0);
0825:  BCF    32.0
0826:  MOVF   32,W
0827:  BSF    03.5
0828:  MOVWF  07
0829:  BCF    03.5
082A:  BCF    07.0
....................     output_low(PIN_C1);
082B:  BCF    32.1
082C:  MOVF   32,W
082D:  BSF    03.5
082E:  MOVWF  07
082F:  BCF    03.5
0830:  BCF    07.1
....................     
....................     setup_adc_ports(RA0_ANALOG);// LM35 entry
0831:  BSF    03.5
0832:  BCF    1F.0
0833:  BSF    1F.1
0834:  BSF    1F.2
0835:  BSF    1F.3
....................     setup_adc(ADC_CLOCK_INTERNAL);
0836:  BCF    03.5
0837:  BSF    1F.6
0838:  BSF    1F.7
0839:  BSF    03.5
083A:  BSF    1F.7
083B:  BCF    03.5
083C:  BSF    1F.0
....................     
....................     option_reg = 0; //Quit OPTION
083D:  BSF    03.5
083E:  CLRF   01
....................     wpug= 0b11111111;//Set pullups
083F:  MOVLW  FF
0840:  MOVWF  15
....................     
....................     lcd_init(); // Init LCD comm
0841:  BCF    0A.3
0842:  BCF    03.5
0843:  GOTO   0E0
0844:  BSF    0A.3
....................     
....................     lcd_gotoxy(1,1);
0845:  MOVLW  01
0846:  MOVWF  4A
0847:  MOVWF  4B
0848:  BCF    0A.3
0849:  CALL   11E
084A:  BSF    0A.3
....................     printf(lcd_putc,"Fridge Access");
084B:  MOVLW  19
084C:  BSF    03.6
084D:  MOVWF  0D
084E:  MOVLW  00
084F:  MOVWF  0F
0850:  BCF    0A.3
0851:  BCF    03.6
0852:  CALL   15C
0853:  BSF    0A.3
....................     lcd_gotoxy(1,2);
0854:  MOVLW  01
0855:  MOVWF  4A
0856:  MOVLW  02
0857:  MOVWF  4B
0858:  BCF    0A.3
0859:  CALL   11E
085A:  BSF    0A.3
....................     printf(lcd_putc,"Starting...");
085B:  MOVLW  20
085C:  BSF    03.6
085D:  MOVWF  0D
085E:  MOVLW  00
085F:  MOVWF  0F
0860:  BCF    0A.3
0861:  BCF    03.6
0862:  CALL   15C
0863:  BSF    0A.3
....................     delay_ms(2000);
0864:  MOVLW  08
0865:  MOVWF  3C
0866:  MOVLW  FA
0867:  MOVWF  4A
0868:  BCF    0A.3
0869:  CALL   079
086A:  BSF    0A.3
086B:  DECFSZ 3C,F
086C:  GOTO   066
....................     printf(lcd_putc, "\f");
086D:  MOVLW  0C
086E:  MOVWF  49
086F:  BCF    0A.3
0870:  CALL   130
0871:  BSF    0A.3
....................     printf(lcd_putc,"\f tecla No= %c",k);
0872:  MOVLW  26
0873:  BSF    03.6
0874:  MOVWF  0D
0875:  MOVLW  00
0876:  MOVWF  0F
0877:  BCF    03.0
0878:  MOVLW  0C
0879:  BCF    03.6
087A:  MOVWF  3C
087B:  BCF    0A.3
087C:  CALL   1B2
087D:  BSF    0A.3
087E:  MOVF   2A,W
087F:  MOVWF  49
0880:  BCF    0A.3
0881:  CALL   130
0882:  BSF    0A.3
....................     
....................     kbd_init(); //KBD init
0883:  BCF    0A.3
0884:  GOTO   209
0885:  BSF    0A.3
....................     
....................     port_b_pullups(true);
0886:  BSF    03.5
0887:  BCF    01.7
....................     
....................    
....................     
....................     while(true)
....................     {
....................         fridgeTemp=(float)read_adc()/2; //Set temp from read_adc()
0888:  BCF    03.5
0889:  BSF    1F.2
088A:  BTFSC  1F.2
088B:  GOTO   08A
088C:  MOVF   1E,W
088D:  MOVWF  79
088E:  BSF    03.5
088F:  MOVF   1E,W
0890:  MOVWF  78
0891:  MOVF   79,W
0892:  MOVWF  7A
0893:  MOVF   1E,W
0894:  BCF    03.5
0895:  MOVWF  3C
0896:  MOVF   79,W
0897:  MOVWF  3D
0898:  BCF    0A.3
0899:  GOTO   20C
089A:  BSF    0A.3
089B:  MOVF   7A,W
089C:  MOVWF  3F
089D:  MOVF   79,W
089E:  MOVWF  3E
089F:  MOVF   78,W
08A0:  MOVWF  3D
08A1:  MOVF   77,W
08A2:  MOVWF  3C
08A3:  MOVF   3F,W
08A4:  MOVWF  43
08A5:  MOVF   3E,W
08A6:  MOVWF  42
08A7:  MOVF   3D,W
08A8:  MOVWF  41
08A9:  MOVF   3C,W
08AA:  MOVWF  40
08AB:  CLRF   47
08AC:  CLRF   46
08AD:  CLRF   45
08AE:  MOVLW  80
08AF:  MOVWF  44
08B0:  BCF    0A.3
08B1:  GOTO   22B
08B2:  BSF    0A.3
08B3:  MOVF   7A,W
08B4:  MOVWF  29
08B5:  MOVF   79,W
08B6:  MOVWF  28
08B7:  MOVF   78,W
08B8:  MOVWF  27
08B9:  MOVF   77,W
08BA:  MOVWF  26
....................         
....................         lcd_gotoxy(1,1);
08BB:  MOVLW  01
08BC:  MOVWF  4A
08BD:  MOVWF  4B
08BE:  BCF    0A.3
08BF:  CALL   11E
08C0:  BSF    0A.3
....................         printf(lcd_putc,"TEMP: %f C ",fridgeTemp);
08C1:  MOVLW  2E
08C2:  BSF    03.6
08C3:  MOVWF  0D
08C4:  MOVLW  00
08C5:  MOVWF  0F
08C6:  BCF    03.0
08C7:  MOVLW  06
08C8:  BCF    03.6
08C9:  MOVWF  3C
08CA:  BCF    0A.3
08CB:  CALL   1B2
08CC:  BSF    0A.3
08CD:  MOVLW  89
08CE:  MOVWF  04
08CF:  MOVF   29,W
08D0:  MOVWF  3F
08D1:  MOVF   28,W
08D2:  MOVWF  3E
08D3:  MOVF   27,W
08D4:  MOVWF  3D
08D5:  MOVF   26,W
08D6:  MOVWF  3C
08D7:  MOVLW  02
08D8:  MOVWF  40
08D9:  BCF    0A.3
08DA:  GOTO   3DA
08DB:  BSF    0A.3
08DC:  MOVLW  20
08DD:  MOVWF  49
08DE:  BCF    0A.3
08DF:  CALL   130
08E0:  BSF    0A.3
08E1:  MOVLW  43
08E2:  MOVWF  49
08E3:  BCF    0A.3
08E4:  CALL   130
08E5:  BSF    0A.3
08E6:  MOVLW  20
08E7:  MOVWF  49
08E8:  BCF    0A.3
08E9:  CALL   130
08EA:  BSF    0A.3
....................         lcd_gotoxy(2,1);
08EB:  MOVLW  02
08EC:  MOVWF  4A
08ED:  MOVLW  01
08EE:  MOVWF  4B
08EF:  BCF    0A.3
08F0:  CALL   11E
08F1:  BSF    0A.3
....................         
....................         k=kbd_getc();//Get keypad action
08F2:  BCF    0A.3
08F3:  CALL   49F
08F4:  BSF    0A.3
08F5:  MOVF   78,W
08F6:  MOVWF  2A
....................         
....................         if(k!=0){
08F7:  MOVF   2A,F
08F8:  BTFSC  03.2
08F9:  GOTO   1E7
....................             lcd_gotoxy(1,1);
08FA:  MOVLW  01
08FB:  MOVWF  4A
08FC:  MOVWF  4B
08FD:  BCF    0A.3
08FE:  CALL   11E
08FF:  BSF    0A.3
....................             printf(lcd_putc,"\f Insert");
0900:  MOVLW  34
0901:  BSF    03.6
0902:  MOVWF  0D
0903:  MOVLW  00
0904:  MOVWF  0F
0905:  BCF    0A.3
0906:  BCF    03.6
0907:  CALL   15C
0908:  BSF    0A.3
....................             lcd_gotoxy(1,2);
0909:  MOVLW  01
090A:  MOVWF  4A
090B:  MOVLW  02
090C:  MOVWF  4B
090D:  BCF    0A.3
090E:  CALL   11E
090F:  BSF    0A.3
....................             printf(lcd_putc,"Password");
0910:  MOVLW  39
0911:  BSF    03.6
0912:  MOVWF  0D
0913:  MOVLW  00
0914:  MOVWF  0F
0915:  BCF    0A.3
0916:  BCF    03.6
0917:  CALL   15C
0918:  BSF    0A.3
....................             int counter=0;
0919:  CLRF   35
....................             delay_ms(3000);
091A:  MOVLW  0C
091B:  MOVWF  3C
091C:  MOVLW  FA
091D:  MOVWF  4A
091E:  BCF    0A.3
091F:  CALL   079
0920:  BSF    0A.3
0921:  DECFSZ 3C,F
0922:  GOTO   11C
....................             printf(lcd_putc,"\f");
0923:  MOVLW  0C
0924:  MOVWF  49
0925:  BCF    0A.3
0926:  CALL   130
0927:  BSF    0A.3
....................             
....................             while(true){
....................                 k=0;
0928:  CLRF   2A
....................                 k=kbd_getc();
0929:  BCF    0A.3
092A:  CALL   49F
092B:  BSF    0A.3
092C:  MOVF   78,W
092D:  MOVWF  2A
....................                 lcd_gotoxy(1,1);
092E:  MOVLW  01
092F:  MOVWF  4A
0930:  MOVWF  4B
0931:  BCF    0A.3
0932:  CALL   11E
0933:  BSF    0A.3
....................                 printf(lcd_putc,"Reading...");
0934:  MOVLW  3E
0935:  BSF    03.6
0936:  MOVWF  0D
0937:  MOVLW  00
0938:  MOVWF  0F
0939:  BCF    0A.3
093A:  BCF    03.6
093B:  CALL   15C
093C:  BSF    0A.3
....................                 if(k!=0 && counter!=6){ 
093D:  MOVF   2A,F
093E:  BTFSC  03.2
093F:  GOTO   1CF
0940:  MOVF   35,W
0941:  SUBLW  06
0942:  BTFSC  03.2
0943:  GOTO   1CF
....................                     if(k=='#'){
0944:  MOVF   2A,W
0945:  SUBLW  23
0946:  BTFSS  03.2
0947:  GOTO   1A8
....................                         //Password logic with string library
....................                         if(strcmp(password,"12345")==0){
0948:  MOVLW  31
0949:  MOVWF  36
094A:  MOVLW  32
094B:  MOVWF  37
094C:  MOVLW  33
094D:  MOVWF  38
094E:  MOVLW  34
094F:  MOVWF  39
0950:  MOVLW  35
0951:  MOVWF  3A
0952:  CLRF   3B
0953:  CLRF   3F
0954:  MOVLW  2B
0955:  MOVWF  3E
0956:  CLRF   41
0957:  MOVLW  36
0958:  MOVWF  40
0959:  BCF    0A.3
095A:  CALL   527
095B:  BSF    0A.3
095C:  MOVF   78,F
095D:  BTFSS  03.2
095E:  GOTO   163
....................                            doorFlag=1;
095F:  MOVLW  01
0960:  MOVWF  30
....................                            break;
0961:  GOTO   1E7
....................                         }
0962:  GOTO   1A7
....................                         else if(strcmp(password,"67890")==0){
0963:  MOVLW  36
0964:  MOVWF  36
0965:  MOVLW  37
0966:  MOVWF  37
0967:  MOVLW  38
0968:  MOVWF  38
0969:  MOVLW  39
096A:  MOVWF  39
096B:  MOVLW  30
096C:  MOVWF  3A
096D:  CLRF   3B
096E:  CLRF   3F
096F:  MOVLW  2B
0970:  MOVWF  3E
0971:  CLRF   41
0972:  MOVLW  36
0973:  MOVWF  40
0974:  BCF    0A.3
0975:  CALL   527
0976:  BSF    0A.3
0977:  MOVF   78,F
0978:  BTFSS  03.2
0979:  GOTO   17E
....................                            doorFlag=1;
097A:  MOVLW  01
097B:  MOVWF  30
....................                            break;
097C:  GOTO   1E7
....................                         }
097D:  GOTO   1A7
....................                         else{
....................                             lcd_gotoxy(1,1);
097E:  MOVLW  01
097F:  MOVWF  4A
0980:  MOVWF  4B
0981:  BCF    0A.3
0982:  CALL   11E
0983:  BSF    0A.3
....................                             printf(lcd_putc,"\f Invalid");
0984:  MOVLW  44
0985:  BSF    03.6
0986:  MOVWF  0D
0987:  MOVLW  00
0988:  MOVWF  0F
0989:  BCF    0A.3
098A:  BCF    03.6
098B:  CALL   15C
098C:  BSF    0A.3
....................                             lcd_gotoxy(1,2);
098D:  MOVLW  01
098E:  MOVWF  4A
098F:  MOVLW  02
0990:  MOVWF  4B
0991:  BCF    0A.3
0992:  CALL   11E
0993:  BSF    0A.3
....................                             printf(lcd_putc,"Password");
0994:  MOVLW  49
0995:  BSF    03.6
0996:  MOVWF  0D
0997:  MOVLW  00
0998:  MOVWF  0F
0999:  BCF    0A.3
099A:  BCF    03.6
099B:  CALL   15C
099C:  BSF    0A.3
....................                             delay_ms(2000);
099D:  MOVLW  08
099E:  MOVWF  3C
099F:  MOVLW  FA
09A0:  MOVWF  4A
09A1:  BCF    0A.3
09A2:  CALL   079
09A3:  BSF    0A.3
09A4:  DECFSZ 3C,F
09A5:  GOTO   19F
....................                             break;
09A6:  GOTO   1E7
....................                         }
....................                     }
09A7:  GOTO   1CE
....................                     else{
....................                         printf(lcd_putc,"\f Key: %c",k);
09A8:  MOVLW  4E
09A9:  BSF    03.6
09AA:  MOVWF  0D
09AB:  MOVLW  00
09AC:  MOVWF  0F
09AD:  BCF    03.0
09AE:  MOVLW  07
09AF:  BCF    03.6
09B0:  MOVWF  3C
09B1:  BCF    0A.3
09B2:  CALL   1B2
09B3:  BSF    0A.3
09B4:  MOVF   2A,W
09B5:  MOVWF  49
09B6:  BCF    0A.3
09B7:  CALL   130
09B8:  BSF    0A.3
....................                         delay_ms(1000);
09B9:  MOVLW  04
09BA:  MOVWF  3C
09BB:  MOVLW  FA
09BC:  MOVWF  4A
09BD:  BCF    0A.3
09BE:  CALL   079
09BF:  BSF    0A.3
09C0:  DECFSZ 3C,F
09C1:  GOTO   1BB
....................                         strncat(password, &k, 1);     
09C2:  CLRF   3D
09C3:  MOVLW  2B
09C4:  MOVWF  3C
09C5:  CLRF   3F
09C6:  MOVLW  2A
09C7:  MOVWF  3E
09C8:  MOVLW  01
09C9:  MOVWF  40
09CA:  BCF    0A.3
09CB:  GOTO   56B
09CC:  BSF    0A.3
....................                         counter++;
09CD:  INCF   35,F
....................                     }
....................                 }
09CE:  GOTO   1E6
....................                 else if(counter==6){
09CF:  MOVF   35,W
09D0:  SUBLW  06
09D1:  BTFSS  03.2
09D2:  GOTO   1E6
....................                     printf(lcd_putc,"\f Password Error");
09D3:  MOVLW  53
09D4:  BSF    03.6
09D5:  MOVWF  0D
09D6:  MOVLW  00
09D7:  MOVWF  0F
09D8:  BCF    0A.3
09D9:  BCF    03.6
09DA:  CALL   15C
09DB:  BSF    0A.3
....................                     delay_ms(1500);
09DC:  MOVLW  06
09DD:  MOVWF  3C
09DE:  MOVLW  FA
09DF:  MOVWF  4A
09E0:  BCF    0A.3
09E1:  CALL   079
09E2:  BSF    0A.3
09E3:  DECFSZ 3C,F
09E4:  GOTO   1DE
....................                     break;
09E5:  GOTO   1E7
....................                 }
09E6:  GOTO   128
....................             }
....................              
....................         }
....................         if (doorFlag == 1){
09E7:  DECFSZ 30,W
09E8:  GOTO   2F8
....................             putc(13);//First column                                  
09E9:  MOVLW  0D
09EA:  BTFSS  0C.4
09EB:  GOTO   1EA
09EC:  MOVWF  19
....................             printf("CODE %s TEMP: %f",password,fridgeTemp); //UART write                  
09ED:  MOVLW  5C
09EE:  BSF    03.6
09EF:  MOVWF  0D
09F0:  MOVLW  00
09F1:  MOVWF  0F
09F2:  BCF    03.0
09F3:  MOVLW  05
09F4:  BCF    03.6
09F5:  MOVWF  3C
09F6:  BCF    0A.3
09F7:  CALL   5AE
09F8:  BSF    0A.3
09F9:  MOVLW  2B
09FA:  MOVWF  04
09FB:  BCF    03.7
09FC:  BCF    0A.3
09FD:  GOTO   607
09FE:  BSF    0A.3
09FF:  MOVLW  5F
0A00:  BSF    03.6
0A01:  MOVWF  0D
0A02:  MOVLW  00
0A03:  MOVWF  0F
0A04:  BSF    03.0
0A05:  MOVLW  07
0A06:  BCF    03.6
0A07:  MOVWF  3C
0A08:  BCF    0A.3
0A09:  CALL   5AE
0A0A:  BSF    0A.3
0A0B:  MOVLW  89
0A0C:  MOVWF  04
0A0D:  MOVF   29,W
0A0E:  MOVWF  3F
0A0F:  MOVF   28,W
0A10:  MOVWF  3E
0A11:  MOVF   27,W
0A12:  MOVWF  3D
0A13:  MOVF   26,W
0A14:  MOVWF  3C
0A15:  MOVLW  02
0A16:  MOVWF  40
0A17:  BCF    0A.3
0A18:  GOTO   620
0A19:  BSF    0A.3
....................             putc(13);                                   
0A1A:  MOVLW  0D
0A1B:  BTFSS  0C.4
0A1C:  GOTO   21B
0A1D:  MOVWF  19
....................             putc(10);//New line
0A1E:  MOVLW  0A
0A1F:  BTFSS  0C.4
0A20:  GOTO   21F
0A21:  MOVWF  19
....................             password="";
0A22:  CLRF   3C
0A23:  CLRF   3D
0A24:  MOVLW  2B
0A25:  MOVWF  04
0A26:  BCF    03.7
0A27:  MOVF   3C,W
0A28:  ADDWF  04,F
0A29:  MOVF   3D,W
0A2A:  BCF    0A.3
0A2B:  CALL   014
0A2C:  BSF    0A.3
0A2D:  MOVWF  00
0A2E:  IORLW  00
0A2F:  BTFSC  03.2
0A30:  GOTO   234
0A31:  INCF   3D,F
0A32:  INCF   3C,F
0A33:  GOTO   224
....................             //Motor and sound logic with input/output 
....................             if (fridgeTemp > 35){
0A34:  CLRF   3F
0A35:  CLRF   3E
0A36:  MOVLW  0C
0A37:  MOVWF  3D
0A38:  MOVLW  84
0A39:  MOVWF  3C
0A3A:  MOVF   29,W
0A3B:  MOVWF  43
0A3C:  MOVF   28,W
0A3D:  MOVWF  42
0A3E:  MOVF   27,W
0A3F:  MOVWF  41
0A40:  MOVF   26,W
0A41:  MOVWF  40
0A42:  BCF    0A.3
0A43:  CALL   6E9
0A44:  BSF    0A.3
0A45:  BTFSS  03.0
0A46:  GOTO   26C
....................                 lcd_putc("\f");
0A47:  MOVLW  65
0A48:  BSF    03.6
0A49:  MOVWF  0D
0A4A:  MOVLW  00
0A4B:  MOVWF  0F
0A4C:  BCF    0A.3
0A4D:  BCF    03.6
0A4E:  CALL   15C
0A4F:  BSF    0A.3
....................                 printf(lcd_putc,"Wait, high temp");
0A50:  MOVLW  66
0A51:  BSF    03.6
0A52:  MOVWF  0D
0A53:  MOVLW  00
0A54:  MOVWF  0F
0A55:  BCF    0A.3
0A56:  BCF    03.6
0A57:  CALL   15C
0A58:  BSF    0A.3
....................                 delay_ms(5000);
0A59:  MOVLW  14
0A5A:  MOVWF  3C
0A5B:  MOVLW  FA
0A5C:  MOVWF  4A
0A5D:  BCF    0A.3
0A5E:  CALL   079
0A5F:  BSF    0A.3
0A60:  DECFSZ 3C,F
0A61:  GOTO   25B
....................                 lcd_putc("\f");
0A62:  MOVLW  6E
0A63:  BSF    03.6
0A64:  MOVWF  0D
0A65:  MOVLW  00
0A66:  MOVWF  0F
0A67:  BCF    0A.3
0A68:  BCF    03.6
0A69:  CALL   15C
0A6A:  BSF    0A.3
....................             }
0A6B:  GOTO   2F8
....................             else if (35>fridgeTemp>20){ 
0A6C:  MOVF   29,W
0A6D:  MOVWF  3F
0A6E:  MOVF   28,W
0A6F:  MOVWF  3E
0A70:  MOVF   27,W
0A71:  MOVWF  3D
0A72:  MOVF   26,W
0A73:  MOVWF  3C
0A74:  CLRF   43
0A75:  CLRF   42
0A76:  MOVLW  0C
0A77:  MOVWF  41
0A78:  MOVLW  84
0A79:  MOVWF  40
0A7A:  BCF    0A.3
0A7B:  CALL   6E9
0A7C:  BSF    0A.3
0A7D:  MOVLW  00
0A7E:  BTFSC  03.0
0A7F:  MOVLW  01
0A80:  SUBLW  14
0A81:  BTFSC  03.0
0A82:  GOTO   2C1
....................                 output_high(PIN_C2);
0A83:  BCF    32.2
0A84:  MOVF   32,W
0A85:  BSF    03.5
0A86:  MOVWF  07
0A87:  BCF    03.5
0A88:  BSF    07.2
....................                 output_low(PIN_C1);
0A89:  BCF    32.1
0A8A:  MOVF   32,W
0A8B:  BSF    03.5
0A8C:  MOVWF  07
0A8D:  BCF    03.5
0A8E:  BCF    07.1
....................                 output_high(PIN_C0);
0A8F:  BCF    32.0
0A90:  MOVF   32,W
0A91:  BSF    03.5
0A92:  MOVWF  07
0A93:  BCF    03.5
0A94:  BSF    07.0
....................                 delay_ms(5000);
0A95:  MOVLW  14
0A96:  MOVWF  3C
0A97:  MOVLW  FA
0A98:  MOVWF  4A
0A99:  BCF    0A.3
0A9A:  CALL   079
0A9B:  BSF    0A.3
0A9C:  DECFSZ 3C,F
0A9D:  GOTO   297
....................                 output_low(PIN_C0);
0A9E:  BCF    32.0
0A9F:  MOVF   32,W
0AA0:  BSF    03.5
0AA1:  MOVWF  07
0AA2:  BCF    03.5
0AA3:  BCF    07.0
....................                 output_high(PIN_C1);
0AA4:  BCF    32.1
0AA5:  MOVF   32,W
0AA6:  BSF    03.5
0AA7:  MOVWF  07
0AA8:  BCF    03.5
0AA9:  BSF    07.1
....................                 delay_ms(5000);
0AAA:  MOVLW  14
0AAB:  MOVWF  3C
0AAC:  MOVLW  FA
0AAD:  MOVWF  4A
0AAE:  BCF    0A.3
0AAF:  CALL   079
0AB0:  BSF    0A.3
0AB1:  DECFSZ 3C,F
0AB2:  GOTO   2AC
....................                 output_low(PIN_C1);
0AB3:  BCF    32.1
0AB4:  MOVF   32,W
0AB5:  BSF    03.5
0AB6:  MOVWF  07
0AB7:  BCF    03.5
0AB8:  BCF    07.1
....................                 output_low(PIN_C2);
0AB9:  BCF    32.2
0ABA:  MOVF   32,W
0ABB:  BSF    03.5
0ABC:  MOVWF  07
0ABD:  BCF    03.5
0ABE:  BCF    07.2
....................                 doorFlag=0;
0ABF:  CLRF   30
....................             }
0AC0:  GOTO   2F8
....................             else {
....................                 output_high(PIN_C2);
0AC1:  BCF    32.2
0AC2:  MOVF   32,W
0AC3:  BSF    03.5
0AC4:  MOVWF  07
0AC5:  BCF    03.5
0AC6:  BSF    07.2
....................                 output_high(PIN_C0);
0AC7:  BCF    32.0
0AC8:  MOVF   32,W
0AC9:  BSF    03.5
0ACA:  MOVWF  07
0ACB:  BCF    03.5
0ACC:  BSF    07.0
....................                 delay_ms(10000);
0ACD:  MOVLW  28
0ACE:  MOVWF  3C
0ACF:  MOVLW  FA
0AD0:  MOVWF  4A
0AD1:  BCF    0A.3
0AD2:  CALL   079
0AD3:  BSF    0A.3
0AD4:  DECFSZ 3C,F
0AD5:  GOTO   2CF
....................                 output_low(PIN_C0);
0AD6:  BCF    32.0
0AD7:  MOVF   32,W
0AD8:  BSF    03.5
0AD9:  MOVWF  07
0ADA:  BCF    03.5
0ADB:  BCF    07.0
....................                 output_high(PIN_C1);
0ADC:  BCF    32.1
0ADD:  MOVF   32,W
0ADE:  BSF    03.5
0ADF:  MOVWF  07
0AE0:  BCF    03.5
0AE1:  BSF    07.1
....................                 delay_ms(10000);
0AE2:  MOVLW  28
0AE3:  MOVWF  3C
0AE4:  MOVLW  FA
0AE5:  MOVWF  4A
0AE6:  BCF    0A.3
0AE7:  CALL   079
0AE8:  BSF    0A.3
0AE9:  DECFSZ 3C,F
0AEA:  GOTO   2E4
....................                 output_low(PIN_C1);
0AEB:  BCF    32.1
0AEC:  MOVF   32,W
0AED:  BSF    03.5
0AEE:  MOVWF  07
0AEF:  BCF    03.5
0AF0:  BCF    07.1
....................                 output_low(PIN_C2);
0AF1:  BCF    32.2
0AF2:  MOVF   32,W
0AF3:  BSF    03.5
0AF4:  MOVWF  07
0AF5:  BCF    03.5
0AF6:  BCF    07.2
....................                 doorFlag=0;
0AF7:  CLRF   30
....................             }
....................         } 
....................         //Managment logic   
....................         if(~input(PIN_B0)){
0AF8:  BSF    03.5
0AF9:  BSF    06.0
0AFA:  BCF    03.5
0AFB:  BTFSC  06.0
0AFC:  GOTO   32B
....................             printf(lcd_putc,"\f Superuser Mode");
0AFD:  MOVLW  6F
0AFE:  BSF    03.6
0AFF:  MOVWF  0D
0B00:  MOVLW  00
0B01:  MOVWF  0F
0B02:  BCF    0A.3
0B03:  BCF    03.6
0B04:  CALL   15C
0B05:  BSF    0A.3
....................             delay_ms(3000);
0B06:  MOVLW  0C
0B07:  MOVWF  3C
0B08:  MOVLW  FA
0B09:  MOVWF  4A
0B0A:  BCF    0A.3
0B0B:  CALL   079
0B0C:  BSF    0A.3
0B0D:  DECFSZ 3C,F
0B0E:  GOTO   308
....................             lcd_putc("\f");
0B0F:  MOVLW  78
0B10:  BSF    03.6
0B11:  MOVWF  0D
0B12:  MOVLW  00
0B13:  MOVWF  0F
0B14:  BCF    0A.3
0B15:  BCF    03.6
0B16:  CALL   15C
0B17:  BSF    0A.3
....................             if(userFlag == 0){
0B18:  MOVF   31,F
0B19:  BTFSS  03.2
0B1A:  GOTO   324
....................                 output_high(PIN_C2);
0B1B:  BCF    32.2
0B1C:  MOVF   32,W
0B1D:  BSF    03.5
0B1E:  MOVWF  07
0B1F:  BCF    03.5
0B20:  BSF    07.2
....................                 userFlag = 1;
0B21:  MOVLW  01
0B22:  MOVWF  31
....................             }
0B23:  GOTO   32B
....................             else{
....................                 userFlag = 0;
0B24:  CLRF   31
....................                 output_low(PIN_C2);
0B25:  BCF    32.2
0B26:  MOVF   32,W
0B27:  BSF    03.5
0B28:  MOVWF  07
0B29:  BCF    03.5
0B2A:  BCF    07.2
....................             }
....................             
....................         }
0B2B:  GOTO   089
....................       
....................     }
....................     
....................     
....................     
.................... }
.................... 
0B2C:  SLEEP
.................... 

Configuration Fuses:
   Word  1: 3F71   XT NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
