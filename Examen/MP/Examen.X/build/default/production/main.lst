CCS PCM C Compiler, Version 5.088d, 1               11-Nov-19 13:29
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\pablo\Documents\1-TEC\Arqui1\Examen\MP\Examen.X\build\default\production\main.lst

               ROM used:   1413 words (17%)
                           Largest free fragment is 2048
               RAM used:   41 (11%) at main() level
                           55 (15%) worst case
               Stack used: 6 locations
               Stack size: 8

*
0000:  MOVLW  04
0001:  MOVWF  0A
0002:  GOTO   473
0003:  NOP
.................... #include <16f877.h>
.................... //////////// Standard Header file for the PIC16F877 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  34
000C:  RETLW  35
000D:  RETLW  36
000E:  RETLW  37
000F:  RETLW  38
0010:  RETLW  39
0011:  RETLW  2A
0012:  RETLW  30
0013:  RETLW  23
0014:  DATA 0C,38
0015:  DATA F5,32
0016:  DATA 72,3A
0017:  DATA 61,10
0018:  DATA 61,31
0019:  DATA E9,32
001A:  DATA 72,3A
001B:  DATA 61,00
001C:  DATA 0C,38
001D:  DATA F5,32
001E:  DATA 72,3A
001F:  DATA 61,10
0020:  DATA E3,32
0021:  DATA 72,39
0022:  DATA 61,32
0023:  DATA 61,00
0024:  DATA 0C,38
0025:  DATA F5,32
0026:  DATA 72,3A
0027:  DATA 61,10
0028:  DATA 61,31
0029:  DATA E9,32
002A:  DATA 72,3A
002B:  DATA 61,00
002C:  DATA 0C,38
002D:  DATA F5,32
002E:  DATA 72,3A
002F:  DATA 61,10
0030:  DATA E3,32
0031:  DATA 72,39
0032:  DATA 61,32
0033:  DATA 61,00
0034:  DATA 0C,38
0035:  DATA F5,32
0036:  DATA 72,3A
0037:  DATA 61,10
0038:  DATA E3,32
0039:  DATA 72,39
003A:  DATA 61,32
003B:  DATA 61,00
003C:  DATA 0C,10
003D:  DATA F4,32
003E:  DATA 63,36
003F:  DATA 61,10
0040:  DATA CE,37
0041:  DATA 3D,10
0042:  DATA A5,31
0043:  DATA 00,00
0044:  DATA 0C,28
0045:  DATA 49,27
0046:  DATA A0,21
0047:  DATA 6F,39
0048:  DATA F2,32
0049:  DATA 63,3A
004A:  DATA 6F,00
004B:  DATA 0C,28
004C:  DATA 49,27
004D:  DATA A0,21
004E:  DATA 6F,39
004F:  DATA F2,32
0050:  DATA 63,3A
0051:  DATA 6F,00
0052:  DATA 0C,28
0053:  DATA 49,27
0054:  DATA A0,24
0055:  DATA EE,31
0056:  DATA 6F,39
0057:  DATA F2,32
0058:  DATA 63,3A
0059:  DATA 6F,00
*
0102:  MOVLW  8E
0103:  MOVWF  77
0104:  MOVF   41,W
0105:  MOVWF  78
0106:  MOVF   40,W
0107:  MOVWF  79
0108:  CLRF   7A
0109:  MOVF   78,F
010A:  BTFSS  03.2
010B:  GOTO   116
010C:  MOVF   79,W
010D:  MOVWF  78
010E:  CLRF   79
010F:  MOVLW  08
0110:  SUBWF  77,F
0111:  MOVF   78,F
0112:  BTFSS  03.2
0113:  GOTO   116
0114:  CLRF   77
0115:  GOTO   11E
0116:  BCF    03.0
0117:  BTFSC  78.7
0118:  GOTO   11D
0119:  RLF    79,F
011A:  RLF    78,F
011B:  DECF   77,F
011C:  GOTO   116
011D:  BCF    78.7
011E:  BCF    0A.3
011F:  BCF    0A.4
0120:  GOTO   4D9 (RETURN)
0121:  MOVF   44,W
0122:  BTFSC  03.2
0123:  GOTO   1E6
0124:  MOVWF  50
0125:  MOVF   48,W
0126:  BTFSC  03.2
0127:  GOTO   1E6
0128:  SUBWF  50,F
0129:  BTFSS  03.0
012A:  GOTO   130
012B:  MOVLW  7F
012C:  ADDWF  50,F
012D:  BTFSC  03.0
012E:  GOTO   1E6
012F:  GOTO   136
0130:  MOVLW  81
0131:  SUBWF  50,F
0132:  BTFSS  03.0
0133:  GOTO   1E6
0134:  BTFSC  03.2
0135:  GOTO   1E6
0136:  MOVF   50,W
0137:  MOVWF  77
0138:  CLRF   78
0139:  CLRF   79
013A:  CLRF   7A
013B:  CLRF   4F
013C:  MOVF   45,W
013D:  MOVWF  4E
013E:  BSF    4E.7
013F:  MOVF   46,W
0140:  MOVWF  4D
0141:  MOVF   47,W
0142:  MOVWF  4C
0143:  MOVLW  19
0144:  MOVWF  50
0145:  MOVF   4B,W
0146:  SUBWF  4C,F
0147:  BTFSC  03.0
0148:  GOTO   159
0149:  MOVLW  01
014A:  SUBWF  4D,F
014B:  BTFSC  03.0
014C:  GOTO   159
014D:  SUBWF  4E,F
014E:  BTFSC  03.0
014F:  GOTO   159
0150:  SUBWF  4F,F
0151:  BTFSC  03.0
0152:  GOTO   159
0153:  INCF   4F,F
0154:  INCF   4E,F
0155:  INCF   4D,F
0156:  MOVF   4B,W
0157:  ADDWF  4C,F
0158:  GOTO   18B
0159:  MOVF   4A,W
015A:  SUBWF  4D,F
015B:  BTFSC  03.0
015C:  GOTO   174
015D:  MOVLW  01
015E:  SUBWF  4E,F
015F:  BTFSC  03.0
0160:  GOTO   174
0161:  SUBWF  4F,F
0162:  BTFSC  03.0
0163:  GOTO   174
0164:  INCF   4F,F
0165:  INCF   4E,F
0166:  MOVF   4A,W
0167:  ADDWF  4D,F
0168:  MOVF   4B,W
0169:  ADDWF  4C,F
016A:  BTFSS  03.0
016B:  GOTO   18B
016C:  INCF   4D,F
016D:  BTFSS  03.2
016E:  GOTO   18B
016F:  INCF   4E,F
0170:  BTFSS  03.2
0171:  GOTO   18B
0172:  INCF   4F,F
0173:  GOTO   18B
0174:  MOVF   49,W
0175:  IORLW  80
0176:  SUBWF  4E,F
0177:  BTFSC  03.0
0178:  GOTO   18A
0179:  MOVLW  01
017A:  SUBWF  4F,F
017B:  BTFSC  03.0
017C:  GOTO   18A
017D:  INCF   4F,F
017E:  MOVF   49,W
017F:  IORLW  80
0180:  ADDWF  4E,F
0181:  MOVF   4A,W
0182:  ADDWF  4D,F
0183:  BTFSS  03.0
0184:  GOTO   168
0185:  INCF   4E,F
0186:  BTFSS  03.2
0187:  GOTO   168
0188:  INCF   4F,F
0189:  GOTO   168
018A:  BSF    7A.0
018B:  DECFSZ 50,F
018C:  GOTO   18E
018D:  GOTO   199
018E:  BCF    03.0
018F:  RLF    4C,F
0190:  RLF    4D,F
0191:  RLF    4E,F
0192:  RLF    4F,F
0193:  BCF    03.0
0194:  RLF    7A,F
0195:  RLF    79,F
0196:  RLF    78,F
0197:  RLF    51,F
0198:  GOTO   145
0199:  BTFSS  51.0
019A:  GOTO   1A1
019B:  BCF    03.0
019C:  RRF    78,F
019D:  RRF    79,F
019E:  RRF    7A,F
019F:  RRF    51,F
01A0:  GOTO   1A4
01A1:  DECF   77,F
01A2:  BTFSC  03.2
01A3:  GOTO   1E6
01A4:  BTFSC  51.7
01A5:  GOTO   1CD
01A6:  BCF    03.0
01A7:  RLF    4C,F
01A8:  RLF    4D,F
01A9:  RLF    4E,F
01AA:  RLF    4F,F
01AB:  MOVF   4B,W
01AC:  SUBWF  4C,F
01AD:  BTFSC  03.0
01AE:  GOTO   1B9
01AF:  MOVLW  01
01B0:  SUBWF  4D,F
01B1:  BTFSC  03.0
01B2:  GOTO   1B9
01B3:  SUBWF  4E,F
01B4:  BTFSC  03.0
01B5:  GOTO   1B9
01B6:  SUBWF  4F,F
01B7:  BTFSS  03.0
01B8:  GOTO   1DC
01B9:  MOVF   4A,W
01BA:  SUBWF  4D,F
01BB:  BTFSC  03.0
01BC:  GOTO   1C4
01BD:  MOVLW  01
01BE:  SUBWF  4E,F
01BF:  BTFSC  03.0
01C0:  GOTO   1C4
01C1:  SUBWF  4F,F
01C2:  BTFSS  03.0
01C3:  GOTO   1DC
01C4:  MOVF   49,W
01C5:  IORLW  80
01C6:  SUBWF  4E,F
01C7:  BTFSC  03.0
01C8:  GOTO   1CD
01C9:  MOVLW  01
01CA:  SUBWF  4F,F
01CB:  BTFSS  03.0
01CC:  GOTO   1DC
01CD:  INCF   7A,F
01CE:  BTFSS  03.2
01CF:  GOTO   1DC
01D0:  INCF   79,F
01D1:  BTFSS  03.2
01D2:  GOTO   1DC
01D3:  INCF   78,F
01D4:  BTFSS  03.2
01D5:  GOTO   1DC
01D6:  INCF   77,F
01D7:  BTFSC  03.2
01D8:  GOTO   1E6
01D9:  RRF    78,F
01DA:  RRF    79,F
01DB:  RRF    7A,F
01DC:  MOVF   45,W
01DD:  MOVWF  50
01DE:  MOVF   49,W
01DF:  XORWF  50,F
01E0:  BTFSS  50.7
01E1:  GOTO   1E4
01E2:  BSF    78.7
01E3:  GOTO   1EA
01E4:  BCF    78.7
01E5:  GOTO   1EA
01E6:  CLRF   77
01E7:  CLRF   78
01E8:  CLRF   79
01E9:  CLRF   7A
01EA:  BCF    0A.3
01EB:  BCF    0A.4
01EC:  GOTO   4EF (RETURN)
*
023D:  CLRF   77
023E:  CLRF   78
023F:  MOVF   42,W
0240:  BCF    03.0
0241:  BTFSC  43.0
0242:  ADDWF  77,F
0243:  RRF    77,F
0244:  RRF    78,F
0245:  BTFSC  43.1
0246:  ADDWF  77,F
0247:  RRF    77,F
0248:  RRF    78,F
0249:  BTFSC  43.2
024A:  ADDWF  77,F
024B:  RRF    77,F
024C:  RRF    78,F
024D:  BTFSC  43.3
024E:  ADDWF  77,F
024F:  RRF    77,F
0250:  RRF    78,F
0251:  BTFSC  43.4
0252:  ADDWF  77,F
0253:  RRF    77,F
0254:  RRF    78,F
0255:  BTFSC  43.5
0256:  ADDWF  77,F
0257:  RRF    77,F
0258:  RRF    78,F
0259:  BTFSC  43.6
025A:  ADDWF  77,F
025B:  RRF    77,F
025C:  RRF    78,F
025D:  BTFSC  43.7
025E:  ADDWF  77,F
025F:  RRF    77,F
0260:  RRF    78,F
*
02B5:  MOVF   0B,W
02B6:  MOVWF  41
02B7:  BCF    0B.7
02B8:  BSF    03.5
02B9:  BSF    03.6
02BA:  BSF    0C.7
02BB:  BSF    0C.0
02BC:  NOP
02BD:  NOP
02BE:  BCF    03.5
02BF:  BCF    03.6
02C0:  BTFSC  41.7
02C1:  BSF    0B.7
02C2:  BTFSC  03.0
02C3:  GOTO   2EC
02C4:  BSF    03.6
02C5:  MOVF   0C,W
02C6:  ANDLW  7F
02C7:  BCF    03.6
02C8:  MOVWF  41
02C9:  BSF    03.6
02CA:  MOVF   0D,W
02CB:  BCF    03.6
02CC:  MOVWF  42
02CD:  BSF    03.6
02CE:  MOVF   0F,W
02CF:  BCF    03.6
02D0:  MOVWF  43
02D1:  MOVF   41,W
02D2:  MOVWF  44
02D3:  CALL   289
02D4:  MOVF   42,W
02D5:  BSF    03.6
02D6:  MOVWF  0D
02D7:  BCF    03.6
02D8:  MOVF   43,W
02D9:  BSF    03.6
02DA:  MOVWF  0F
02DB:  BCF    03.6
02DC:  MOVF   0B,W
02DD:  MOVWF  44
02DE:  BCF    0B.7
02DF:  BSF    03.5
02E0:  BSF    03.6
02E1:  BSF    0C.7
02E2:  BSF    0C.0
02E3:  NOP
02E4:  NOP
02E5:  BCF    03.5
02E6:  BCF    03.6
02E7:  BTFSC  44.7
02E8:  BSF    0B.7
02E9:  DECFSZ 40,F
02EA:  GOTO   2EC
02EB:  GOTO   30B
02EC:  BSF    03.6
02ED:  RLF    0C,W
02EE:  RLF    0E,W
02EF:  ANDLW  7F
02F0:  BCF    03.6
02F1:  MOVWF  41
02F2:  BSF    03.6
02F3:  MOVF   0D,W
02F4:  BCF    03.6
02F5:  MOVWF  42
02F6:  BSF    03.6
02F7:  MOVF   0F,W
02F8:  BCF    03.6
02F9:  MOVWF  43
02FA:  MOVF   41,W
02FB:  MOVWF  44
02FC:  CALL   289
02FD:  MOVF   42,W
02FE:  BSF    03.6
02FF:  MOVWF  0D
0300:  BCF    03.6
0301:  MOVF   43,W
0302:  BSF    03.6
0303:  MOVWF  0F
0304:  INCF   0D,F
0305:  BTFSC  03.2
0306:  INCF   0F,F
0307:  BCF    03.0
0308:  BCF    03.6
0309:  DECFSZ 40,F
030A:  GOTO   2B5
030B:  BCF    0A.3
030C:  BCF    0A.4
030D:  GOTO   507 (RETURN)
030E:  MOVF   0B,W
030F:  MOVWF  40
0310:  BCF    0B.7
0311:  BSF    03.5
0312:  BSF    03.6
0313:  BSF    0C.7
0314:  BSF    0C.0
0315:  NOP
0316:  NOP
0317:  BCF    03.5
0318:  BCF    03.6
0319:  BTFSC  40.7
031A:  BSF    0B.7
031B:  BSF    03.6
031C:  MOVF   0C,W
031D:  ANDLW  7F
031E:  BTFSC  03.2
031F:  GOTO   362
0320:  BCF    03.6
0321:  MOVWF  40
0322:  BSF    03.6
0323:  MOVF   0D,W
0324:  BCF    03.6
0325:  MOVWF  41
0326:  BSF    03.6
0327:  MOVF   0F,W
0328:  BCF    03.6
0329:  MOVWF  42
032A:  MOVF   40,W
032B:  MOVWF  44
032C:  CALL   289
032D:  MOVF   41,W
032E:  BSF    03.6
032F:  MOVWF  0D
0330:  BCF    03.6
0331:  MOVF   42,W
0332:  BSF    03.6
0333:  MOVWF  0F
0334:  BCF    03.6
0335:  MOVF   0B,W
0336:  MOVWF  43
0337:  BCF    0B.7
0338:  BSF    03.5
0339:  BSF    03.6
033A:  BSF    0C.7
033B:  BSF    0C.0
033C:  NOP
033D:  NOP
033E:  BCF    03.5
033F:  BCF    03.6
0340:  BTFSC  43.7
0341:  BSF    0B.7
0342:  BSF    03.6
0343:  RLF    0C,W
0344:  RLF    0E,W
0345:  ANDLW  7F
0346:  BTFSC  03.2
0347:  GOTO   362
0348:  BCF    03.6
0349:  MOVWF  40
034A:  BSF    03.6
034B:  MOVF   0D,W
034C:  BCF    03.6
034D:  MOVWF  41
034E:  BSF    03.6
034F:  MOVF   0F,W
0350:  BCF    03.6
0351:  MOVWF  42
0352:  MOVF   40,W
0353:  MOVWF  44
0354:  CALL   289
0355:  MOVF   41,W
0356:  BSF    03.6
0357:  MOVWF  0D
0358:  BCF    03.6
0359:  MOVF   42,W
035A:  BSF    03.6
035B:  MOVWF  0F
035C:  INCF   0D,F
035D:  BTFSC  03.2
035E:  INCF   0F,F
035F:  BCF    03.6
0360:  GOTO   30E
0361:  BSF    03.6
0362:  BCF    03.6
0363:  RETURN
0364:  MOVF   41,W
0365:  MOVWF  48
0366:  MOVF   45,W
0367:  XORWF  48,F
0368:  BTFSS  48.7
0369:  GOTO   36F
036A:  BCF    03.2
036B:  BCF    03.0
036C:  BTFSC  41.7
036D:  BSF    03.0
036E:  GOTO   3A2
036F:  MOVF   41,W
0370:  MOVWF  48
0371:  MOVF   44,W
0372:  MOVWF  49
0373:  MOVF   40,W
0374:  SUBWF  49,F
0375:  BTFSC  03.2
0376:  GOTO   37D
0377:  BTFSS  48.7
0378:  GOTO   3A2
0379:  MOVF   03,W
037A:  XORLW  01
037B:  MOVWF  03
037C:  GOTO   3A2
037D:  MOVF   45,W
037E:  MOVWF  49
037F:  MOVF   41,W
0380:  SUBWF  49,F
0381:  BTFSC  03.2
0382:  GOTO   389
0383:  BTFSS  48.7
0384:  GOTO   3A2
0385:  MOVF   03,W
0386:  XORLW  01
0387:  MOVWF  03
0388:  GOTO   3A2
0389:  MOVF   46,W
038A:  MOVWF  49
038B:  MOVF   42,W
038C:  SUBWF  49,F
038D:  BTFSC  03.2
038E:  GOTO   395
038F:  BTFSS  48.7
0390:  GOTO   3A2
0391:  MOVF   03,W
0392:  XORLW  01
0393:  MOVWF  03
0394:  GOTO   3A2
0395:  MOVF   47,W
0396:  MOVWF  49
0397:  MOVF   43,W
0398:  SUBWF  49,F
0399:  BTFSC  03.2
039A:  GOTO   3A1
039B:  BTFSS  48.7
039C:  GOTO   3A2
039D:  MOVF   03,W
039E:  XORLW  01
039F:  MOVWF  03
03A0:  GOTO   3A2
03A1:  BCF    03.0
03A2:  RETURN
.................... 
.................... #list
.................... 
.................... #fuses xt,nowdt,HS,NOWDT,NOPROTECT,NOLVP,BROWNOUT
.................... #device *=16
.................... #device adc=10
.................... #use delay(clock = 4M)
*
005D:  MOVLW  45
005E:  MOVWF  04
005F:  BCF    03.7
0060:  MOVF   00,W
0061:  BTFSC  03.2
0062:  GOTO   071
0063:  MOVLW  01
0064:  MOVWF  78
0065:  CLRF   77
0066:  DECFSZ 77,F
0067:  GOTO   066
0068:  DECFSZ 78,F
0069:  GOTO   065
006A:  MOVLW  4A
006B:  MOVWF  77
006C:  DECFSZ 77,F
006D:  GOTO   06C
006E:  GOTO   06F
006F:  DECFSZ 00,F
0070:  GOTO   063
0071:  RETURN
.................... #define use_portb_kbd TRUE
.................... #define use_portd_lcd TRUE
.................... //#use standard_io(a)           //gestion de puertos
.................... #include <lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
....................    output_float(LCD_DATA5);
....................    output_float(LCD_DATA6);
....................    output_float(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0xF;
*
008A:  MOVLW  0F
008B:  BSF    03.5
008C:  ANDWF  08,W
008D:  IORLW  F0
008E:  MOVWF  08
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
008F:  BCF    03.5
0090:  BSF    08.2
....................    delay_cycles(1);
0091:  NOP
....................    lcd_output_enable(1);
0092:  BSF    08.0
....................    delay_cycles(1);
0093:  NOP
....................    high = lcd_read_nibble();
0094:  CALL   07E
0095:  MOVF   78,W
0096:  MOVWF  4C
....................       
....................    lcd_output_enable(0);
0097:  BCF    08.0
....................    delay_cycles(1);
0098:  NOP
....................    lcd_output_enable(1);
0099:  BSF    08.0
....................    delay_us(1);
009A:  NOP
....................    low = lcd_read_nibble();
009B:  CALL   07E
009C:  MOVF   78,W
009D:  MOVWF  4B
....................       
....................    lcd_output_enable(0);
009E:  BCF    08.0
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
009F:  MOVLW  0F
00A0:  BSF    03.5
00A1:  ANDWF  08,W
00A2:  MOVWF  08
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
00A3:  BCF    03.5
00A4:  SWAPF  4C,W
00A5:  MOVWF  77
00A6:  MOVLW  F0
00A7:  ANDWF  77,F
00A8:  MOVF   77,W
00A9:  IORWF  4B,W
00AA:  MOVWF  78
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
....................    n |= input(LCD_DATA5) << 1;
....................    n |= input(LCD_DATA6) << 2;
....................    n |= input(LCD_DATA7) << 3;
....................    
....................    return(n);
....................   #else
....................    return(lcd.data);
*
007E:  MOVF   08,W
007F:  MOVWF  77
0080:  SWAPF  08,W
0081:  ANDLW  0F
0082:  MOVWF  78
....................   #endif
0083:  RETURN
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
....................    output_bit(LCD_DATA5, bit_test(n, 1));
....................    output_bit(LCD_DATA6, bit_test(n, 2));
....................    output_bit(LCD_DATA7, bit_test(n, 3));
....................   #else      
....................    lcdlat.data = n;
*
0072:  SWAPF  4C,W
0073:  ANDLW  F0
0074:  MOVWF  77
0075:  MOVLW  0F
0076:  ANDWF  08,W
0077:  IORWF  77,W
0078:  MOVWF  08
....................   #endif
....................       
....................    delay_cycles(1);
0079:  NOP
....................    lcd_output_enable(1);
007A:  BSF    08.0
....................    delay_us(2);
007B:  GOTO   07C
....................    lcd_output_enable(0);
007C:  BCF    08.0
007D:  RETURN
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
0084:  BSF    03.5
0085:  BCF    08.0
....................    lcd_rs_tris();
0086:  BCF    08.1
....................    lcd_rw_tris();
0087:  BCF    08.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
0088:  BCF    03.5
0089:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ;
*
00AB:  MOVF   78,W
00AC:  MOVWF  4B
00AD:  BTFSC  4B.7
00AE:  GOTO   08A
....................    lcd_output_rs(address);
00AF:  BTFSS  49.0
00B0:  BCF    08.1
00B1:  BTFSC  49.0
00B2:  BSF    08.1
....................    delay_cycles(1);
00B3:  NOP
....................    lcd_output_rw(0);
00B4:  BCF    08.2
....................    delay_cycles(1);
00B5:  NOP
....................    lcd_output_enable(0);
00B6:  BCF    08.0
....................    lcd_send_nibble(n >> 4);
00B7:  SWAPF  4A,W
00B8:  MOVWF  4B
00B9:  MOVLW  0F
00BA:  ANDWF  4B,F
00BB:  MOVF   4B,W
00BC:  MOVWF  4C
00BD:  CALL   072
....................    lcd_send_nibble(n & 0xf);
00BE:  MOVF   4A,W
00BF:  ANDLW  0F
00C0:  MOVWF  4B
00C1:  MOVWF  4C
00C2:  CALL   072
00C3:  RETURN
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
00C4:  MOVLW  28
00C5:  MOVWF  41
00C6:  MOVLW  0C
00C7:  MOVWF  42
00C8:  MOVLW  01
00C9:  MOVWF  43
00CA:  MOVLW  06
00CB:  MOVWF  44
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
00CC:  BCF    08.0
....................    lcd_output_rs(0);
00CD:  BCF    08.1
....................    lcd_output_rw(0);
00CE:  BCF    08.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
00CF:  MOVLW  0F
00D0:  BSF    03.5
00D1:  ANDWF  08,W
00D2:  MOVWF  08
....................   #endif
....................    lcd_enable_tris();
00D3:  BCF    08.0
....................    lcd_rs_tris();
00D4:  BCF    08.1
....................    lcd_rw_tris();
00D5:  BCF    08.2
....................  #endif
....................     
....................    delay_ms(15);
00D6:  MOVLW  0F
00D7:  BCF    03.5
00D8:  MOVWF  45
00D9:  CALL   05D
....................    for(i=1;i<=3;++i)
00DA:  MOVLW  01
00DB:  MOVWF  40
00DC:  MOVF   40,W
00DD:  SUBLW  03
00DE:  BTFSS  03.0
00DF:  GOTO   0E8
....................    {
....................        lcd_send_nibble(3);
00E0:  MOVLW  03
00E1:  MOVWF  4C
00E2:  CALL   072
....................        delay_ms(5);
00E3:  MOVLW  05
00E4:  MOVWF  45
00E5:  CALL   05D
00E6:  INCF   40,F
00E7:  GOTO   0DC
....................    }
....................    
....................    lcd_send_nibble(2);
00E8:  MOVLW  02
00E9:  MOVWF  4C
00EA:  CALL   072
....................    delay_ms(5);
00EB:  MOVLW  05
00EC:  MOVWF  45
00ED:  CALL   05D
....................    for(i=0;i<=3;++i)
00EE:  CLRF   40
00EF:  MOVF   40,W
00F0:  SUBLW  03
00F1:  BTFSS  03.0
00F2:  GOTO   0FF
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
00F3:  MOVLW  41
00F4:  ADDWF  40,W
00F5:  MOVWF  04
00F6:  BCF    03.7
00F7:  MOVF   00,W
00F8:  MOVWF  45
00F9:  CLRF   49
00FA:  MOVF   45,W
00FB:  MOVWF  4A
00FC:  CALL   084
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
00FD:  INCF   40,F
00FE:  GOTO   0EF
00FF:  BCF    0A.3
0100:  BCF    0A.4
0101:  GOTO   4B0 (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
*
0277:  DECFSZ 46,W
0278:  GOTO   27A
0279:  GOTO   27D
....................       address=LCD_LINE_TWO;
027A:  MOVLW  40
027B:  MOVWF  47
027C:  GOTO   27E
....................    else
....................       address=0;
027D:  CLRF   47
....................      
....................    address+=x-1;
027E:  MOVLW  01
027F:  SUBWF  45,W
0280:  ADDWF  47,F
....................    lcd_send_byte(0,0x80|address);
0281:  MOVF   47,W
0282:  IORLW  80
0283:  MOVWF  48
0284:  CLRF   49
0285:  MOVF   48,W
0286:  MOVWF  4A
0287:  CALL   084
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0288:  RETURN
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
0289:  MOVF   44,W
028A:  XORLW  07
028B:  BTFSC  03.2
028C:  GOTO   297
028D:  XORLW  0B
028E:  BTFSC  03.2
028F:  GOTO   29C
0290:  XORLW  06
0291:  BTFSC  03.2
0292:  GOTO   2A4
0293:  XORLW  02
0294:  BTFSC  03.2
0295:  GOTO   2AA
0296:  GOTO   2AF
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
0297:  MOVLW  01
0298:  MOVWF  45
0299:  MOVWF  46
029A:  CALL   277
029B:  GOTO   2B4
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
029C:  CLRF   49
029D:  MOVLW  01
029E:  MOVWF  4A
029F:  CALL   084
....................                      delay_ms(2);
02A0:  MOVLW  02
02A1:  MOVWF  45
02A2:  CALL   05D
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
02A3:  GOTO   2B4
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
02A4:  MOVLW  01
02A5:  MOVWF  45
02A6:  MOVLW  02
02A7:  MOVWF  46
02A8:  CALL   277
02A9:  GOTO   2B4
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
02AA:  CLRF   49
02AB:  MOVLW  10
02AC:  MOVWF  4A
02AD:  CALL   084
02AE:  GOTO   2B4
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
02AF:  MOVLW  01
02B0:  MOVWF  49
02B1:  MOVF   44,W
02B2:  MOVWF  4A
02B3:  CALL   084
....................      #endif
....................    }
02B4:  RETURN
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <kbd.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             KBD.C                                 ////
.................... ////                  Generic keypad scan driver                       ////
.................... ////                                                                   ////
.................... ////  kbd_init()   Must be called before any other function.           ////
.................... ////                                                                   ////
.................... ////  c = kbd_getc()  Will return a key value if pressed or /0 if not  ////
.................... ////                   This function should be called frequently so as ////
.................... ////                   not to miss a key press.                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////// The following defines the keypad layout on port D
.................... 
.................... // Un-comment the following define to use port B
.................... // #define use_portb_kbd TRUE
.................... 
.................... // Make sure the port used has pull-up resistors (or the LCD) on
.................... // the column pins
.................... 
.................... #if defined use_portb_kbd
....................    #byte kbd = getenv("SFR:PORTB")
.................... #else
....................    #byte kbd = getenv("SFR:PORTD")
.................... #endif
.................... 
.................... #if defined use_portb_kbd
....................    #define set_tris_kbd(x) set_tris_b(x)
.................... #else
....................    #define set_tris_kbd(x) set_tris_d(x)
.................... #endif
.................... 
.................... //Keypad connection:   (for example column 0 is B2)
.................... //                Bx:
.................... 
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad
.................... #define COL0 (1 << 2)
.................... #define COL1 (1 << 3)
.................... #define COL2 (1 << 6)
.................... 
.................... #define ROW0 (1 << 4)
.................... #define ROW1 (1 << 7)
.................... #define ROW2 (1 << 1)
.................... #define ROW3 (1 << 5)
.................... 
.................... #else ////////////////////////////////////////////////// For the black keypad
.................... #define COL0 (1 << 5)
.................... #define COL1 (1 << 6)
.................... #define COL2 (1 << 7)
.................... 
.................... #define ROW0 (1 << 1)
.................... #define ROW1 (1 << 2)
.................... #define ROW2 (1 << 3)
.................... #define ROW3 (1 << 4)
.................... 
.................... #endif
.................... 
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3)
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2)
.................... 
.................... // Keypad layout:
.................... char const KEYS[4][3] = {{'1','2','3'},
....................                          {'4','5','6'},
....................                          {'7','8','9'},
....................                          {'*','0','#'}};
.................... 
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where
....................                                   // n is the number of times you expect
....................                                   // to call kbd_getc each second
.................... 
.................... 
.................... void kbd_init() {
*
005A:  BCF    0A.3
005B:  BCF    0A.4
005C:  GOTO   4AF (RETURN)
.................... }
.................... 
.................... char kbd_getc( ) {
....................    static BYTE kbd_call_count;
*
0480:  BCF    03.5
0481:  CLRF   20
....................    static int1 kbd_down;
0482:  BCF    21.0
....................    static char last_key;
0483:  CLRF   22
....................    static BYTE col;
0484:  CLRF   23
.................... 
....................    BYTE kchar;
....................    BYTE row;
.................... 
....................    kchar='\0';
*
01ED:  CLRF   40
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) {
01EE:  INCF   20,F
01EF:  MOVF   20,W
01F0:  SUBLW  21
01F1:  BTFSC  03.0
01F2:  GOTO   26E
....................        switch (col) {
01F3:  MOVF   23,W
01F4:  BTFSC  03.2
01F5:  GOTO   1FD
01F6:  XORLW  01
01F7:  BTFSC  03.2
01F8:  GOTO   203
01F9:  XORLW  03
01FA:  BTFSC  03.2
01FB:  GOTO   209
01FC:  GOTO   20E
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0);
01FD:  MOVLW  DE
01FE:  BSF    03.5
01FF:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS;
0200:  BCF    03.5
0201:  MOVWF  06
....................                     break;
0202:  GOTO   20E
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1);
0203:  MOVLW  BE
0204:  BSF    03.5
0205:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS;
0206:  BCF    03.5
0207:  MOVWF  06
....................                     break;
0208:  GOTO   20E
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2);
0209:  MOVLW  7E
020A:  BSF    03.5
020B:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS;
020C:  BCF    03.5
020D:  MOVWF  06
....................                     break;
....................        }
.................... 
....................        if(kbd_down) {
020E:  BTFSS  21.0
020F:  GOTO   21A
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) {
0210:  MOVF   06,W
0211:  ANDLW  1E
0212:  SUBLW  1E
0213:  BTFSS  03.2
0214:  GOTO   219
....................            kbd_down=FALSE;
0215:  BCF    21.0
....................            kchar=last_key;
0216:  MOVF   22,W
0217:  MOVWF  40
....................            last_key='\0';
0218:  CLRF   22
....................          }
....................        } else {
0219:  GOTO   26D
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) {
021A:  MOVF   06,W
021B:  ANDLW  1E
021C:  SUBLW  1E
021D:  BTFSC  03.2
021E:  GOTO   268
....................              if((kbd & ROW0)==0)
021F:  MOVF   06,W
0220:  ANDLW  02
0221:  BTFSS  03.2
0222:  GOTO   225
....................                row=0;
0223:  CLRF   41
0224:  GOTO   239
....................              else if((kbd & ROW1)==0)
0225:  MOVF   06,W
0226:  ANDLW  04
0227:  BTFSS  03.2
0228:  GOTO   22C
....................                row=1;
0229:  MOVLW  01
022A:  MOVWF  41
022B:  GOTO   239
....................              else if((kbd & ROW2)==0)
022C:  MOVF   06,W
022D:  ANDLW  08
022E:  BTFSS  03.2
022F:  GOTO   233
....................                row=2;
0230:  MOVLW  02
0231:  MOVWF  41
0232:  GOTO   239
....................              else if((kbd & ROW3)==0)
0233:  MOVF   06,W
0234:  ANDLW  10
0235:  BTFSS  03.2
0236:  GOTO   239
....................                row=3;
0237:  MOVLW  03
0238:  MOVWF  41
....................              last_key =KEYS[row][col];
0239:  MOVF   41,W
023A:  MOVWF  42
023B:  MOVLW  03
023C:  MOVWF  43
*
0261:  MOVF   23,W
0262:  ADDWF  78,W
0263:  CALL   004
0264:  MOVWF  78
0265:  MOVWF  22
....................              kbd_down = TRUE;
0266:  BSF    21.0
....................           } else {
0267:  GOTO   26D
....................              ++col;
0268:  INCF   23,F
....................              if(col==3)
0269:  MOVF   23,W
026A:  SUBLW  03
026B:  BTFSC  03.2
....................                col=0;
026C:  CLRF   23
....................           }
....................        }
....................       kbd_call_count=0;
026D:  CLRF   20
....................    }
....................   set_tris_kbd(ALL_PINS);
026E:  MOVLW  FE
026F:  BSF    03.5
0270:  MOVWF  06
....................   return(kchar);
0271:  BCF    03.5
0272:  MOVF   40,W
0273:  MOVWF  78
0274:  BCF    0A.3
0275:  BCF    0A.4
0276:  GOTO   4F8 (RETURN)
.................... }
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
0485:  CLRF   24
0486:  CLRF   25
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... //#rom 0x2100={'1','2','3','4','5','6','7','8','9','0','#'}
.................... 
.................... float temperatura;
.................... char keypad;
.................... int i;
.................... char keys_pressed[5];
.................... char password[10];
.................... 
.................... void checkTemp(){
....................     if(temperatura<20)  {
*
03A3:  MOVF   29,W
03A4:  MOVWF  43
03A5:  MOVF   28,W
03A6:  MOVWF  42
03A7:  MOVF   27,W
03A8:  MOVWF  41
03A9:  MOVF   26,W
03AA:  MOVWF  40
03AB:  CLRF   47
03AC:  CLRF   46
03AD:  MOVLW  20
03AE:  MOVWF  45
03AF:  MOVLW  83
03B0:  MOVWF  44
03B1:  CALL   364
03B2:  BTFSS  03.0
03B3:  GOTO   3EB
....................         //Abre
....................         lcd_gotoxy(1,2);
03B4:  MOVLW  01
03B5:  MOVWF  45
03B6:  MOVLW  02
03B7:  MOVWF  46
03B8:  CALL   277
....................         printf(lcd_putc,"\fpuerta abierta");
03B9:  MOVLW  14
03BA:  BSF    03.6
03BB:  MOVWF  0D
03BC:  MOVLW  00
03BD:  MOVWF  0F
03BE:  BCF    03.6
03BF:  CALL   30E
....................         output_high(PIN_B3);
03C0:  BSF    03.5
03C1:  BCF    06.3
03C2:  BCF    03.5
03C3:  BSF    06.3
....................         delay_ms(10000);
03C4:  MOVLW  28
03C5:  MOVWF  40
03C6:  MOVLW  FA
03C7:  MOVWF  45
03C8:  CALL   05D
03C9:  DECFSZ 40,F
03CA:  GOTO   3C6
....................         output_low(PIN_B3);
03CB:  BSF    03.5
03CC:  BCF    06.3
03CD:  BCF    03.5
03CE:  BCF    06.3
....................         
....................         //Cierra
....................         lcd_gotoxy (1,2);
03CF:  MOVLW  01
03D0:  MOVWF  45
03D1:  MOVLW  02
03D2:  MOVWF  46
03D3:  CALL   277
....................         printf(lcd_putc,"\fpuerta cerrada");
03D4:  MOVLW  1C
03D5:  BSF    03.6
03D6:  MOVWF  0D
03D7:  MOVLW  00
03D8:  MOVWF  0F
03D9:  BCF    03.6
03DA:  CALL   30E
....................         output_high(PIN_D3);
03DB:  BSF    03.5
03DC:  BCF    08.3
03DD:  BCF    03.5
03DE:  BSF    08.3
....................         delay_ms(10000);
03DF:  MOVLW  28
03E0:  MOVWF  40
03E1:  MOVLW  FA
03E2:  MOVWF  45
03E3:  CALL   05D
03E4:  DECFSZ 40,F
03E5:  GOTO   3E1
....................         output_low(PIN_D3);
03E6:  BSF    03.5
03E7:  BCF    08.3
03E8:  BCF    03.5
03E9:  BCF    08.3
....................     }
03EA:  GOTO   46C
....................     else if(temperatura>=20&&temperatura<=35)  {         
03EB:  CLRF   43
03EC:  CLRF   42
03ED:  MOVLW  20
03EE:  MOVWF  41
03EF:  MOVLW  83
03F0:  MOVWF  40
03F1:  MOVF   29,W
03F2:  MOVWF  47
03F3:  MOVF   28,W
03F4:  MOVWF  46
03F5:  MOVF   27,W
03F6:  MOVWF  45
03F7:  MOVF   26,W
03F8:  MOVWF  44
03F9:  CALL   364
03FA:  BTFSC  03.0
03FB:  GOTO   3FE
03FC:  BTFSS  03.2
03FD:  GOTO   43E
03FE:  MOVF   29,W
03FF:  MOVWF  43
0400:  MOVF   28,W
0401:  MOVWF  42
0402:  MOVF   27,W
0403:  MOVWF  41
0404:  MOVF   26,W
0405:  MOVWF  40
0406:  CLRF   47
0407:  CLRF   46
0408:  MOVLW  0C
0409:  MOVWF  45
040A:  MOVLW  84
040B:  MOVWF  44
040C:  CALL   364
040D:  BTFSC  03.0
040E:  GOTO   411
040F:  BTFSS  03.2
0410:  GOTO   43E
....................         //Abre
....................         lcd_gotoxy(1,2);
0411:  MOVLW  01
0412:  MOVWF  45
0413:  MOVLW  02
0414:  MOVWF  46
0415:  CALL   277
....................         set_pwm1_duty(100);
0416:  MOVLW  64
0417:  MOVWF  15
....................         printf(lcd_putc,"\fpuerta abierta");
0418:  MOVLW  24
0419:  BSF    03.6
041A:  MOVWF  0D
041B:  MOVLW  00
041C:  MOVWF  0F
041D:  BCF    03.6
041E:  CALL   30E
....................         delay_ms(5000);
041F:  MOVLW  14
0420:  MOVWF  40
0421:  MOVLW  FA
0422:  MOVWF  45
0423:  CALL   05D
0424:  DECFSZ 40,F
0425:  GOTO   421
....................         set_pwm1_duty(0);
0426:  CLRF   15
.................... 
....................         //Cierra
....................         lcd_gotoxy (1,2);
0427:  MOVLW  01
0428:  MOVWF  45
0429:  MOVLW  02
042A:  MOVWF  46
042B:  CALL   277
....................         set_pwm2_duty(100);
042C:  MOVLW  64
042D:  MOVWF  1B
....................         printf(lcd_putc,"\fpuerta cerrada");
042E:  MOVLW  2C
042F:  BSF    03.6
0430:  MOVWF  0D
0431:  MOVLW  00
0432:  MOVWF  0F
0433:  BCF    03.6
0434:  CALL   30E
....................         delay_ms(5000);
0435:  MOVLW  14
0436:  MOVWF  40
0437:  MOVLW  FA
0438:  MOVWF  45
0439:  CALL   05D
043A:  DECFSZ 40,F
043B:  GOTO   437
....................         set_pwm2_duty(0);
043C:  CLRF   1B
....................     }
043D:  GOTO   46C
....................     else if(temperatura>35)  {
043E:  CLRF   43
043F:  CLRF   42
0440:  MOVLW  0C
0441:  MOVWF  41
0442:  MOVLW  84
0443:  MOVWF  40
0444:  MOVF   29,W
0445:  MOVWF  47
0446:  MOVF   28,W
0447:  MOVWF  46
0448:  MOVF   27,W
0449:  MOVWF  45
044A:  MOVF   26,W
044B:  MOVWF  44
044C:  CALL   364
044D:  BTFSS  03.0
044E:  GOTO   46C
....................         printf(lcd_putc,"\fpuerta cerrada");
044F:  MOVLW  34
0450:  BSF    03.6
0451:  MOVWF  0D
0452:  MOVLW  00
0453:  MOVWF  0F
0454:  BCF    03.6
0455:  CALL   30E
....................         set_pwm1_duty(228);
0456:  MOVLW  E4
0457:  MOVWF  15
....................         output_low(49); // PIN B1 (BUZZER) 
0458:  BSF    03.5
0459:  BCF    06.1
045A:  BCF    03.5
045B:  BCF    06.1
....................         delay_ms(500);
045C:  MOVLW  02
045D:  MOVWF  40
045E:  MOVLW  FA
045F:  MOVWF  45
0460:  CALL   05D
0461:  DECFSZ 40,F
0462:  GOTO   45E
....................         set_pwm1_duty(228);
0463:  MOVLW  E4
0464:  MOVWF  15
....................         delay_ms(500);
0465:  MOVLW  02
0466:  MOVWF  40
0467:  MOVLW  FA
0468:  MOVWF  45
0469:  CALL   05D
046A:  DECFSZ 40,F
046B:  GOTO   467
....................     }
....................     keys_pressed[0]='*';
046C:  MOVLW  2A
046D:  MOVWF  2C
....................     keys_pressed[1]='*';
046E:  MOVWF  2D
....................     keys_pressed[2]='*';
046F:  MOVWF  2E
....................     keys_pressed[3]='*';
0470:  MOVWF  2F
....................     keys_pressed[4]='*';
0471:  MOVWF  30
0472:  RETURN
....................     
....................     
.................... }
.................... 
.................... void main() {
0473:  MOVF   03,W
0474:  ANDLW  1F
0475:  MOVWF  03
0476:  CLRF   3C
0477:  CLRF   3B
0478:  MOVLW  FF
0479:  MOVWF  3D
047A:  BSF    03.5
047B:  BSF    1F.0
047C:  BSF    1F.1
047D:  BSF    1F.2
047E:  BCF    1F.3
047F:  BCF    03.7
*
0487:  CLRF   3E
0488:  MOVLW  01
0489:  MOVWF  3F
....................     int checkPassword=0;
....................     int valid=1;
....................     
....................     setup_adc_ports (RA0_ANALOG); 
048A:  BSF    03.5
048B:  BCF    1F.0
048C:  BSF    1F.1
048D:  BSF    1F.2
048E:  BSF    1F.3
....................     setup_adc(ADC_CLOCK_INTERNAL);
048F:  BCF    03.5
0490:  BSF    1F.6
0491:  BSF    1F.7
0492:  BSF    03.5
0493:  BSF    1F.7
0494:  BCF    03.5
0495:  BSF    1F.0
....................     //set_adc_channel(0);
....................     setup_ccp1(0x0C);
0496:  BCF    3D.2
0497:  MOVF   3D,W
0498:  BSF    03.5
0499:  MOVWF  07
049A:  BCF    03.5
049B:  BCF    07.2
049C:  MOVLW  0C
049D:  MOVWF  17
....................     setup_ccp2(0x0C);
049E:  BCF    3D.1
049F:  MOVF   3D,W
04A0:  BSF    03.5
04A1:  MOVWF  07
04A2:  BCF    03.5
04A3:  BCF    07.1
04A4:  MOVLW  0C
04A5:  MOVWF  1D
....................     setup_timer_2(T2_DIV_BY_16,255,1);
04A6:  MOVLW  00
04A7:  MOVWF  78
04A8:  IORLW  06
04A9:  MOVWF  12
04AA:  MOVLW  FF
04AB:  BSF    03.5
04AC:  MOVWF  12
.................... 
....................     kbd_init();
04AD:  BCF    03.5
04AE:  GOTO   05A
....................     lcd_init();                                  
04AF:  GOTO   0C4
....................     port_b_pullups(TRUE);   //habilitan las resistencias pull up para evitar resistencias en el teclado
04B0:  BSF    03.5
04B1:  BCF    01.7
....................     
.................... 
....................     //setup_ccp1(0x0C);                            //configuracion modo pwm cpp_pwn
....................     //setup_timer_2(T2_DIV_BY_16,255,1);              //configuracion del timer 2 y postcaler
....................     // tambien printf(putc,(\f))  para borrar         
....................     i=0;
04B2:  BCF    03.5
04B3:  CLRF   2B
....................     for (i=0;i<10;i++){      //pasa los datos de eeprom a la matriz
04B4:  CLRF   2B
04B5:  MOVF   2B,W
04B6:  SUBLW  09
04B7:  BTFSS  03.0
04B8:  GOTO   4C9
....................         password[i]=read_eeprom(i);
04B9:  MOVLW  31
04BA:  ADDWF  2B,W
04BB:  MOVWF  04
04BC:  BCF    03.7
04BD:  MOVF   2B,W
04BE:  BSF    03.6
04BF:  MOVWF  0D
04C0:  BSF    03.5
04C1:  BCF    0C.7
04C2:  BSF    0C.0
04C3:  BCF    03.5
04C4:  MOVF   0C,W
04C5:  MOVWF  00
04C6:  BCF    03.6
04C7:  INCF   2B,F
04C8:  GOTO   4B5
....................     }
.................... 
....................     while (TRUE)   {
....................         //Muestra Temperatura
....................         temperatura=(float)read_adc()/2;
04C9:  BSF    1F.2
04CA:  BTFSC  1F.2
04CB:  GOTO   4CA
04CC:  MOVF   1E,W
04CD:  MOVWF  79
04CE:  BSF    03.5
04CF:  MOVF   1E,W
04D0:  MOVWF  78
04D1:  MOVF   79,W
04D2:  MOVWF  7A
04D3:  MOVF   1E,W
04D4:  BCF    03.5
04D5:  MOVWF  40
04D6:  MOVF   79,W
04D7:  MOVWF  41
04D8:  GOTO   102
04D9:  MOVF   7A,W
04DA:  MOVWF  43
04DB:  MOVF   79,W
04DC:  MOVWF  42
04DD:  MOVF   78,W
04DE:  MOVWF  41
04DF:  MOVF   77,W
04E0:  MOVWF  40
04E1:  MOVF   7A,W
04E2:  MOVWF  47
04E3:  MOVF   79,W
04E4:  MOVWF  46
04E5:  MOVF   78,W
04E6:  MOVWF  45
04E7:  MOVF   77,W
04E8:  MOVWF  44
04E9:  CLRF   4B
04EA:  CLRF   4A
04EB:  CLRF   49
04EC:  MOVLW  80
04ED:  MOVWF  48
04EE:  GOTO   121
04EF:  MOVF   7A,W
04F0:  MOVWF  29
04F1:  MOVF   79,W
04F2:  MOVWF  28
04F3:  MOVF   78,W
04F4:  MOVWF  27
04F5:  MOVF   77,W
04F6:  MOVWF  26
....................         //lcd_gotoxy(1,1);           
....................         //printf(lcd_putc,"TEMP: %f ",temperatura);
....................         //lcd_gotoxy(12,1);
....................         //printf (lcd_putc,"C");
....................         //delay_ms(200);
....................         
....................         //lee teclado
....................         keypad=kbd_getc();           
04F7:  GOTO   1ED
04F8:  MOVF   78,W
04F9:  MOVWF  2A
....................         if(keypad!=0){
04FA:  MOVF   2A,F
04FB:  BTFSC  03.2
04FC:  GOTO   521
....................             printf(lcd_putc,"\f tecla No= %c",keypad);
04FD:  MOVLW  3C
04FE:  BSF    03.6
04FF:  MOVWF  0D
0500:  MOVLW  00
0501:  MOVWF  0F
0502:  BCF    03.0
0503:  MOVLW  0C
0504:  BCF    03.6
0505:  MOVWF  40
0506:  GOTO   2B5
0507:  MOVF   2A,W
0508:  MOVWF  44
0509:  CALL   289
....................             delay_ms(200);
050A:  MOVLW  C8
050B:  MOVWF  45
050C:  CALL   05D
....................             if(keypad=='#'){
050D:  MOVF   2A,W
050E:  SUBLW  23
050F:  BTFSS  03.2
0510:  GOTO   514
....................                 checkPassword=1;
0511:  MOVLW  01
0512:  MOVWF  3E
....................             }
0513:  GOTO   521
....................             else if(i>4){
0514:  MOVF   2B,W
0515:  SUBLW  04
0516:  BTFSC  03.0
0517:  GOTO   51A
....................                 valid=0;
0518:  CLRF   3F
....................             }
0519:  GOTO   521
....................             else{
....................                 keys_pressed[i]=keypad;
051A:  MOVLW  2C
051B:  ADDWF  2B,W
051C:  MOVWF  04
051D:  BCF    03.7
051E:  MOVF   2A,W
051F:  MOVWF  00
....................                 i++;   
0520:  INCF   2B,F
....................             }
....................         }
....................         //Cuando digita contrasena
....................         if(checkPassword==1){
0521:  DECFSZ 3E,W
0522:  GOTO   583
....................             if( keys_pressed[0]=='1' && 
....................                 keys_pressed[1]=='2' && 
....................                 keys_pressed[2]=='3' &&
....................                 keys_pressed[3]=='4' &&
....................                 keys_pressed[4]=='5' && valid==1){
0523:  MOVF   2C,W
0524:  SUBLW  31
0525:  BTFSS  03.2
0526:  GOTO   54A
0527:  MOVF   2D,W
0528:  SUBLW  32
0529:  BTFSS  03.2
052A:  GOTO   54A
052B:  MOVF   2E,W
052C:  SUBLW  33
052D:  BTFSS  03.2
052E:  GOTO   54A
052F:  MOVF   2F,W
0530:  SUBLW  34
0531:  BTFSS  03.2
0532:  GOTO   54A
0533:  MOVF   30,W
0534:  SUBLW  35
0535:  BTFSS  03.2
0536:  GOTO   54A
0537:  DECFSZ 3F,W
0538:  GOTO   54A
....................                 i=0;
0539:  CLRF   2B
....................                 printf(lcd_putc,"\fPIN Correcto");
053A:  MOVLW  44
053B:  BSF    03.6
053C:  MOVWF  0D
053D:  MOVLW  00
053E:  MOVWF  0F
053F:  BCF    03.6
0540:  CALL   30E
....................                 delay_ms(2000);
0541:  MOVLW  08
0542:  MOVWF  40
0543:  MOVLW  FA
0544:  MOVWF  45
0545:  CALL   05D
0546:  DECFSZ 40,F
0547:  GOTO   543
....................                 checkTemp();
0548:  CALL   3A3
....................             }
0549:  GOTO   580
....................             else if(keys_pressed[0]=='6' && 
....................                     keys_pressed[1]=='7' && 
....................                     keys_pressed[2]=='8' &&
....................                     keys_pressed[3]=='9' &&
....................                     keys_pressed[4]=='0' && valid==1){
054A:  MOVF   2C,W
054B:  SUBLW  36
054C:  BTFSS  03.2
054D:  GOTO   571
054E:  MOVF   2D,W
054F:  SUBLW  37
0550:  BTFSS  03.2
0551:  GOTO   571
0552:  MOVF   2E,W
0553:  SUBLW  38
0554:  BTFSS  03.2
0555:  GOTO   571
0556:  MOVF   2F,W
0557:  SUBLW  39
0558:  BTFSS  03.2
0559:  GOTO   571
055A:  MOVF   30,W
055B:  SUBLW  30
055C:  BTFSS  03.2
055D:  GOTO   571
055E:  DECFSZ 3F,W
055F:  GOTO   571
....................                 i=0;
0560:  CLRF   2B
....................                 printf(lcd_putc,"\fPIN Correcto");
0561:  MOVLW  4B
0562:  BSF    03.6
0563:  MOVWF  0D
0564:  MOVLW  00
0565:  MOVWF  0F
0566:  BCF    03.6
0567:  CALL   30E
....................                 delay_ms(2000);
0568:  MOVLW  08
0569:  MOVWF  40
056A:  MOVLW  FA
056B:  MOVWF  45
056C:  CALL   05D
056D:  DECFSZ 40,F
056E:  GOTO   56A
....................                 checkTemp();
056F:  CALL   3A3
....................             }
0570:  GOTO   580
....................             else {
....................                 printf(lcd_putc,"\fPIN Incorrecto");
0571:  MOVLW  52
0572:  BSF    03.6
0573:  MOVWF  0D
0574:  MOVLW  00
0575:  MOVWF  0F
0576:  BCF    03.6
0577:  CALL   30E
....................                 i=0;
0578:  CLRF   2B
....................                 delay_ms(2000);
0579:  MOVLW  08
057A:  MOVWF  40
057B:  MOVLW  FA
057C:  MOVWF  45
057D:  CALL   05D
057E:  DECFSZ 40,F
057F:  GOTO   57B
....................             }
....................             checkPassword=0;
0580:  CLRF   3E
....................             valid=1;
0581:  MOVLW  01
0582:  MOVWF  3F
....................         }
0583:  GOTO   4C9
....................     }
.................... }
0584:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
