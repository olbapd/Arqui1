CCS PCM C Compiler, Version 5.088d, 1               11-Nov-19 16:29
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\pablo\Documents\1-TEC\Arqui1\Examen\MP\Examen.X\build\default\production\main.lst

               ROM used:   2552 words (31%)
                           Largest free fragment is 2048
               RAM used:   37 (10%) at main() level
                           59 (16%) worst case
               Stack used: 6 locations
               Stack size: 8

*
0000:  MOVLW  08
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
.................... #include <16f877.h>
.................... //////////// Standard Header file for the PIC16F877 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  34
000C:  RETLW  35
000D:  RETLW  36
000E:  RETLW  37
000F:  RETLW  38
0010:  RETLW  39
0011:  RETLW  2A
0012:  RETLW  30
0013:  RETLW  23
0014:  DATA 0C,38
0015:  DATA F5,32
0016:  DATA 72,3A
0017:  DATA 61,10
0018:  DATA 61,31
0019:  DATA E9,32
001A:  DATA 72,3A
001B:  DATA 61,00
001C:  DATA 0C,38
001D:  DATA F5,32
001E:  DATA 72,3A
001F:  DATA 61,10
0020:  DATA E3,32
0021:  DATA 72,39
0022:  DATA 61,32
0023:  DATA 61,00
0024:  DATA 0C,38
0025:  DATA F5,32
0026:  DATA 72,3A
0027:  DATA 61,10
0028:  DATA 61,31
0029:  DATA E9,32
002A:  DATA 72,3A
002B:  DATA 61,00
002C:  DATA 0C,38
002D:  DATA F5,32
002E:  DATA 72,3A
002F:  DATA 61,10
0030:  DATA E3,32
0031:  DATA 72,39
0032:  DATA 61,32
0033:  DATA 61,00
0034:  DATA 0C,2A
0035:  DATA E5,36
0036:  DATA 70,10
0037:  DATA 61,36
0038:  DATA F4,30
0039:  DATA 2C,00
003A:  DATA 69,37
003B:  DATA F4,32
003C:  DATA 6E,3A
003D:  DATA 61,39
003E:  DATA 20,32
003F:  DATA E5,39
0040:  DATA F0,3A
0041:  DATA E5,39
0042:  DATA 2E,00
0043:  DATA 0C,2A
0044:  DATA C5,26
0045:  DATA 50,1D
0046:  DATA A0,12
0047:  DATA 66,10
0048:  DATA 00,00
0049:  DATA 0C,2A
004A:  DATA C5,26
004B:  DATA 50,1D
004C:  DATA A0,12
004D:  DATA 66,10
004E:  DATA 00,01
004F:  DATA 0C,2A
0050:  DATA C5,26
0051:  DATA 50,1D
0052:  DATA A0,12
0053:  DATA 66,10
0054:  DATA 00,01
0055:  DATA 0C,10
0056:  DATA F4,32
0057:  DATA 63,36
0058:  DATA 61,10
0059:  DATA CE,37
005A:  DATA 3D,10
005B:  DATA A5,31
005C:  DATA 00,01
005D:  DATA 0C,28
005E:  DATA 49,27
005F:  DATA A0,21
0060:  DATA 6F,39
0061:  DATA F2,32
0062:  DATA 63,3A
0063:  DATA 6F,00
0064:  DATA 0C,28
0065:  DATA 49,27
0066:  DATA A0,21
0067:  DATA 6F,39
0068:  DATA F2,32
0069:  DATA 63,3A
006A:  DATA 6F,00
006B:  DATA 0C,28
006C:  DATA 49,27
006D:  DATA A0,24
006E:  DATA EE,31
006F:  DATA 6F,39
0070:  DATA F2,32
0071:  DATA 63,3A
0072:  DATA 6F,00
0073:  DATA 0C,2A
0074:  DATA C5,26
0075:  DATA 50,1D
0076:  DATA A0,12
0077:  DATA 66,10
0078:  DATA 00,01
*
0121:  MOVLW  8E
0122:  MOVWF  77
0123:  MOVF   3D,W
0124:  MOVWF  78
0125:  MOVF   3C,W
0126:  MOVWF  79
0127:  CLRF   7A
0128:  MOVF   78,F
0129:  BTFSS  03.2
012A:  GOTO   135
012B:  MOVF   79,W
012C:  MOVWF  78
012D:  CLRF   79
012E:  MOVLW  08
012F:  SUBWF  77,F
0130:  MOVF   78,F
0131:  BTFSS  03.2
0132:  GOTO   135
0133:  CLRF   77
0134:  GOTO   13D
0135:  BCF    03.0
0136:  BTFSC  78.7
0137:  GOTO   13C
0138:  RLF    79,F
0139:  RLF    78,F
013A:  DECF   77,F
013B:  GOTO   135
013C:  BCF    78.7
013D:  BSF    0A.3
013E:  BCF    0A.4
013F:  GOTO   064 (RETURN)
0140:  MOVF   40,W
0141:  BTFSC  03.2
0142:  GOTO   205
0143:  MOVWF  4C
0144:  MOVF   44,W
0145:  BTFSC  03.2
0146:  GOTO   205
0147:  SUBWF  4C,F
0148:  BTFSS  03.0
0149:  GOTO   14F
014A:  MOVLW  7F
014B:  ADDWF  4C,F
014C:  BTFSC  03.0
014D:  GOTO   205
014E:  GOTO   155
014F:  MOVLW  81
0150:  SUBWF  4C,F
0151:  BTFSS  03.0
0152:  GOTO   205
0153:  BTFSC  03.2
0154:  GOTO   205
0155:  MOVF   4C,W
0156:  MOVWF  77
0157:  CLRF   78
0158:  CLRF   79
0159:  CLRF   7A
015A:  CLRF   4B
015B:  MOVF   41,W
015C:  MOVWF  4A
015D:  BSF    4A.7
015E:  MOVF   42,W
015F:  MOVWF  49
0160:  MOVF   43,W
0161:  MOVWF  48
0162:  MOVLW  19
0163:  MOVWF  4C
0164:  MOVF   47,W
0165:  SUBWF  48,F
0166:  BTFSC  03.0
0167:  GOTO   178
0168:  MOVLW  01
0169:  SUBWF  49,F
016A:  BTFSC  03.0
016B:  GOTO   178
016C:  SUBWF  4A,F
016D:  BTFSC  03.0
016E:  GOTO   178
016F:  SUBWF  4B,F
0170:  BTFSC  03.0
0171:  GOTO   178
0172:  INCF   4B,F
0173:  INCF   4A,F
0174:  INCF   49,F
0175:  MOVF   47,W
0176:  ADDWF  48,F
0177:  GOTO   1AA
0178:  MOVF   46,W
0179:  SUBWF  49,F
017A:  BTFSC  03.0
017B:  GOTO   193
017C:  MOVLW  01
017D:  SUBWF  4A,F
017E:  BTFSC  03.0
017F:  GOTO   193
0180:  SUBWF  4B,F
0181:  BTFSC  03.0
0182:  GOTO   193
0183:  INCF   4B,F
0184:  INCF   4A,F
0185:  MOVF   46,W
0186:  ADDWF  49,F
0187:  MOVF   47,W
0188:  ADDWF  48,F
0189:  BTFSS  03.0
018A:  GOTO   1AA
018B:  INCF   49,F
018C:  BTFSS  03.2
018D:  GOTO   1AA
018E:  INCF   4A,F
018F:  BTFSS  03.2
0190:  GOTO   1AA
0191:  INCF   4B,F
0192:  GOTO   1AA
0193:  MOVF   45,W
0194:  IORLW  80
0195:  SUBWF  4A,F
0196:  BTFSC  03.0
0197:  GOTO   1A9
0198:  MOVLW  01
0199:  SUBWF  4B,F
019A:  BTFSC  03.0
019B:  GOTO   1A9
019C:  INCF   4B,F
019D:  MOVF   45,W
019E:  IORLW  80
019F:  ADDWF  4A,F
01A0:  MOVF   46,W
01A1:  ADDWF  49,F
01A2:  BTFSS  03.0
01A3:  GOTO   187
01A4:  INCF   4A,F
01A5:  BTFSS  03.2
01A6:  GOTO   187
01A7:  INCF   4B,F
01A8:  GOTO   187
01A9:  BSF    7A.0
01AA:  DECFSZ 4C,F
01AB:  GOTO   1AD
01AC:  GOTO   1B8
01AD:  BCF    03.0
01AE:  RLF    48,F
01AF:  RLF    49,F
01B0:  RLF    4A,F
01B1:  RLF    4B,F
01B2:  BCF    03.0
01B3:  RLF    7A,F
01B4:  RLF    79,F
01B5:  RLF    78,F
01B6:  RLF    4D,F
01B7:  GOTO   164
01B8:  BTFSS  4D.0
01B9:  GOTO   1C0
01BA:  BCF    03.0
01BB:  RRF    78,F
01BC:  RRF    79,F
01BD:  RRF    7A,F
01BE:  RRF    4D,F
01BF:  GOTO   1C3
01C0:  DECF   77,F
01C1:  BTFSC  03.2
01C2:  GOTO   205
01C3:  BTFSC  4D.7
01C4:  GOTO   1EC
01C5:  BCF    03.0
01C6:  RLF    48,F
01C7:  RLF    49,F
01C8:  RLF    4A,F
01C9:  RLF    4B,F
01CA:  MOVF   47,W
01CB:  SUBWF  48,F
01CC:  BTFSC  03.0
01CD:  GOTO   1D8
01CE:  MOVLW  01
01CF:  SUBWF  49,F
01D0:  BTFSC  03.0
01D1:  GOTO   1D8
01D2:  SUBWF  4A,F
01D3:  BTFSC  03.0
01D4:  GOTO   1D8
01D5:  SUBWF  4B,F
01D6:  BTFSS  03.0
01D7:  GOTO   1FB
01D8:  MOVF   46,W
01D9:  SUBWF  49,F
01DA:  BTFSC  03.0
01DB:  GOTO   1E3
01DC:  MOVLW  01
01DD:  SUBWF  4A,F
01DE:  BTFSC  03.0
01DF:  GOTO   1E3
01E0:  SUBWF  4B,F
01E1:  BTFSS  03.0
01E2:  GOTO   1FB
01E3:  MOVF   45,W
01E4:  IORLW  80
01E5:  SUBWF  4A,F
01E6:  BTFSC  03.0
01E7:  GOTO   1EC
01E8:  MOVLW  01
01E9:  SUBWF  4B,F
01EA:  BTFSS  03.0
01EB:  GOTO   1FB
01EC:  INCF   7A,F
01ED:  BTFSS  03.2
01EE:  GOTO   1FB
01EF:  INCF   79,F
01F0:  BTFSS  03.2
01F1:  GOTO   1FB
01F2:  INCF   78,F
01F3:  BTFSS  03.2
01F4:  GOTO   1FB
01F5:  INCF   77,F
01F6:  BTFSC  03.2
01F7:  GOTO   205
01F8:  RRF    78,F
01F9:  RRF    79,F
01FA:  RRF    7A,F
01FB:  MOVF   41,W
01FC:  MOVWF  4C
01FD:  MOVF   45,W
01FE:  XORWF  4C,F
01FF:  BTFSS  4C.7
0200:  GOTO   203
0201:  BSF    78.7
0202:  GOTO   209
0203:  BCF    78.7
0204:  GOTO   209
0205:  CLRF   77
0206:  CLRF   78
0207:  CLRF   79
0208:  CLRF   7A
0209:  BSF    0A.3
020A:  BCF    0A.4
020B:  GOTO   07C (RETURN)
020C:  MOVF   41,W
020D:  MOVWF  48
020E:  MOVF   45,W
020F:  XORWF  48,F
0210:  BTFSS  48.7
0211:  GOTO   217
0212:  BCF    03.2
0213:  BCF    03.0
0214:  BTFSC  41.7
0215:  BSF    03.0
0216:  GOTO   24A
0217:  MOVF   41,W
0218:  MOVWF  48
0219:  MOVF   44,W
021A:  MOVWF  49
021B:  MOVF   40,W
021C:  SUBWF  49,F
021D:  BTFSC  03.2
021E:  GOTO   225
021F:  BTFSS  48.7
0220:  GOTO   24A
0221:  MOVF   03,W
0222:  XORLW  01
0223:  MOVWF  03
0224:  GOTO   24A
0225:  MOVF   45,W
0226:  MOVWF  49
0227:  MOVF   41,W
0228:  SUBWF  49,F
0229:  BTFSC  03.2
022A:  GOTO   231
022B:  BTFSS  48.7
022C:  GOTO   24A
022D:  MOVF   03,W
022E:  XORLW  01
022F:  MOVWF  03
0230:  GOTO   24A
0231:  MOVF   46,W
0232:  MOVWF  49
0233:  MOVF   42,W
0234:  SUBWF  49,F
0235:  BTFSC  03.2
0236:  GOTO   23D
0237:  BTFSS  48.7
0238:  GOTO   24A
0239:  MOVF   03,W
023A:  XORLW  01
023B:  MOVWF  03
023C:  GOTO   24A
023D:  MOVF   47,W
023E:  MOVWF  49
023F:  MOVF   43,W
0240:  SUBWF  49,F
0241:  BTFSC  03.2
0242:  GOTO   249
0243:  BTFSS  48.7
0244:  GOTO   24A
0245:  MOVF   03,W
0246:  XORLW  01
0247:  MOVWF  03
0248:  GOTO   24A
0249:  BCF    03.0
024A:  RETURN
024B:  MOVLW  80
024C:  BTFSC  03.1
024D:  XORWF  41,F
024E:  CLRF   46
024F:  CLRF   47
0250:  MOVF   3D,W
0251:  MOVWF  45
0252:  MOVF   41,W
0253:  XORWF  45,F
0254:  MOVF   3C,W
0255:  BTFSC  03.2
0256:  GOTO   33B
0257:  MOVWF  44
0258:  MOVWF  77
0259:  MOVF   40,W
025A:  BTFSC  03.2
025B:  GOTO   344
025C:  SUBWF  44,F
025D:  BTFSC  03.2
025E:  GOTO   2E0
025F:  BTFSS  03.0
0260:  GOTO   29E
0261:  MOVF   41,W
0262:  MOVWF  4A
0263:  BSF    4A.7
0264:  MOVF   42,W
0265:  MOVWF  49
0266:  MOVF   43,W
0267:  MOVWF  48
0268:  CLRF   47
0269:  BCF    03.0
026A:  RRF    4A,F
026B:  RRF    49,F
026C:  RRF    48,F
026D:  RRF    47,F
026E:  DECFSZ 44,F
026F:  GOTO   268
0270:  BTFSS  45.7
0271:  GOTO   275
0272:  BSF    46.0
0273:  GOTO   358
0274:  BCF    46.0
0275:  BCF    44.0
0276:  BSF    46.4
0277:  MOVLW  3F
0278:  MOVWF  04
0279:  BCF    03.7
027A:  GOTO   36D
027B:  BCF    46.4
027C:  BTFSC  45.7
027D:  GOTO   288
027E:  BTFSS  44.0
027F:  GOTO   293
0280:  RRF    4A,F
0281:  RRF    49,F
0282:  RRF    48,F
0283:  RRF    47,F
0284:  INCF   77,F
0285:  BTFSC  03.2
0286:  GOTO   353
0287:  GOTO   293
0288:  BTFSC  4A.7
0289:  GOTO   296
028A:  BCF    03.0
028B:  RLF    47,F
028C:  RLF    48,F
028D:  RLF    49,F
028E:  RLF    4A,F
028F:  DECF   77,F
0290:  BTFSC  03.2
0291:  GOTO   353
0292:  GOTO   288
0293:  BSF    46.6
0294:  GOTO   300
0295:  BCF    46.6
0296:  MOVF   3D,W
0297:  MOVWF  45
0298:  BTFSS  45.7
0299:  GOTO   29C
029A:  BSF    4A.7
029B:  GOTO   34C
029C:  BCF    4A.7
029D:  GOTO   34C
029E:  MOVF   40,W
029F:  MOVWF  44
02A0:  MOVWF  77
02A1:  MOVF   3C,W
02A2:  SUBWF  44,F
02A3:  MOVF   3D,W
02A4:  MOVWF  4A
02A5:  BSF    4A.7
02A6:  MOVF   3E,W
02A7:  MOVWF  49
02A8:  MOVF   3F,W
02A9:  MOVWF  48
02AA:  CLRF   47
02AB:  BCF    03.0
02AC:  RRF    4A,F
02AD:  RRF    49,F
02AE:  RRF    48,F
02AF:  RRF    47,F
02B0:  DECFSZ 44,F
02B1:  GOTO   2AA
02B2:  BTFSS  45.7
02B3:  GOTO   2B7
02B4:  BSF    46.1
02B5:  GOTO   358
02B6:  BCF    46.1
02B7:  BCF    44.0
02B8:  BSF    46.5
02B9:  MOVLW  43
02BA:  MOVWF  04
02BB:  BCF    03.7
02BC:  GOTO   36D
02BD:  BCF    46.5
02BE:  BTFSC  45.7
02BF:  GOTO   2CA
02C0:  BTFSS  44.0
02C1:  GOTO   2D5
02C2:  RRF    4A,F
02C3:  RRF    49,F
02C4:  RRF    48,F
02C5:  RRF    47,F
02C6:  INCF   77,F
02C7:  BTFSC  03.2
02C8:  GOTO   353
02C9:  GOTO   2D5
02CA:  BTFSC  4A.7
02CB:  GOTO   2D8
02CC:  BCF    03.0
02CD:  RLF    47,F
02CE:  RLF    48,F
02CF:  RLF    49,F
02D0:  RLF    4A,F
02D1:  DECF   77,F
02D2:  BTFSC  03.2
02D3:  GOTO   353
02D4:  GOTO   2CA
02D5:  BSF    46.7
02D6:  GOTO   300
02D7:  BCF    46.7
02D8:  MOVF   41,W
02D9:  MOVWF  45
02DA:  BTFSS  45.7
02DB:  GOTO   2DE
02DC:  BSF    4A.7
02DD:  GOTO   34C
02DE:  BCF    4A.7
02DF:  GOTO   34C
02E0:  MOVF   41,W
02E1:  MOVWF  4A
02E2:  BSF    4A.7
02E3:  MOVF   42,W
02E4:  MOVWF  49
02E5:  MOVF   43,W
02E6:  MOVWF  48
02E7:  BTFSS  45.7
02E8:  GOTO   2ED
02E9:  BCF    4A.7
02EA:  BSF    46.2
02EB:  GOTO   358
02EC:  BCF    46.2
02ED:  CLRF   47
02EE:  BCF    44.0
02EF:  MOVLW  3F
02F0:  MOVWF  04
02F1:  BCF    03.7
02F2:  GOTO   36D
02F3:  BTFSC  45.7
02F4:  GOTO   316
02F5:  MOVF   3D,W
02F6:  MOVWF  45
02F7:  BTFSS  44.0
02F8:  GOTO   300
02F9:  RRF    4A,F
02FA:  RRF    49,F
02FB:  RRF    48,F
02FC:  RRF    47,F
02FD:  INCF   77,F
02FE:  BTFSC  03.2
02FF:  GOTO   353
0300:  BTFSS  47.7
0301:  GOTO   311
0302:  INCF   48,F
0303:  BTFSS  03.2
0304:  GOTO   311
0305:  INCF   49,F
0306:  BTFSS  03.2
0307:  GOTO   311
0308:  INCF   4A,F
0309:  BTFSS  03.2
030A:  GOTO   311
030B:  RRF    4A,F
030C:  RRF    49,F
030D:  RRF    48,F
030E:  INCF   77,F
030F:  BTFSC  03.2
0310:  GOTO   353
0311:  BTFSC  46.6
0312:  GOTO   295
0313:  BTFSC  46.7
0314:  GOTO   2D7
0315:  GOTO   335
0316:  MOVLW  80
0317:  XORWF  4A,F
0318:  BTFSS  4A.7
0319:  GOTO   31E
031A:  GOTO   358
031B:  MOVF   41,W
031C:  MOVWF  45
031D:  GOTO   32B
031E:  MOVF   3D,W
031F:  MOVWF  45
0320:  MOVF   4A,F
0321:  BTFSS  03.2
0322:  GOTO   32B
0323:  MOVF   49,F
0324:  BTFSS  03.2
0325:  GOTO   32B
0326:  MOVF   48,F
0327:  BTFSS  03.2
0328:  GOTO   32B
0329:  CLRF   77
032A:  GOTO   34C
032B:  BTFSC  4A.7
032C:  GOTO   335
032D:  BCF    03.0
032E:  RLF    47,F
032F:  RLF    48,F
0330:  RLF    49,F
0331:  RLF    4A,F
0332:  DECFSZ 77,F
0333:  GOTO   32B
0334:  GOTO   353
0335:  BTFSS  45.7
0336:  GOTO   339
0337:  BSF    4A.7
0338:  GOTO   34C
0339:  BCF    4A.7
033A:  GOTO   34C
033B:  MOVF   40,W
033C:  MOVWF  77
033D:  MOVF   41,W
033E:  MOVWF  4A
033F:  MOVF   42,W
0340:  MOVWF  49
0341:  MOVF   43,W
0342:  MOVWF  48
0343:  GOTO   34C
0344:  MOVF   3C,W
0345:  MOVWF  77
0346:  MOVF   3D,W
0347:  MOVWF  4A
0348:  MOVF   3E,W
0349:  MOVWF  49
034A:  MOVF   3F,W
034B:  MOVWF  48
034C:  MOVF   4A,W
034D:  MOVWF  78
034E:  MOVF   49,W
034F:  MOVWF  79
0350:  MOVF   48,W
0351:  MOVWF  7A
0352:  GOTO   38B
0353:  CLRF   77
0354:  CLRF   78
0355:  CLRF   79
0356:  CLRF   7A
0357:  GOTO   38B
0358:  CLRF   47
0359:  COMF   48,F
035A:  COMF   49,F
035B:  COMF   4A,F
035C:  COMF   47,F
035D:  INCF   47,F
035E:  BTFSS  03.2
035F:  GOTO   366
0360:  INCF   48,F
0361:  BTFSS  03.2
0362:  GOTO   366
0363:  INCF   49,F
0364:  BTFSC  03.2
0365:  INCF   4A,F
0366:  BTFSC  46.0
0367:  GOTO   274
0368:  BTFSC  46.1
0369:  GOTO   2B6
036A:  BTFSC  46.2
036B:  GOTO   2EC
036C:  GOTO   31B
036D:  MOVF   00,W
036E:  ADDWF  48,F
036F:  BTFSS  03.0
0370:  GOTO   377
0371:  INCF   49,F
0372:  BTFSS  03.2
0373:  GOTO   377
0374:  INCF   4A,F
0375:  BTFSC  03.2
0376:  BSF    44.0
0377:  DECF   04,F
0378:  MOVF   00,W
0379:  ADDWF  49,F
037A:  BTFSS  03.0
037B:  GOTO   37F
037C:  INCF   4A,F
037D:  BTFSC  03.2
037E:  BSF    44.0
037F:  DECF   04,F
0380:  MOVF   00,W
0381:  BTFSS  00.7
0382:  XORLW  80
0383:  ADDWF  4A,F
0384:  BTFSC  03.0
0385:  BSF    44.0
0386:  BTFSC  46.4
0387:  GOTO   27B
0388:  BTFSC  46.5
0389:  GOTO   2BD
038A:  GOTO   2F3
038B:  RETURN
*
03CA:  MOVF   0B,W
03CB:  MOVWF  3D
03CC:  BCF    0B.7
03CD:  BSF    03.5
03CE:  BSF    03.6
03CF:  BSF    0C.7
03D0:  BSF    0C.0
03D1:  NOP
03D2:  NOP
03D3:  BCF    03.5
03D4:  BCF    03.6
03D5:  BTFSC  3D.7
03D6:  BSF    0B.7
03D7:  BTFSC  03.0
03D8:  GOTO   401
03D9:  BSF    03.6
03DA:  MOVF   0C,W
03DB:  ANDLW  7F
03DC:  BCF    03.6
03DD:  MOVWF  3D
03DE:  BSF    03.6
03DF:  MOVF   0D,W
03E0:  BCF    03.6
03E1:  MOVWF  3E
03E2:  BSF    03.6
03E3:  MOVF   0F,W
03E4:  BCF    03.6
03E5:  MOVWF  3F
03E6:  MOVF   3D,W
03E7:  MOVWF  49
03E8:  CALL   39E
03E9:  MOVF   3E,W
03EA:  BSF    03.6
03EB:  MOVWF  0D
03EC:  BCF    03.6
03ED:  MOVF   3F,W
03EE:  BSF    03.6
03EF:  MOVWF  0F
03F0:  BCF    03.6
03F1:  MOVF   0B,W
03F2:  MOVWF  40
03F3:  BCF    0B.7
03F4:  BSF    03.5
03F5:  BSF    03.6
03F6:  BSF    0C.7
03F7:  BSF    0C.0
03F8:  NOP
03F9:  NOP
03FA:  BCF    03.5
03FB:  BCF    03.6
03FC:  BTFSC  40.7
03FD:  BSF    0B.7
03FE:  DECFSZ 3C,F
03FF:  GOTO   401
0400:  GOTO   420
0401:  BSF    03.6
0402:  RLF    0C,W
0403:  RLF    0E,W
0404:  ANDLW  7F
0405:  BCF    03.6
0406:  MOVWF  3D
0407:  BSF    03.6
0408:  MOVF   0D,W
0409:  BCF    03.6
040A:  MOVWF  3E
040B:  BSF    03.6
040C:  MOVF   0F,W
040D:  BCF    03.6
040E:  MOVWF  3F
040F:  MOVF   3D,W
0410:  MOVWF  49
0411:  CALL   39E
0412:  MOVF   3E,W
0413:  BSF    03.6
0414:  MOVWF  0D
0415:  BCF    03.6
0416:  MOVF   3F,W
0417:  BSF    03.6
0418:  MOVWF  0F
0419:  INCF   0D,F
041A:  BTFSC  03.2
041B:  INCF   0F,F
041C:  BCF    03.0
041D:  BCF    03.6
041E:  DECFSZ 3C,F
041F:  GOTO   3CA
0420:  RETURN
0421:  BTFSC  03.1
0422:  GOTO   426
0423:  MOVLW  51
0424:  MOVWF  04
0425:  BCF    03.7
0426:  CLRF   77
0427:  CLRF   78
0428:  CLRF   79
0429:  CLRF   7A
042A:  CLRF   51
042B:  CLRF   52
042C:  CLRF   53
042D:  CLRF   54
042E:  MOVF   50,W
042F:  IORWF  4F,W
0430:  IORWF  4E,W
0431:  IORWF  4D,W
0432:  BTFSC  03.2
0433:  GOTO   464
0434:  MOVLW  20
0435:  MOVWF  55
0436:  BCF    03.0
0437:  RLF    49,F
0438:  RLF    4A,F
0439:  RLF    4B,F
043A:  RLF    4C,F
043B:  RLF    51,F
043C:  RLF    52,F
043D:  RLF    53,F
043E:  RLF    54,F
043F:  MOVF   50,W
0440:  SUBWF  54,W
0441:  BTFSS  03.2
0442:  GOTO   44D
0443:  MOVF   4F,W
0444:  SUBWF  53,W
0445:  BTFSS  03.2
0446:  GOTO   44D
0447:  MOVF   4E,W
0448:  SUBWF  52,W
0449:  BTFSS  03.2
044A:  GOTO   44D
044B:  MOVF   4D,W
044C:  SUBWF  51,W
044D:  BTFSS  03.0
044E:  GOTO   45E
044F:  MOVF   4D,W
0450:  SUBWF  51,F
0451:  MOVF   4E,W
0452:  BTFSS  03.0
0453:  INCFSZ 4E,W
0454:  SUBWF  52,F
0455:  MOVF   4F,W
0456:  BTFSS  03.0
0457:  INCFSZ 4F,W
0458:  SUBWF  53,F
0459:  MOVF   50,W
045A:  BTFSS  03.0
045B:  INCFSZ 50,W
045C:  SUBWF  54,F
045D:  BSF    03.0
045E:  RLF    77,F
045F:  RLF    78,F
0460:  RLF    79,F
0461:  RLF    7A,F
0462:  DECFSZ 55,F
0463:  GOTO   436
0464:  MOVF   51,W
0465:  MOVWF  00
0466:  INCF   04,F
0467:  MOVF   52,W
0468:  MOVWF  00
0469:  INCF   04,F
046A:  MOVF   53,W
046B:  MOVWF  00
046C:  INCF   04,F
046D:  MOVF   54,W
046E:  MOVWF  00
046F:  RETURN
0470:  MOVF   04,W
0471:  MOVWF  41
0472:  MOVF   40,W
0473:  MOVWF  43
0474:  BTFSC  03.2
0475:  GOTO   502
0476:  MOVF   3F,W
0477:  MOVWF  4C
0478:  MOVF   3E,W
0479:  MOVWF  4B
047A:  MOVF   3D,W
047B:  MOVWF  4A
047C:  MOVF   3C,W
047D:  MOVWF  49
047E:  CLRF   50
047F:  CLRF   4F
0480:  MOVLW  20
0481:  MOVWF  4E
0482:  MOVLW  82
0483:  MOVWF  4D
0484:  MOVF   49,W
0485:  BTFSC  03.2
0486:  GOTO   4F4
0487:  MOVWF  51
0488:  MOVF   4D,W
0489:  BTFSC  03.2
048A:  GOTO   4F4
048B:  ADDWF  51,F
048C:  BTFSC  03.0
048D:  GOTO   495
048E:  MOVLW  7F
048F:  SUBWF  51,F
0490:  BTFSS  03.0
0491:  GOTO   4F4
0492:  BTFSC  03.2
0493:  GOTO   4F4
0494:  GOTO   499
0495:  MOVLW  81
0496:  ADDWF  51,F
0497:  BTFSC  03.0
0498:  GOTO   4F4
0499:  MOVF   51,W
049A:  MOVWF  77
049B:  CLRF   78
049C:  CLRF   79
049D:  CLRF   7A
049E:  MOVF   4A,W
049F:  MOVWF  55
04A0:  BSF    55.7
04A1:  MOVF   4B,W
04A2:  MOVWF  54
04A3:  MOVF   4C,W
04A4:  MOVWF  53
04A5:  MOVLW  18
04A6:  MOVWF  51
04A7:  CLRF   52
04A8:  BTFSS  53.0
04A9:  GOTO   4C2
04AA:  MOVF   50,W
04AB:  ADDWF  7A,F
04AC:  BTFSS  03.0
04AD:  GOTO   4B4
04AE:  INCF   79,F
04AF:  BTFSS  03.2
04B0:  GOTO   4B4
04B1:  INCF   78,F
04B2:  BTFSC  03.2
04B3:  BSF    52.7
04B4:  MOVF   4F,W
04B5:  ADDWF  79,F
04B6:  BTFSS  03.0
04B7:  GOTO   4BB
04B8:  INCF   78,F
04B9:  BTFSC  03.2
04BA:  BSF    52.7
04BB:  MOVF   4E,W
04BC:  MOVWF  4B
04BD:  BSF    4B.7
04BE:  MOVF   4B,W
04BF:  ADDWF  78,F
04C0:  BTFSC  03.0
04C1:  BSF    52.7
04C2:  RLF    52,F
04C3:  RRF    78,F
04C4:  RRF    79,F
04C5:  RRF    7A,F
04C6:  RRF    55,F
04C7:  RRF    54,F
04C8:  RRF    53,F
04C9:  BCF    03.0
04CA:  DECFSZ 51,F
04CB:  GOTO   4A7
04CC:  MOVLW  01
04CD:  ADDWF  77,F
04CE:  BTFSC  03.0
04CF:  GOTO   4F4
04D0:  BTFSC  78.7
04D1:  GOTO   4D9
04D2:  RLF    55,F
04D3:  RLF    7A,F
04D4:  RLF    79,F
04D5:  RLF    78,F
04D6:  DECF   77,F
04D7:  BTFSC  03.2
04D8:  GOTO   4F4
04D9:  BTFSS  55.7
04DA:  GOTO   4EA
04DB:  INCF   7A,F
04DC:  BTFSS  03.2
04DD:  GOTO   4EA
04DE:  INCF   79,F
04DF:  BTFSS  03.2
04E0:  GOTO   4EA
04E1:  INCF   78,F
04E2:  BTFSS  03.2
04E3:  GOTO   4EA
04E4:  RRF    78,F
04E5:  RRF    79,F
04E6:  RRF    7A,F
04E7:  INCF   77,F
04E8:  BTFSC  03.2
04E9:  GOTO   4F4
04EA:  MOVF   4A,W
04EB:  MOVWF  52
04EC:  MOVF   4E,W
04ED:  XORWF  52,F
04EE:  BTFSS  52.7
04EF:  GOTO   4F2
04F0:  BSF    78.7
04F1:  GOTO   4F8
04F2:  BCF    78.7
04F3:  GOTO   4F8
04F4:  CLRF   77
04F5:  CLRF   78
04F6:  CLRF   79
04F7:  CLRF   7A
04F8:  MOVF   7A,W
04F9:  MOVWF  3F
04FA:  MOVF   79,W
04FB:  MOVWF  3E
04FC:  MOVF   78,W
04FD:  MOVWF  3D
04FE:  MOVF   77,W
04FF:  MOVWF  3C
0500:  DECFSZ 43,F
0501:  GOTO   476
0502:  MOVF   3F,W
0503:  MOVWF  4C
0504:  MOVF   3E,W
0505:  MOVWF  4B
0506:  MOVF   3D,W
0507:  MOVWF  4A
0508:  MOVF   3C,W
0509:  MOVWF  49
050A:  MOVF   49,W
050B:  SUBLW  B6
050C:  MOVWF  49
050D:  CLRF   7A
050E:  MOVF   4A,W
050F:  MOVWF  4D
0510:  BSF    4A.7
0511:  BCF    03.0
0512:  RRF    4A,F
0513:  RRF    4B,F
0514:  RRF    4C,F
0515:  RRF    7A,F
0516:  RRF    79,F
0517:  RRF    78,F
0518:  RRF    77,F
0519:  DECFSZ 49,F
051A:  GOTO   511
051B:  BTFSS  4D.7
051C:  GOTO   528
051D:  COMF   77,F
051E:  COMF   78,F
051F:  COMF   79,F
0520:  COMF   7A,F
0521:  INCF   77,F
0522:  BTFSC  03.2
0523:  INCF   78,F
0524:  BTFSC  03.2
0525:  INCF   79,F
0526:  BTFSC  03.2
0527:  INCF   7A,F
0528:  MOVF   7A,W
0529:  MOVWF  3F
052A:  MOVF   79,W
052B:  MOVWF  3E
052C:  MOVF   78,W
052D:  MOVWF  3D
052E:  MOVF   77,W
052F:  MOVWF  3C
0530:  BTFSS  3F.7
0531:  GOTO   53F
0532:  DECF   41,F
0533:  BSF    41.5
0534:  COMF   3C,F
0535:  COMF   3D,F
0536:  COMF   3E,F
0537:  COMF   3F,F
0538:  INCF   3C,F
0539:  BTFSC  03.2
053A:  INCF   3D,F
053B:  BTFSC  03.2
053C:  INCF   3E,F
053D:  BTFSC  03.2
053E:  INCF   3F,F
053F:  MOVLW  3B
0540:  MOVWF  48
0541:  MOVLW  9A
0542:  MOVWF  47
0543:  MOVLW  CA
0544:  MOVWF  46
0545:  CLRF   45
0546:  MOVLW  0A
0547:  MOVWF  43
0548:  MOVF   40,W
0549:  BTFSC  03.2
054A:  INCF   41,F
054B:  BSF    03.1
054C:  MOVLW  3C
054D:  MOVWF  04
054E:  BCF    03.7
054F:  MOVF   3F,W
0550:  MOVWF  4C
0551:  MOVF   3E,W
0552:  MOVWF  4B
0553:  MOVF   3D,W
0554:  MOVWF  4A
0555:  MOVF   3C,W
0556:  MOVWF  49
0557:  MOVF   48,W
0558:  MOVWF  50
0559:  MOVF   47,W
055A:  MOVWF  4F
055B:  MOVF   46,W
055C:  MOVWF  4E
055D:  MOVF   45,W
055E:  MOVWF  4D
055F:  CALL   421
0560:  MOVF   78,W
0561:  MOVF   77,F
0562:  BTFSS  03.2
0563:  GOTO   577
0564:  INCF   40,W
0565:  SUBWF  43,W
0566:  BTFSC  03.2
0567:  GOTO   577
0568:  MOVF   41,W
0569:  BTFSC  03.2
056A:  GOTO   579
056B:  ANDLW  0F
056C:  SUBWF  43,W
056D:  BTFSC  03.2
056E:  GOTO   571
056F:  BTFSC  03.0
0570:  GOTO   5A9
0571:  BTFSC  41.7
0572:  GOTO   5A9
0573:  BTFSC  41.6
0574:  GOTO   579
0575:  MOVLW  20
0576:  GOTO   5A5
0577:  MOVLW  20
0578:  ANDWF  41,F
0579:  BTFSS  41.5
057A:  GOTO   587
057B:  BCF    41.5
057C:  MOVF   40,W
057D:  BTFSS  03.2
057E:  DECF   41,F
057F:  MOVF   77,W
0580:  MOVWF  41
0581:  MOVLW  2D
0582:  MOVWF  49
0583:  CALL   39E
0584:  MOVF   41,W
0585:  MOVWF  77
0586:  CLRF   41
0587:  MOVF   40,W
0588:  SUBWF  43,W
0589:  BTFSS  03.2
058A:  GOTO   595
058B:  MOVF   77,W
058C:  MOVWF  41
058D:  MOVLW  2E
058E:  MOVWF  49
058F:  CALL   39E
0590:  MOVF   41,W
0591:  MOVWF  77
0592:  MOVLW  20
0593:  ANDWF  41,F
0594:  MOVLW  00
0595:  MOVLW  30
0596:  BTFSS  41.5
0597:  GOTO   5A5
0598:  BCF    41.5
0599:  MOVF   40,W
059A:  BTFSS  03.2
059B:  DECF   41,F
059C:  MOVF   77,W
059D:  MOVWF  41
059E:  MOVLW  2D
059F:  MOVWF  49
05A0:  CALL   39E
05A1:  MOVF   41,W
05A2:  MOVWF  77
05A3:  CLRF   41
05A4:  MOVLW  30
05A5:  ADDWF  77,F
05A6:  MOVF   77,W
05A7:  MOVWF  49
05A8:  CALL   39E
05A9:  BCF    03.1
05AA:  MOVF   48,W
05AB:  MOVWF  4C
05AC:  MOVF   47,W
05AD:  MOVWF  4B
05AE:  MOVF   46,W
05AF:  MOVWF  4A
05B0:  MOVF   45,W
05B1:  MOVWF  49
05B2:  CLRF   50
05B3:  CLRF   4F
05B4:  CLRF   4E
05B5:  MOVLW  0A
05B6:  MOVWF  4D
05B7:  CALL   421
05B8:  MOVF   7A,W
05B9:  MOVWF  48
05BA:  MOVF   79,W
05BB:  MOVWF  47
05BC:  MOVF   78,W
05BD:  MOVWF  46
05BE:  MOVF   77,W
05BF:  MOVWF  45
05C0:  DECFSZ 43,F
05C1:  GOTO   54B
05C2:  RETURN
*
0613:  CLRF   77
0614:  CLRF   78
0615:  MOVF   3E,W
0616:  BCF    03.0
0617:  BTFSC  3F.0
0618:  ADDWF  77,F
0619:  RRF    77,F
061A:  RRF    78,F
061B:  BTFSC  3F.1
061C:  ADDWF  77,F
061D:  RRF    77,F
061E:  RRF    78,F
061F:  BTFSC  3F.2
0620:  ADDWF  77,F
0621:  RRF    77,F
0622:  RRF    78,F
0623:  BTFSC  3F.3
0624:  ADDWF  77,F
0625:  RRF    77,F
0626:  RRF    78,F
0627:  BTFSC  3F.4
0628:  ADDWF  77,F
0629:  RRF    77,F
062A:  RRF    78,F
062B:  BTFSC  3F.5
062C:  ADDWF  77,F
062D:  RRF    77,F
062E:  RRF    78,F
062F:  BTFSC  3F.6
0630:  ADDWF  77,F
0631:  RRF    77,F
0632:  RRF    78,F
0633:  BTFSC  3F.7
0634:  ADDWF  77,F
0635:  RRF    77,F
0636:  RRF    78,F
*
064D:  MOVF   0B,W
064E:  MOVWF  3C
064F:  BCF    0B.7
0650:  BSF    03.5
0651:  BSF    03.6
0652:  BSF    0C.7
0653:  BSF    0C.0
0654:  NOP
0655:  NOP
0656:  BCF    03.5
0657:  BCF    03.6
0658:  BTFSC  3C.7
0659:  BSF    0B.7
065A:  BSF    03.6
065B:  MOVF   0C,W
065C:  ANDLW  7F
065D:  BTFSC  03.2
065E:  GOTO   6A1
065F:  BCF    03.6
0660:  MOVWF  3C
0661:  BSF    03.6
0662:  MOVF   0D,W
0663:  BCF    03.6
0664:  MOVWF  3D
0665:  BSF    03.6
0666:  MOVF   0F,W
0667:  BCF    03.6
0668:  MOVWF  3E
0669:  MOVF   3C,W
066A:  MOVWF  49
066B:  CALL   39E
066C:  MOVF   3D,W
066D:  BSF    03.6
066E:  MOVWF  0D
066F:  BCF    03.6
0670:  MOVF   3E,W
0671:  BSF    03.6
0672:  MOVWF  0F
0673:  BCF    03.6
0674:  MOVF   0B,W
0675:  MOVWF  3F
0676:  BCF    0B.7
0677:  BSF    03.5
0678:  BSF    03.6
0679:  BSF    0C.7
067A:  BSF    0C.0
067B:  NOP
067C:  NOP
067D:  BCF    03.5
067E:  BCF    03.6
067F:  BTFSC  3F.7
0680:  BSF    0B.7
0681:  BSF    03.6
0682:  RLF    0C,W
0683:  RLF    0E,W
0684:  ANDLW  7F
0685:  BTFSC  03.2
0686:  GOTO   6A1
0687:  BCF    03.6
0688:  MOVWF  3C
0689:  BSF    03.6
068A:  MOVF   0D,W
068B:  BCF    03.6
068C:  MOVWF  3D
068D:  BSF    03.6
068E:  MOVF   0F,W
068F:  BCF    03.6
0690:  MOVWF  3E
0691:  MOVF   3C,W
0692:  MOVWF  49
0693:  CALL   39E
0694:  MOVF   3D,W
0695:  BSF    03.6
0696:  MOVWF  0D
0697:  BCF    03.6
0698:  MOVF   3E,W
0699:  BSF    03.6
069A:  MOVWF  0F
069B:  INCF   0D,F
069C:  BTFSC  03.2
069D:  INCF   0F,F
069E:  BCF    03.6
069F:  GOTO   64D
06A0:  BSF    03.6
06A1:  BCF    03.6
06A2:  RETURN
.................... 
.................... #list
.................... 
.................... #fuses xt,nowdt,HS,NOWDT,NOPROTECT,NOLVP,BROWNOUT
.................... #device *=16
.................... #device adc=10
.................... #use delay(clock = 4M)
*
007C:  MOVLW  4A
007D:  MOVWF  04
007E:  BCF    03.7
007F:  MOVF   00,W
0080:  BTFSC  03.2
0081:  GOTO   090
0082:  MOVLW  01
0083:  MOVWF  78
0084:  CLRF   77
0085:  DECFSZ 77,F
0086:  GOTO   085
0087:  DECFSZ 78,F
0088:  GOTO   084
0089:  MOVLW  4A
008A:  MOVWF  77
008B:  DECFSZ 77,F
008C:  GOTO   08B
008D:  GOTO   08E
008E:  DECFSZ 00,F
008F:  GOTO   082
0090:  RETURN
.................... #define use_portb_kbd TRUE
.................... #define use_portd_lcd TRUE
.................... #include <lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
....................    output_float(LCD_DATA5);
....................    output_float(LCD_DATA6);
....................    output_float(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0xF;
*
00A9:  MOVLW  0F
00AA:  BSF    03.5
00AB:  ANDWF  08,W
00AC:  IORLW  F0
00AD:  MOVWF  08
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
00AE:  BCF    03.5
00AF:  BSF    08.2
....................    delay_cycles(1);
00B0:  NOP
....................    lcd_output_enable(1);
00B1:  BSF    08.0
....................    delay_cycles(1);
00B2:  NOP
....................    high = lcd_read_nibble();
00B3:  CALL   09D
00B4:  MOVF   78,W
00B5:  MOVWF  51
....................       
....................    lcd_output_enable(0);
00B6:  BCF    08.0
....................    delay_cycles(1);
00B7:  NOP
....................    lcd_output_enable(1);
00B8:  BSF    08.0
....................    delay_us(1);
00B9:  NOP
....................    low = lcd_read_nibble();
00BA:  CALL   09D
00BB:  MOVF   78,W
00BC:  MOVWF  50
....................       
....................    lcd_output_enable(0);
00BD:  BCF    08.0
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
00BE:  MOVLW  0F
00BF:  BSF    03.5
00C0:  ANDWF  08,W
00C1:  MOVWF  08
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
00C2:  BCF    03.5
00C3:  SWAPF  51,W
00C4:  MOVWF  77
00C5:  MOVLW  F0
00C6:  ANDWF  77,F
00C7:  MOVF   77,W
00C8:  IORWF  50,W
00C9:  MOVWF  78
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
....................    n |= input(LCD_DATA5) << 1;
....................    n |= input(LCD_DATA6) << 2;
....................    n |= input(LCD_DATA7) << 3;
....................    
....................    return(n);
....................   #else
....................    return(lcd.data);
*
009D:  MOVF   08,W
009E:  MOVWF  77
009F:  SWAPF  08,W
00A0:  ANDLW  0F
00A1:  MOVWF  78
....................   #endif
00A2:  RETURN
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
....................    output_bit(LCD_DATA5, bit_test(n, 1));
....................    output_bit(LCD_DATA6, bit_test(n, 2));
....................    output_bit(LCD_DATA7, bit_test(n, 3));
....................   #else      
....................    lcdlat.data = n;
*
0091:  SWAPF  51,W
0092:  ANDLW  F0
0093:  MOVWF  77
0094:  MOVLW  0F
0095:  ANDWF  08,W
0096:  IORWF  77,W
0097:  MOVWF  08
....................   #endif
....................       
....................    delay_cycles(1);
0098:  NOP
....................    lcd_output_enable(1);
0099:  BSF    08.0
....................    delay_us(2);
009A:  GOTO   09B
....................    lcd_output_enable(0);
009B:  BCF    08.0
009C:  RETURN
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
00A3:  BSF    03.5
00A4:  BCF    08.0
....................    lcd_rs_tris();
00A5:  BCF    08.1
....................    lcd_rw_tris();
00A6:  BCF    08.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
00A7:  BCF    03.5
00A8:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ;
*
00CA:  MOVF   78,W
00CB:  MOVWF  50
00CC:  BTFSC  50.7
00CD:  GOTO   0A9
....................    lcd_output_rs(address);
00CE:  BTFSS  4E.0
00CF:  BCF    08.1
00D0:  BTFSC  4E.0
00D1:  BSF    08.1
....................    delay_cycles(1);
00D2:  NOP
....................    lcd_output_rw(0);
00D3:  BCF    08.2
....................    delay_cycles(1);
00D4:  NOP
....................    lcd_output_enable(0);
00D5:  BCF    08.0
....................    lcd_send_nibble(n >> 4);
00D6:  SWAPF  4F,W
00D7:  MOVWF  50
00D8:  MOVLW  0F
00D9:  ANDWF  50,F
00DA:  MOVF   50,W
00DB:  MOVWF  51
00DC:  CALL   091
....................    lcd_send_nibble(n & 0xf);
00DD:  MOVF   4F,W
00DE:  ANDLW  0F
00DF:  MOVWF  50
00E0:  MOVWF  51
00E1:  CALL   091
00E2:  RETURN
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
00E3:  MOVLW  28
00E4:  MOVWF  3D
00E5:  MOVLW  0C
00E6:  MOVWF  3E
00E7:  MOVLW  01
00E8:  MOVWF  3F
00E9:  MOVLW  06
00EA:  MOVWF  40
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
00EB:  BCF    08.0
....................    lcd_output_rs(0);
00EC:  BCF    08.1
....................    lcd_output_rw(0);
00ED:  BCF    08.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
00EE:  MOVLW  0F
00EF:  BSF    03.5
00F0:  ANDWF  08,W
00F1:  MOVWF  08
....................   #endif
....................    lcd_enable_tris();
00F2:  BCF    08.0
....................    lcd_rs_tris();
00F3:  BCF    08.1
....................    lcd_rw_tris();
00F4:  BCF    08.2
....................  #endif
....................     
....................    delay_ms(15);
00F5:  MOVLW  0F
00F6:  BCF    03.5
00F7:  MOVWF  4A
00F8:  CALL   07C
....................    for(i=1;i<=3;++i)
00F9:  MOVLW  01
00FA:  MOVWF  3C
00FB:  MOVF   3C,W
00FC:  SUBLW  03
00FD:  BTFSS  03.0
00FE:  GOTO   107
....................    {
....................        lcd_send_nibble(3);
00FF:  MOVLW  03
0100:  MOVWF  51
0101:  CALL   091
....................        delay_ms(5);
0102:  MOVLW  05
0103:  MOVWF  4A
0104:  CALL   07C
0105:  INCF   3C,F
0106:  GOTO   0FB
....................    }
....................    
....................    lcd_send_nibble(2);
0107:  MOVLW  02
0108:  MOVWF  51
0109:  CALL   091
....................    delay_ms(5);
010A:  MOVLW  05
010B:  MOVWF  4A
010C:  CALL   07C
....................    for(i=0;i<=3;++i)
010D:  CLRF   3C
010E:  MOVF   3C,W
010F:  SUBLW  03
0110:  BTFSS  03.0
0111:  GOTO   11E
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
0112:  MOVLW  3D
0113:  ADDWF  3C,W
0114:  MOVWF  04
0115:  BCF    03.7
0116:  MOVF   00,W
0117:  MOVWF  41
0118:  CLRF   4E
0119:  MOVF   41,W
011A:  MOVWF  4F
011B:  CALL   0A3
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
011C:  INCF   3C,F
011D:  GOTO   10E
011E:  BSF    0A.3
011F:  BCF    0A.4
0120:  GOTO   04E (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
*
038C:  DECFSZ 4B,W
038D:  GOTO   38F
038E:  GOTO   392
....................       address=LCD_LINE_TWO;
038F:  MOVLW  40
0390:  MOVWF  4C
0391:  GOTO   393
....................    else
....................       address=0;
0392:  CLRF   4C
....................      
....................    address+=x-1;
0393:  MOVLW  01
0394:  SUBWF  4A,W
0395:  ADDWF  4C,F
....................    lcd_send_byte(0,0x80|address);
0396:  MOVF   4C,W
0397:  IORLW  80
0398:  MOVWF  4D
0399:  CLRF   4E
039A:  MOVF   4D,W
039B:  MOVWF  4F
039C:  CALL   0A3
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
039D:  RETURN
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
039E:  MOVF   49,W
039F:  XORLW  07
03A0:  BTFSC  03.2
03A1:  GOTO   3AC
03A2:  XORLW  0B
03A3:  BTFSC  03.2
03A4:  GOTO   3B1
03A5:  XORLW  06
03A6:  BTFSC  03.2
03A7:  GOTO   3B9
03A8:  XORLW  02
03A9:  BTFSC  03.2
03AA:  GOTO   3BF
03AB:  GOTO   3C4
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
03AC:  MOVLW  01
03AD:  MOVWF  4A
03AE:  MOVWF  4B
03AF:  CALL   38C
03B0:  GOTO   3C9
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
03B1:  CLRF   4E
03B2:  MOVLW  01
03B3:  MOVWF  4F
03B4:  CALL   0A3
....................                      delay_ms(2);
03B5:  MOVLW  02
03B6:  MOVWF  4A
03B7:  CALL   07C
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
03B8:  GOTO   3C9
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
03B9:  MOVLW  01
03BA:  MOVWF  4A
03BB:  MOVLW  02
03BC:  MOVWF  4B
03BD:  CALL   38C
03BE:  GOTO   3C9
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
03BF:  CLRF   4E
03C0:  MOVLW  10
03C1:  MOVWF  4F
03C2:  CALL   0A3
03C3:  GOTO   3C9
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
03C4:  MOVLW  01
03C5:  MOVWF  4E
03C6:  MOVF   49,W
03C7:  MOVWF  4F
03C8:  CALL   0A3
....................      #endif
....................    }
03C9:  RETURN
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <kbd.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             KBD.C                                 ////
.................... ////                  Generic keypad scan driver                       ////
.................... ////                                                                   ////
.................... ////  kbd_init()   Must be called before any other function.           ////
.................... ////                                                                   ////
.................... ////  c = kbd_getc()  Will return a key value if pressed or /0 if not  ////
.................... ////                   This function should be called frequently so as ////
.................... ////                   not to miss a key press.                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////// The following defines the keypad layout on port D
.................... 
.................... // Un-comment the following define to use port B
.................... // #define use_portb_kbd TRUE
.................... 
.................... // Make sure the port used has pull-up resistors (or the LCD) on
.................... // the column pins
.................... 
.................... #if defined use_portb_kbd
....................    #byte kbd = getenv("SFR:PORTB")
.................... #else
....................    #byte kbd = getenv("SFR:PORTD")
.................... #endif
.................... 
.................... #if defined use_portb_kbd
....................    #define set_tris_kbd(x) set_tris_b(x)
.................... #else
....................    #define set_tris_kbd(x) set_tris_d(x)
.................... #endif
.................... 
.................... //Keypad connection:   (for example column 0 is B2)
.................... //                Bx:
.................... 
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad
.................... #define COL0 (1 << 2)
.................... #define COL1 (1 << 3)
.................... #define COL2 (1 << 6)
.................... 
.................... #define ROW0 (1 << 4)
.................... #define ROW1 (1 << 7)
.................... #define ROW2 (1 << 1)
.................... #define ROW3 (1 << 5)
.................... 
.................... #else ////////////////////////////////////////////////// For the black keypad
.................... #define COL0 (1 << 5)
.................... #define COL1 (1 << 6)
.................... #define COL2 (1 << 7)
.................... 
.................... #define ROW0 (1 << 1)
.................... #define ROW1 (1 << 2)
.................... #define ROW2 (1 << 3)
.................... #define ROW3 (1 << 4)
.................... 
.................... #endif
.................... 
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3)
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2)
.................... 
.................... // Keypad layout:
.................... char const KEYS[4][3] = {{'1','2','3'},
....................                          {'4','5','6'},
....................                          {'7','8','9'},
....................                          {'*','0','#'}};
.................... 
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where
....................                                   // n is the number of times you expect
....................                                   // to call kbd_getc each second
.................... 
.................... 
.................... void kbd_init() {
*
0079:  BSF    0A.3
007A:  BCF    0A.4
007B:  GOTO   04B (RETURN)
.................... }
.................... 
.................... char kbd_getc( ) {
....................    static BYTE kbd_call_count;
*
080D:  BCF    03.5
080E:  CLRF   20
....................    static int1 kbd_down;
080F:  BCF    21.0
....................    static char last_key;
0810:  CLRF   22
....................    static BYTE col;
0811:  CLRF   23
.................... 
....................    BYTE kchar;
....................    BYTE row;
.................... 
....................    kchar='\0';
*
05C3:  CLRF   3C
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) {
05C4:  INCF   20,F
05C5:  MOVF   20,W
05C6:  SUBLW  21
05C7:  BTFSC  03.0
05C8:  GOTO   644
....................        switch (col) {
05C9:  MOVF   23,W
05CA:  BTFSC  03.2
05CB:  GOTO   5D3
05CC:  XORLW  01
05CD:  BTFSC  03.2
05CE:  GOTO   5D9
05CF:  XORLW  03
05D0:  BTFSC  03.2
05D1:  GOTO   5DF
05D2:  GOTO   5E4
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0);
05D3:  MOVLW  DE
05D4:  BSF    03.5
05D5:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS;
05D6:  BCF    03.5
05D7:  MOVWF  06
....................                     break;
05D8:  GOTO   5E4
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1);
05D9:  MOVLW  BE
05DA:  BSF    03.5
05DB:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS;
05DC:  BCF    03.5
05DD:  MOVWF  06
....................                     break;
05DE:  GOTO   5E4
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2);
05DF:  MOVLW  7E
05E0:  BSF    03.5
05E1:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS;
05E2:  BCF    03.5
05E3:  MOVWF  06
....................                     break;
....................        }
.................... 
....................        if(kbd_down) {
05E4:  BTFSS  21.0
05E5:  GOTO   5F0
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) {
05E6:  MOVF   06,W
05E7:  ANDLW  1E
05E8:  SUBLW  1E
05E9:  BTFSS  03.2
05EA:  GOTO   5EF
....................            kbd_down=FALSE;
05EB:  BCF    21.0
....................            kchar=last_key;
05EC:  MOVF   22,W
05ED:  MOVWF  3C
....................            last_key='\0';
05EE:  CLRF   22
....................          }
....................        } else {
05EF:  GOTO   643
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) {
05F0:  MOVF   06,W
05F1:  ANDLW  1E
05F2:  SUBLW  1E
05F3:  BTFSC  03.2
05F4:  GOTO   63E
....................              if((kbd & ROW0)==0)
05F5:  MOVF   06,W
05F6:  ANDLW  02
05F7:  BTFSS  03.2
05F8:  GOTO   5FB
....................                row=0;
05F9:  CLRF   3D
05FA:  GOTO   60F
....................              else if((kbd & ROW1)==0)
05FB:  MOVF   06,W
05FC:  ANDLW  04
05FD:  BTFSS  03.2
05FE:  GOTO   602
....................                row=1;
05FF:  MOVLW  01
0600:  MOVWF  3D
0601:  GOTO   60F
....................              else if((kbd & ROW2)==0)
0602:  MOVF   06,W
0603:  ANDLW  08
0604:  BTFSS  03.2
0605:  GOTO   609
....................                row=2;
0606:  MOVLW  02
0607:  MOVWF  3D
0608:  GOTO   60F
....................              else if((kbd & ROW3)==0)
0609:  MOVF   06,W
060A:  ANDLW  10
060B:  BTFSS  03.2
060C:  GOTO   60F
....................                row=3;
060D:  MOVLW  03
060E:  MOVWF  3D
....................              last_key =KEYS[row][col];
060F:  MOVF   3D,W
0610:  MOVWF  3E
0611:  MOVLW  03
0612:  MOVWF  3F
*
0637:  MOVF   23,W
0638:  ADDWF  78,W
0639:  CALL   004
063A:  MOVWF  78
063B:  MOVWF  22
....................              kbd_down = TRUE;
063C:  BSF    21.0
....................           } else {
063D:  GOTO   643
....................              ++col;
063E:  INCF   23,F
....................              if(col==3)
063F:  MOVF   23,W
0640:  SUBLW  03
0641:  BTFSC  03.2
....................                col=0;
0642:  CLRF   23
....................           }
....................        }
....................       kbd_call_count=0;
0643:  CLRF   20
....................    }
....................   set_tris_kbd(ALL_PINS);
0644:  MOVLW  FE
0645:  BSF    03.5
0646:  MOVWF  06
....................   return(kchar);
0647:  BCF    03.5
0648:  MOVF   3C,W
0649:  MOVWF  78
064A:  BSF    0A.3
064B:  BCF    0A.4
064C:  GOTO   184 (RETURN)
.................... }
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
0812:  CLRF   24
0813:  CLRF   25
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... 
.................... float temperatura;
.................... char keypad;
.................... int i;
.................... char keys_pressed[5];
.................... 
.................... void checkTemp(){
....................     if(temperatura<20)  {
*
06A3:  MOVF   29,W
06A4:  MOVWF  43
06A5:  MOVF   28,W
06A6:  MOVWF  42
06A7:  MOVF   27,W
06A8:  MOVWF  41
06A9:  MOVF   26,W
06AA:  MOVWF  40
06AB:  CLRF   47
06AC:  CLRF   46
06AD:  MOVLW  20
06AE:  MOVWF  45
06AF:  MOVLW  83
06B0:  MOVWF  44
06B1:  CALL   20C
06B2:  BTFSS  03.0
06B3:  GOTO   6E9
....................         //Abre
....................         output_low(PIN_D3);
06B4:  BSF    03.5
06B5:  BCF    08.3
06B6:  BCF    03.5
06B7:  BCF    08.3
....................         lcd_gotoxy(1,2);
06B8:  MOVLW  01
06B9:  MOVWF  4A
06BA:  MOVLW  02
06BB:  MOVWF  4B
06BC:  CALL   38C
....................         set_pwm1_duty(150);
06BD:  MOVLW  96
06BE:  MOVWF  15
....................         printf(lcd_putc,"\fpuerta abierta");
06BF:  MOVLW  14
06C0:  BSF    03.6
06C1:  MOVWF  0D
06C2:  MOVLW  00
06C3:  MOVWF  0F
06C4:  BCF    03.6
06C5:  CALL   64D
....................         delay_ms(10000);
06C6:  MOVLW  28
06C7:  MOVWF  3C
06C8:  MOVLW  FA
06C9:  MOVWF  4A
06CA:  CALL   07C
06CB:  DECFSZ 3C,F
06CC:  GOTO   6C8
....................         set_pwm1_duty(0);
06CD:  CLRF   15
....................         
....................         //Cierra
....................         lcd_gotoxy (1,2);
06CE:  MOVLW  01
06CF:  MOVWF  4A
06D0:  MOVLW  02
06D1:  MOVWF  4B
06D2:  CALL   38C
....................         set_pwm2_duty(150);
06D3:  MOVLW  96
06D4:  MOVWF  1B
....................         printf(lcd_putc,"\fpuerta cerrada");
06D5:  MOVLW  1C
06D6:  BSF    03.6
06D7:  MOVWF  0D
06D8:  MOVLW  00
06D9:  MOVWF  0F
06DA:  BCF    03.6
06DB:  CALL   64D
....................         delay_ms(10000);
06DC:  MOVLW  28
06DD:  MOVWF  3C
06DE:  MOVLW  FA
06DF:  MOVWF  4A
06E0:  CALL   07C
06E1:  DECFSZ 3C,F
06E2:  GOTO   6DE
....................         output_high(PIN_D3);
06E3:  BSF    03.5
06E4:  BCF    08.3
06E5:  BCF    03.5
06E6:  BSF    08.3
....................         set_pwm2_duty(0);
06E7:  CLRF   1B
....................     }
06E8:  GOTO   76F
....................     else if(temperatura>=20&&temperatura<=35)  {         
06E9:  CLRF   43
06EA:  CLRF   42
06EB:  MOVLW  20
06EC:  MOVWF  41
06ED:  MOVLW  83
06EE:  MOVWF  40
06EF:  MOVF   29,W
06F0:  MOVWF  47
06F1:  MOVF   28,W
06F2:  MOVWF  46
06F3:  MOVF   27,W
06F4:  MOVWF  45
06F5:  MOVF   26,W
06F6:  MOVWF  44
06F7:  CALL   20C
06F8:  BTFSC  03.0
06F9:  GOTO   6FC
06FA:  BTFSS  03.2
06FB:  GOTO   744
06FC:  MOVF   29,W
06FD:  MOVWF  43
06FE:  MOVF   28,W
06FF:  MOVWF  42
0700:  MOVF   27,W
0701:  MOVWF  41
0702:  MOVF   26,W
0703:  MOVWF  40
0704:  CLRF   47
0705:  CLRF   46
0706:  MOVLW  0C
0707:  MOVWF  45
0708:  MOVLW  84
0709:  MOVWF  44
070A:  CALL   20C
070B:  BTFSC  03.0
070C:  GOTO   70F
070D:  BTFSS  03.2
070E:  GOTO   744
....................         //Abre
....................         output_low(PIN_D3);
070F:  BSF    03.5
0710:  BCF    08.3
0711:  BCF    03.5
0712:  BCF    08.3
....................         lcd_gotoxy(1,2);
0713:  MOVLW  01
0714:  MOVWF  4A
0715:  MOVLW  02
0716:  MOVWF  4B
0717:  CALL   38C
....................         set_pwm1_duty(150);
0718:  MOVLW  96
0719:  MOVWF  15
....................         printf(lcd_putc,"\fpuerta abierta");
071A:  MOVLW  24
071B:  BSF    03.6
071C:  MOVWF  0D
071D:  MOVLW  00
071E:  MOVWF  0F
071F:  BCF    03.6
0720:  CALL   64D
....................         delay_ms(5000);
0721:  MOVLW  14
0722:  MOVWF  3C
0723:  MOVLW  FA
0724:  MOVWF  4A
0725:  CALL   07C
0726:  DECFSZ 3C,F
0727:  GOTO   723
....................         set_pwm1_duty(0);
0728:  CLRF   15
.................... 
....................         //Cierra
....................         lcd_gotoxy (1,2);
0729:  MOVLW  01
072A:  MOVWF  4A
072B:  MOVLW  02
072C:  MOVWF  4B
072D:  CALL   38C
....................         set_pwm2_duty(150);
072E:  MOVLW  96
072F:  MOVWF  1B
....................         printf(lcd_putc,"\fpuerta cerrada");
0730:  MOVLW  2C
0731:  BSF    03.6
0732:  MOVWF  0D
0733:  MOVLW  00
0734:  MOVWF  0F
0735:  BCF    03.6
0736:  CALL   64D
....................         delay_ms(5000);
0737:  MOVLW  14
0738:  MOVWF  3C
0739:  MOVLW  FA
073A:  MOVWF  4A
073B:  CALL   07C
073C:  DECFSZ 3C,F
073D:  GOTO   739
....................         set_pwm2_duty(0);
073E:  CLRF   1B
....................         output_high(PIN_D3);
073F:  BSF    03.5
0740:  BCF    08.3
0741:  BCF    03.5
0742:  BSF    08.3
....................     }
0743:  GOTO   76F
....................     else if(temperatura>35)  {
0744:  CLRF   43
0745:  CLRF   42
0746:  MOVLW  0C
0747:  MOVWF  41
0748:  MOVLW  84
0749:  MOVWF  40
074A:  MOVF   29,W
074B:  MOVWF  47
074C:  MOVF   28,W
074D:  MOVWF  46
074E:  MOVF   27,W
074F:  MOVWF  45
0750:  MOVF   26,W
0751:  MOVWF  44
0752:  CALL   20C
0753:  BTFSS  03.0
0754:  GOTO   76F
....................         printf(lcd_putc,"\fTemp alta,");
0755:  MOVLW  34
0756:  BSF    03.6
0757:  MOVWF  0D
0758:  MOVLW  00
0759:  MOVWF  0F
075A:  BCF    03.6
075B:  CALL   64D
....................         lcd_gotoxy (1,2);
075C:  MOVLW  01
075D:  MOVWF  4A
075E:  MOVLW  02
075F:  MOVWF  4B
0760:  CALL   38C
....................         printf(lcd_putc,"intentar despues.");
0761:  MOVLW  3A
0762:  BSF    03.6
0763:  MOVWF  0D
0764:  MOVLW  00
0765:  MOVWF  0F
0766:  BCF    03.6
0767:  CALL   64D
....................         delay_ms(500);
0768:  MOVLW  02
0769:  MOVWF  3C
076A:  MOVLW  FA
076B:  MOVWF  4A
076C:  CALL   07C
076D:  DECFSZ 3C,F
076E:  GOTO   76A
....................     }
....................     keys_pressed[0]='*';
076F:  MOVLW  2A
0770:  MOVWF  2C
....................     keys_pressed[1]='*';
0771:  MOVWF  2D
....................     keys_pressed[2]='*';
0772:  MOVWF  2E
....................     keys_pressed[3]='*';
0773:  MOVWF  2F
....................     keys_pressed[4]='*';
0774:  MOVWF  30
....................     
....................     lcd_gotoxy(1,1);           
0775:  MOVLW  01
0776:  MOVWF  4A
0777:  MOVWF  4B
0778:  CALL   38C
....................     printf(lcd_putc,"\fTEMP: %f ",temperatura);
0779:  MOVLW  43
077A:  BSF    03.6
077B:  MOVWF  0D
077C:  MOVLW  00
077D:  MOVWF  0F
077E:  BCF    03.0
077F:  MOVLW  07
0780:  BCF    03.6
0781:  MOVWF  3C
0782:  CALL   3CA
0783:  MOVLW  89
0784:  MOVWF  04
0785:  MOVF   29,W
0786:  MOVWF  3F
0787:  MOVF   28,W
0788:  MOVWF  3E
0789:  MOVF   27,W
078A:  MOVWF  3D
078B:  MOVF   26,W
078C:  MOVWF  3C
078D:  MOVLW  02
078E:  MOVWF  40
078F:  CALL   470
0790:  MOVLW  20
0791:  MOVWF  49
0792:  CALL   39E
....................     lcd_gotoxy(12,1);
0793:  MOVLW  0C
0794:  MOVWF  4A
0795:  MOVLW  01
0796:  MOVWF  4B
0797:  CALL   38C
....................     printf (lcd_putc,"C");
0798:  MOVLW  43
0799:  MOVWF  49
079A:  CALL   39E
079B:  RETURN
....................     
.................... }
.................... 
.................... void main() {
*
0800:  MOVF   03,W
0801:  ANDLW  1F
0802:  MOVWF  03
0803:  CLRF   32
0804:  CLRF   31
0805:  MOVLW  FF
0806:  MOVWF  33
0807:  BSF    03.5
0808:  BSF    1F.0
0809:  BSF    1F.1
080A:  BSF    1F.2
080B:  BCF    1F.3
080C:  BCF    03.7
*
0814:  CLRF   34
0815:  MOVLW  01
0816:  MOVWF  35
0817:  CLRF   36
0818:  CLRF   37
....................     int checkPassword=0;
....................     int valid=1;
....................     int maintinaing=0;
....................     int buttonState=0;
....................     keys_pressed[0]='*';
0819:  MOVLW  2A
081A:  MOVWF  2C
....................     keys_pressed[1]='*';
081B:  MOVWF  2D
....................     keys_pressed[2]='*';
081C:  MOVWF  2E
....................     keys_pressed[3]='*';
081D:  MOVWF  2F
....................     keys_pressed[4]='*';
081E:  MOVWF  30
....................     float previousTemp=0;
081F:  CLRF   3B
0820:  CLRF   3A
0821:  CLRF   39
0822:  CLRF   38
....................     
....................     
....................     
....................     setup_adc_ports(ALL_ANALOG); 
0823:  BSF    03.5
0824:  BCF    1F.0
0825:  BCF    1F.1
0826:  BCF    1F.2
0827:  BCF    1F.3
....................     setup_adc(ADC_CLOCK_INTERNAL);
0828:  BCF    03.5
0829:  BSF    1F.6
082A:  BSF    1F.7
082B:  BSF    03.5
082C:  BSF    1F.7
082D:  BCF    03.5
082E:  BSF    1F.0
....................     //set_adc_channel(0);
....................     setup_ccp1(0x0C);
082F:  BCF    33.2
0830:  MOVF   33,W
0831:  BSF    03.5
0832:  MOVWF  07
0833:  BCF    03.5
0834:  BCF    07.2
0835:  MOVLW  0C
0836:  MOVWF  17
....................     setup_ccp2(0x0C);
0837:  BCF    33.1
0838:  MOVF   33,W
0839:  BSF    03.5
083A:  MOVWF  07
083B:  BCF    03.5
083C:  BCF    07.1
083D:  MOVLW  0C
083E:  MOVWF  1D
....................     setup_timer_2(T2_DIV_BY_16,255,1);
083F:  MOVLW  00
0840:  MOVWF  78
0841:  IORLW  06
0842:  MOVWF  12
0843:  MOVLW  FF
0844:  BSF    03.5
0845:  MOVWF  12
....................     output_high(PIN_D3);
0846:  BCF    08.3
0847:  BCF    03.5
0848:  BSF    08.3
.................... 
....................     kbd_init();
0849:  BCF    0A.3
084A:  GOTO   079
084B:  BSF    0A.3
....................     lcd_init();                                  
084C:  BCF    0A.3
084D:  GOTO   0E3
084E:  BSF    0A.3
....................     port_b_pullups(TRUE);   //habilitan las resistencias pull up para evitar resistencias en el teclado
084F:  BSF    03.5
0850:  BCF    01.7
.................... 
....................     i=0;
0851:  BCF    03.5
0852:  CLRF   2B
....................     
....................     while (TRUE)   {
....................         //Muestra Temperatura
....................         temperatura=(float)read_adc()/2;
0853:  BSF    1F.2
0854:  BTFSC  1F.2
0855:  GOTO   054
0856:  MOVF   1E,W
0857:  MOVWF  79
0858:  BSF    03.5
0859:  MOVF   1E,W
085A:  MOVWF  78
085B:  MOVF   79,W
085C:  MOVWF  7A
085D:  MOVF   1E,W
085E:  BCF    03.5
085F:  MOVWF  3C
0860:  MOVF   79,W
0861:  MOVWF  3D
0862:  BCF    0A.3
0863:  GOTO   121
0864:  BSF    0A.3
0865:  MOVF   7A,W
0866:  MOVWF  3F
0867:  MOVF   79,W
0868:  MOVWF  3E
0869:  MOVF   78,W
086A:  MOVWF  3D
086B:  MOVF   77,W
086C:  MOVWF  3C
086D:  MOVF   3F,W
086E:  MOVWF  43
086F:  MOVF   3E,W
0870:  MOVWF  42
0871:  MOVF   3D,W
0872:  MOVWF  41
0873:  MOVF   3C,W
0874:  MOVWF  40
0875:  CLRF   47
0876:  CLRF   46
0877:  CLRF   45
0878:  MOVLW  80
0879:  MOVWF  44
087A:  BCF    0A.3
087B:  GOTO   140
087C:  BSF    0A.3
087D:  MOVF   7A,W
087E:  MOVWF  29
087F:  MOVF   79,W
0880:  MOVWF  28
0881:  MOVF   78,W
0882:  MOVWF  27
0883:  MOVF   77,W
0884:  MOVWF  26
....................         buttonState=input_state(PIN_C5);
0885:  CLRF   37
0886:  BTFSC  07.5
0887:  INCF   37,F
....................         if(buttonState==0){
0888:  MOVF   37,F
0889:  BTFSS  03.2
088A:  GOTO   094
....................             if(maintinaing==0){
088B:  MOVF   36,F
088C:  BTFSS  03.2
088D:  GOTO   091
....................                 maintinaing=1;
088E:  MOVLW  01
088F:  MOVWF  36
....................             }
0890:  GOTO   094
....................             else if(maintinaing==1){
0891:  DECFSZ 36,W
0892:  GOTO   094
....................                 maintinaing=0;
0893:  CLRF   36
....................             }
....................         }
....................         if(temperatura>previousTemp && temperatura-previousTemp>1){
0894:  MOVF   3B,W
0895:  MOVWF  43
0896:  MOVF   3A,W
0897:  MOVWF  42
0898:  MOVF   39,W
0899:  MOVWF  41
089A:  MOVF   38,W
089B:  MOVWF  40
089C:  MOVF   29,W
089D:  MOVWF  47
089E:  MOVF   28,W
089F:  MOVWF  46
08A0:  MOVF   27,W
08A1:  MOVWF  45
08A2:  MOVF   26,W
08A3:  MOVWF  44
08A4:  BCF    0A.3
08A5:  CALL   20C
08A6:  BSF    0A.3
08A7:  BTFSS  03.0
08A8:  GOTO   112
08A9:  BSF    03.1
08AA:  MOVF   29,W
08AB:  MOVWF  3F
08AC:  MOVF   28,W
08AD:  MOVWF  3E
08AE:  MOVF   27,W
08AF:  MOVWF  3D
08B0:  MOVF   26,W
08B1:  MOVWF  3C
08B2:  MOVF   3B,W
08B3:  MOVWF  43
08B4:  MOVF   3A,W
08B5:  MOVWF  42
08B6:  MOVF   39,W
08B7:  MOVWF  41
08B8:  MOVF   38,W
08B9:  MOVWF  40
08BA:  BCF    0A.3
08BB:  CALL   24B
08BC:  BSF    0A.3
08BD:  MOVF   7A,W
08BE:  MOVWF  3F
08BF:  MOVF   79,W
08C0:  MOVWF  3E
08C1:  MOVF   78,W
08C2:  MOVWF  3D
08C3:  MOVF   77,W
08C4:  MOVWF  3C
08C5:  CLRF   43
08C6:  CLRF   42
08C7:  CLRF   41
08C8:  MOVLW  7F
08C9:  MOVWF  40
08CA:  MOVF   3F,W
08CB:  MOVWF  47
08CC:  MOVF   3E,W
08CD:  MOVWF  46
08CE:  MOVF   3D,W
08CF:  MOVWF  45
08D0:  MOVF   3C,W
08D1:  MOVWF  44
08D2:  BCF    0A.3
08D3:  CALL   20C
08D4:  BSF    0A.3
08D5:  BTFSS  03.0
08D6:  GOTO   112
....................             lcd_gotoxy(1,1);           
08D7:  MOVLW  01
08D8:  MOVWF  4A
08D9:  MOVWF  4B
08DA:  BCF    0A.3
08DB:  CALL   38C
08DC:  BSF    0A.3
....................             printf(lcd_putc,"\fTEMP: %f ",temperatura);
08DD:  MOVLW  49
08DE:  BSF    03.6
08DF:  MOVWF  0D
08E0:  MOVLW  00
08E1:  MOVWF  0F
08E2:  BCF    03.0
08E3:  MOVLW  07
08E4:  BCF    03.6
08E5:  MOVWF  3C
08E6:  BCF    0A.3
08E7:  CALL   3CA
08E8:  BSF    0A.3
08E9:  MOVLW  89
08EA:  MOVWF  04
08EB:  MOVF   29,W
08EC:  MOVWF  3F
08ED:  MOVF   28,W
08EE:  MOVWF  3E
08EF:  MOVF   27,W
08F0:  MOVWF  3D
08F1:  MOVF   26,W
08F2:  MOVWF  3C
08F3:  MOVLW  02
08F4:  MOVWF  40
08F5:  BCF    0A.3
08F6:  CALL   470
08F7:  BSF    0A.3
08F8:  MOVLW  20
08F9:  MOVWF  49
08FA:  BCF    0A.3
08FB:  CALL   39E
08FC:  BSF    0A.3
....................             lcd_gotoxy(12,1);
08FD:  MOVLW  0C
08FE:  MOVWF  4A
08FF:  MOVLW  01
0900:  MOVWF  4B
0901:  BCF    0A.3
0902:  CALL   38C
0903:  BSF    0A.3
....................             printf (lcd_putc,"C");
0904:  MOVLW  43
0905:  MOVWF  49
0906:  BCF    0A.3
0907:  CALL   39E
0908:  BSF    0A.3
....................             previousTemp=temperatura;
0909:  MOVF   29,W
090A:  MOVWF  3B
090B:  MOVF   28,W
090C:  MOVWF  3A
090D:  MOVF   27,W
090E:  MOVWF  39
090F:  MOVF   26,W
0910:  MOVWF  38
....................         }
0911:  GOTO   17B
....................         else if( temperatura-previousTemp<-1){
0912:  BSF    03.1
0913:  MOVF   29,W
0914:  MOVWF  3F
0915:  MOVF   28,W
0916:  MOVWF  3E
0917:  MOVF   27,W
0918:  MOVWF  3D
0919:  MOVF   26,W
091A:  MOVWF  3C
091B:  MOVF   3B,W
091C:  MOVWF  43
091D:  MOVF   3A,W
091E:  MOVWF  42
091F:  MOVF   39,W
0920:  MOVWF  41
0921:  MOVF   38,W
0922:  MOVWF  40
0923:  BCF    0A.3
0924:  CALL   24B
0925:  BSF    0A.3
0926:  MOVF   7A,W
0927:  MOVWF  3F
0928:  MOVF   79,W
0929:  MOVWF  3E
092A:  MOVF   78,W
092B:  MOVWF  3D
092C:  MOVF   77,W
092D:  MOVWF  3C
092E:  MOVF   3F,W
092F:  MOVWF  43
0930:  MOVF   3E,W
0931:  MOVWF  42
0932:  MOVF   3D,W
0933:  MOVWF  41
0934:  MOVF   3C,W
0935:  MOVWF  40
0936:  CLRF   47
0937:  CLRF   46
0938:  MOVLW  80
0939:  MOVWF  45
093A:  MOVLW  7F
093B:  MOVWF  44
093C:  BCF    0A.3
093D:  CALL   20C
093E:  BSF    0A.3
093F:  BTFSS  03.0
0940:  GOTO   17B
....................             lcd_gotoxy(1,1);           
0941:  MOVLW  01
0942:  MOVWF  4A
0943:  MOVWF  4B
0944:  BCF    0A.3
0945:  CALL   38C
0946:  BSF    0A.3
....................             printf(lcd_putc,"\fTEMP: %f ",temperatura);
0947:  MOVLW  4F
0948:  BSF    03.6
0949:  MOVWF  0D
094A:  MOVLW  00
094B:  MOVWF  0F
094C:  BCF    03.0
094D:  MOVLW  07
094E:  BCF    03.6
094F:  MOVWF  3C
0950:  BCF    0A.3
0951:  CALL   3CA
0952:  BSF    0A.3
0953:  MOVLW  89
0954:  MOVWF  04
0955:  MOVF   29,W
0956:  MOVWF  3F
0957:  MOVF   28,W
0958:  MOVWF  3E
0959:  MOVF   27,W
095A:  MOVWF  3D
095B:  MOVF   26,W
095C:  MOVWF  3C
095D:  MOVLW  02
095E:  MOVWF  40
095F:  BCF    0A.3
0960:  CALL   470
0961:  BSF    0A.3
0962:  MOVLW  20
0963:  MOVWF  49
0964:  BCF    0A.3
0965:  CALL   39E
0966:  BSF    0A.3
....................             lcd_gotoxy(12,1);
0967:  MOVLW  0C
0968:  MOVWF  4A
0969:  MOVLW  01
096A:  MOVWF  4B
096B:  BCF    0A.3
096C:  CALL   38C
096D:  BSF    0A.3
....................             printf (lcd_putc,"C");
096E:  MOVLW  43
096F:  MOVWF  49
0970:  BCF    0A.3
0971:  CALL   39E
0972:  BSF    0A.3
....................             previousTemp=temperatura;
0973:  MOVF   29,W
0974:  MOVWF  3B
0975:  MOVF   28,W
0976:  MOVWF  3A
0977:  MOVF   27,W
0978:  MOVWF  39
0979:  MOVF   26,W
097A:  MOVWF  38
....................         }
.................... 
....................         if(maintinaing==0){
097B:  MOVF   36,F
097C:  BTFSS  03.2
097D:  GOTO   254
....................             output_high(PIN_D3);
097E:  BSF    03.5
097F:  BCF    08.3
0980:  BCF    03.5
0981:  BSF    08.3
....................             //lee teclado
....................             keypad=kbd_getc();           
0982:  BCF    0A.3
0983:  GOTO   5C3
0984:  BSF    0A.3
0985:  MOVF   78,W
0986:  MOVWF  2A
....................             if(keypad!=0){
0987:  MOVF   2A,F
0988:  BTFSC  03.2
0989:  GOTO   1AF
....................                 printf(lcd_putc,"\f tecla No= %c",keypad);
098A:  MOVLW  55
098B:  BSF    03.6
098C:  MOVWF  0D
098D:  MOVLW  00
098E:  MOVWF  0F
098F:  BCF    03.0
0990:  MOVLW  0C
0991:  BCF    03.6
0992:  MOVWF  3C
0993:  BCF    0A.3
0994:  CALL   3CA
0995:  BSF    0A.3
0996:  MOVF   2A,W
0997:  MOVWF  49
0998:  BCF    0A.3
0999:  CALL   39E
099A:  BSF    0A.3
....................                 if(keypad=='#'){
099B:  MOVF   2A,W
099C:  SUBLW  23
099D:  BTFSS  03.2
099E:  GOTO   1A2
....................                     checkPassword=1;
099F:  MOVLW  01
09A0:  MOVWF  34
....................                 }
09A1:  GOTO   1AF
....................                 else if(i>4){
09A2:  MOVF   2B,W
09A3:  SUBLW  04
09A4:  BTFSC  03.0
09A5:  GOTO   1A8
....................                     valid=0;
09A6:  CLRF   35
....................                 }
09A7:  GOTO   1AF
....................                 else{
....................                     keys_pressed[i]=keypad;
09A8:  MOVLW  2C
09A9:  ADDWF  2B,W
09AA:  MOVWF  04
09AB:  BCF    03.7
09AC:  MOVF   2A,W
09AD:  MOVWF  00
....................                     i++;   
09AE:  INCF   2B,F
....................                 }
....................             }
....................             //Cuando digita contrasena
....................             if(checkPassword==1){
09AF:  DECFSZ 34,W
09B0:  GOTO   253
....................                 if( keys_pressed[0]=='1' && 
....................                     keys_pressed[1]=='2' && 
....................                     keys_pressed[2]=='3' &&
....................                     keys_pressed[3]=='4' &&
....................                     keys_pressed[4]=='5' && valid==1){
09B1:  MOVF   2C,W
09B2:  SUBLW  31
09B3:  BTFSS  03.2
09B4:  GOTO   1DE
09B5:  MOVF   2D,W
09B6:  SUBLW  32
09B7:  BTFSS  03.2
09B8:  GOTO   1DE
09B9:  MOVF   2E,W
09BA:  SUBLW  33
09BB:  BTFSS  03.2
09BC:  GOTO   1DE
09BD:  MOVF   2F,W
09BE:  SUBLW  34
09BF:  BTFSS  03.2
09C0:  GOTO   1DE
09C1:  MOVF   30,W
09C2:  SUBLW  35
09C3:  BTFSS  03.2
09C4:  GOTO   1DE
09C5:  DECFSZ 35,W
09C6:  GOTO   1DE
....................                     i=0;
09C7:  CLRF   2B
....................                     printf(lcd_putc,"\fPIN Correcto");
09C8:  MOVLW  5D
09C9:  BSF    03.6
09CA:  MOVWF  0D
09CB:  MOVLW  00
09CC:  MOVWF  0F
09CD:  BCF    0A.3
09CE:  BCF    03.6
09CF:  CALL   64D
09D0:  BSF    0A.3
....................                     delay_ms(2000);
09D1:  MOVLW  08
09D2:  MOVWF  3C
09D3:  MOVLW  FA
09D4:  MOVWF  4A
09D5:  BCF    0A.3
09D6:  CALL   07C
09D7:  BSF    0A.3
09D8:  DECFSZ 3C,F
09D9:  GOTO   1D3
....................                     checkTemp();
09DA:  BCF    0A.3
09DB:  CALL   6A3
09DC:  BSF    0A.3
....................                 }
09DD:  GOTO   250
....................                 else if(keys_pressed[0]=='6' && 
....................                         keys_pressed[1]=='7' && 
....................                         keys_pressed[2]=='8' &&
....................                         keys_pressed[3]=='9' &&
....................                         keys_pressed[4]=='0' && valid==1){
09DE:  MOVF   2C,W
09DF:  SUBLW  36
09E0:  BTFSS  03.2
09E1:  GOTO   20B
09E2:  MOVF   2D,W
09E3:  SUBLW  37
09E4:  BTFSS  03.2
09E5:  GOTO   20B
09E6:  MOVF   2E,W
09E7:  SUBLW  38
09E8:  BTFSS  03.2
09E9:  GOTO   20B
09EA:  MOVF   2F,W
09EB:  SUBLW  39
09EC:  BTFSS  03.2
09ED:  GOTO   20B
09EE:  MOVF   30,W
09EF:  SUBLW  30
09F0:  BTFSS  03.2
09F1:  GOTO   20B
09F2:  DECFSZ 35,W
09F3:  GOTO   20B
....................                     i=0;
09F4:  CLRF   2B
....................                     printf(lcd_putc,"\fPIN Correcto");
09F5:  MOVLW  64
09F6:  BSF    03.6
09F7:  MOVWF  0D
09F8:  MOVLW  00
09F9:  MOVWF  0F
09FA:  BCF    0A.3
09FB:  BCF    03.6
09FC:  CALL   64D
09FD:  BSF    0A.3
....................                     delay_ms(2000);
09FE:  MOVLW  08
09FF:  MOVWF  3C
0A00:  MOVLW  FA
0A01:  MOVWF  4A
0A02:  BCF    0A.3
0A03:  CALL   07C
0A04:  BSF    0A.3
0A05:  DECFSZ 3C,F
0A06:  GOTO   200
....................                     checkTemp();
0A07:  BCF    0A.3
0A08:  CALL   6A3
0A09:  BSF    0A.3
....................                 }
0A0A:  GOTO   250
....................                 else {
....................                     printf(lcd_putc,"\fPIN Incorrecto");
0A0B:  MOVLW  6B
0A0C:  BSF    03.6
0A0D:  MOVWF  0D
0A0E:  MOVLW  00
0A0F:  MOVWF  0F
0A10:  BCF    0A.3
0A11:  BCF    03.6
0A12:  CALL   64D
0A13:  BSF    0A.3
....................                     i=0;
0A14:  CLRF   2B
....................                     delay_ms(2000);
0A15:  MOVLW  08
0A16:  MOVWF  3C
0A17:  MOVLW  FA
0A18:  MOVWF  4A
0A19:  BCF    0A.3
0A1A:  CALL   07C
0A1B:  BSF    0A.3
0A1C:  DECFSZ 3C,F
0A1D:  GOTO   217
....................                     lcd_gotoxy(1,1);           
0A1E:  MOVLW  01
0A1F:  MOVWF  4A
0A20:  MOVWF  4B
0A21:  BCF    0A.3
0A22:  CALL   38C
0A23:  BSF    0A.3
....................                     printf(lcd_putc,"\fTEMP: %f ",temperatura);
0A24:  MOVLW  73
0A25:  BSF    03.6
0A26:  MOVWF  0D
0A27:  MOVLW  00
0A28:  MOVWF  0F
0A29:  BCF    03.0
0A2A:  MOVLW  07
0A2B:  BCF    03.6
0A2C:  MOVWF  3C
0A2D:  BCF    0A.3
0A2E:  CALL   3CA
0A2F:  BSF    0A.3
0A30:  MOVLW  89
0A31:  MOVWF  04
0A32:  MOVF   29,W
0A33:  MOVWF  3F
0A34:  MOVF   28,W
0A35:  MOVWF  3E
0A36:  MOVF   27,W
0A37:  MOVWF  3D
0A38:  MOVF   26,W
0A39:  MOVWF  3C
0A3A:  MOVLW  02
0A3B:  MOVWF  40
0A3C:  BCF    0A.3
0A3D:  CALL   470
0A3E:  BSF    0A.3
0A3F:  MOVLW  20
0A40:  MOVWF  49
0A41:  BCF    0A.3
0A42:  CALL   39E
0A43:  BSF    0A.3
....................                     lcd_gotoxy(12,1);
0A44:  MOVLW  0C
0A45:  MOVWF  4A
0A46:  MOVLW  01
0A47:  MOVWF  4B
0A48:  BCF    0A.3
0A49:  CALL   38C
0A4A:  BSF    0A.3
....................                     printf (lcd_putc,"C");
0A4B:  MOVLW  43
0A4C:  MOVWF  49
0A4D:  BCF    0A.3
0A4E:  CALL   39E
0A4F:  BSF    0A.3
....................                 }
....................                 checkPassword=0;
0A50:  CLRF   34
....................                 valid=1;
0A51:  MOVLW  01
0A52:  MOVWF  35
....................             }
....................         }
0A53:  GOTO   25A
....................         else if(maintinaing==1){
0A54:  DECFSZ 36,W
0A55:  GOTO   25A
....................             output_low(PIN_D3);
0A56:  BSF    03.5
0A57:  BCF    08.3
0A58:  BCF    03.5
0A59:  BCF    08.3
....................         }
0A5A:  GOTO   053
....................         
....................     }
.................... }
0A5B:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
