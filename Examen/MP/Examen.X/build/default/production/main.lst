CCS PCM C Compiler, Version 5.088d, 1               11-Nov-19 17:49
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\pablo\Documents\1-TEC\Arqui1\Examen\MP\Examen.X\build\default\production\main.lst

               ROM used:   3182 words (39%)
                           Largest free fragment is 2048
               RAM used:   37 (10%) at main() level
                           60 (16%) worst case
               Stack used: 6 locations
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   255
0003:  NOP
.................... #include <16f877.h>
.................... //////////// Standard Header file for the PIC16F877 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  34
000C:  RETLW  35
000D:  RETLW  36
000E:  RETLW  37
000F:  RETLW  38
0010:  RETLW  39
0011:  RETLW  2A
0012:  RETLW  30
0013:  RETLW  23
0014:  DATA 0C,28
0015:  DATA F5,32
0016:  DATA 72,3A
0017:  DATA 61,10
0018:  DATA 61,31
0019:  DATA E9,32
001A:  DATA 72,3A
001B:  DATA 61,00
001C:  DATA 0C,28
001D:  DATA F5,32
001E:  DATA 72,3A
001F:  DATA 61,10
0020:  DATA E3,32
0021:  DATA 72,39
0022:  DATA 61,32
0023:  DATA 61,00
0024:  DATA 0C,28
0025:  DATA F5,32
0026:  DATA 72,3A
0027:  DATA 61,10
0028:  DATA 61,31
0029:  DATA E9,32
002A:  DATA 72,3A
002B:  DATA 61,00
002C:  DATA 0C,28
002D:  DATA F5,32
002E:  DATA 72,3A
002F:  DATA 61,10
0030:  DATA E3,32
0031:  DATA 72,39
0032:  DATA 61,32
0033:  DATA 61,00
0034:  DATA 0C,2A
0035:  DATA E5,36
0036:  DATA 70,10
0037:  DATA 61,36
0038:  DATA F4,30
0039:  DATA 2C,00
003A:  DATA 69,37
003B:  DATA F4,32
003C:  DATA 6E,3A
003D:  DATA 61,39
003E:  DATA 20,32
003F:  DATA E5,39
0040:  DATA F0,3A
0041:  DATA E5,39
0042:  DATA 2E,00
0043:  DATA 0C,2A
0044:  DATA C5,26
0045:  DATA 50,1D
0046:  DATA A0,12
0047:  DATA 66,10
0048:  DATA 00,00
0049:  DATA C3,37
004A:  DATA E4,32
004B:  DATA BA,18
004C:  DATA B2,19
004D:  DATA B4,1A
004E:  DATA 2D,2A
004F:  DATA E5,36
0050:  DATA 70,1D
0051:  DATA 25,33
0052:  DATA 43,10
0053:  DATA 0A,00
0054:  DATA C3,37
0055:  DATA E4,32
0056:  DATA 3A,1B
0057:  DATA 37,1C
0058:  DATA 39,18
0059:  DATA 2D,2A
005A:  DATA E5,36
005B:  DATA 70,1D
005C:  DATA 25,33
005D:  DATA 43,10
005E:  DATA 0A,00
005F:  DATA 45,3C
0060:  DATA E1,36
0061:  DATA 65,37
0062:  DATA 20,28
0063:  DATA 61,31
0064:  DATA EC,37
0065:  DATA A0,23
0066:  DATA 61,39
0067:  DATA E3,34
0068:  DATA 61,10
0069:  DATA 42,39
006A:  DATA 65,37
006B:  DATA E5,39
006C:  DATA A0,3C
006D:  DATA A0,26
006E:  DATA 61,39
006F:  DATA E3,37
0070:  DATA 20,23
0071:  DATA 65,39
0072:  DATA EE,30
0073:  DATA 6E,32
0074:  DATA 65,3D
0075:  DATA A0,23
0076:  DATA F2,30
0077:  DATA EE,30
0078:  DATA E4,37
0079:  DATA 73,17
007A:  DATA 0A,00
007B:  DATA 0C,2A
007C:  DATA C5,26
007D:  DATA 50,1D
007E:  DATA A0,12
007F:  DATA 66,10
0080:  DATA 00,01
0081:  DATA 0C,2A
0082:  DATA C5,26
0083:  DATA 50,1D
0084:  DATA A0,12
0085:  DATA 66,10
0086:  DATA 00,01
0087:  DATA 0C,10
0088:  DATA D4,32
0089:  DATA 63,36
008A:  DATA 61,1D
008B:  DATA A0,12
008C:  DATA 63,00
008D:  DATA 0C,28
008E:  DATA 49,27
008F:  DATA A0,21
0090:  DATA 6F,39
0091:  DATA F2,32
0092:  DATA 63,3A
0093:  DATA 6F,00
0094:  DATA 0C,28
0095:  DATA 49,27
0096:  DATA A0,21
0097:  DATA 6F,39
0098:  DATA F2,32
0099:  DATA 63,3A
009A:  DATA 6F,00
009B:  DATA 0C,28
009C:  DATA 49,27
009D:  DATA A0,24
009E:  DATA EE,31
009F:  DATA 6F,39
00A0:  DATA F2,32
00A1:  DATA 63,3A
00A2:  DATA 6F,00
00A3:  DATA 0C,2A
00A4:  DATA C5,26
00A5:  DATA 50,1D
00A6:  DATA A0,12
00A7:  DATA 66,10
00A8:  DATA 00,01
*
0151:  MOVF   0B,W
0152:  MOVWF  3C
0153:  BCF    0B.7
0154:  BSF    03.5
0155:  BSF    03.6
0156:  BSF    0C.7
0157:  BSF    0C.0
0158:  NOP
0159:  NOP
015A:  BCF    03.5
015B:  BCF    03.6
015C:  BTFSC  3C.7
015D:  BSF    0B.7
015E:  BSF    03.6
015F:  MOVF   0C,W
0160:  ANDLW  7F
0161:  BTFSC  03.2
0162:  GOTO   1A7
0163:  BCF    03.6
0164:  MOVWF  3C
0165:  BSF    03.6
0166:  MOVF   0D,W
0167:  BCF    03.6
0168:  MOVWF  3D
0169:  BSF    03.6
016A:  MOVF   0F,W
016B:  BCF    03.6
016C:  MOVWF  3E
016D:  MOVF   3C,W
016E:  BTFSS  0C.4
016F:  GOTO   16E
0170:  MOVWF  19
0171:  MOVF   3D,W
0172:  BSF    03.6
0173:  MOVWF  0D
0174:  BCF    03.6
0175:  MOVF   3E,W
0176:  BSF    03.6
0177:  MOVWF  0F
0178:  BCF    03.6
0179:  MOVF   0B,W
017A:  MOVWF  3F
017B:  BCF    0B.7
017C:  BSF    03.5
017D:  BSF    03.6
017E:  BSF    0C.7
017F:  BSF    0C.0
0180:  NOP
0181:  NOP
0182:  BCF    03.5
0183:  BCF    03.6
0184:  BTFSC  3F.7
0185:  BSF    0B.7
0186:  BSF    03.6
0187:  RLF    0C,W
0188:  RLF    0E,W
0189:  ANDLW  7F
018A:  BTFSC  03.2
018B:  GOTO   1A7
018C:  BCF    03.6
018D:  MOVWF  3C
018E:  BSF    03.6
018F:  MOVF   0D,W
0190:  BCF    03.6
0191:  MOVWF  3D
0192:  BSF    03.6
0193:  MOVF   0F,W
0194:  BCF    03.6
0195:  MOVWF  3E
0196:  MOVF   3C,W
0197:  BTFSS  0C.4
0198:  GOTO   197
0199:  MOVWF  19
019A:  MOVF   3D,W
019B:  BSF    03.6
019C:  MOVWF  0D
019D:  BCF    03.6
019E:  MOVF   3E,W
019F:  BSF    03.6
01A0:  MOVWF  0F
01A1:  INCF   0D,F
01A2:  BTFSC  03.2
01A3:  INCF   0F,F
01A4:  BCF    03.6
01A5:  GOTO   151
01A6:  BSF    03.6
01A7:  BCF    03.6
01A8:  BSF    0A.3
01A9:  BCF    0A.4
01AA:  GOTO   2C1 (RETURN)
01AB:  MOVLW  8E
01AC:  MOVWF  77
01AD:  MOVF   3D,W
01AE:  MOVWF  78
01AF:  MOVF   3C,W
01B0:  MOVWF  79
01B1:  CLRF   7A
01B2:  MOVF   78,F
01B3:  BTFSS  03.2
01B4:  GOTO   1BF
01B5:  MOVF   79,W
01B6:  MOVWF  78
01B7:  CLRF   79
01B8:  MOVLW  08
01B9:  SUBWF  77,F
01BA:  MOVF   78,F
01BB:  BTFSS  03.2
01BC:  GOTO   1BF
01BD:  CLRF   77
01BE:  GOTO   1C7
01BF:  BCF    03.0
01C0:  BTFSC  78.7
01C1:  GOTO   1C6
01C2:  RLF    79,F
01C3:  RLF    78,F
01C4:  DECF   77,F
01C5:  GOTO   1BF
01C6:  BCF    78.7
01C7:  BSF    0A.3
01C8:  BCF    0A.4
01C9:  GOTO   2D3 (RETURN)
01CA:  MOVF   40,W
01CB:  BTFSC  03.2
01CC:  GOTO   28F
01CD:  MOVWF  4C
01CE:  MOVF   44,W
01CF:  BTFSC  03.2
01D0:  GOTO   28F
01D1:  SUBWF  4C,F
01D2:  BTFSS  03.0
01D3:  GOTO   1D9
01D4:  MOVLW  7F
01D5:  ADDWF  4C,F
01D6:  BTFSC  03.0
01D7:  GOTO   28F
01D8:  GOTO   1DF
01D9:  MOVLW  81
01DA:  SUBWF  4C,F
01DB:  BTFSS  03.0
01DC:  GOTO   28F
01DD:  BTFSC  03.2
01DE:  GOTO   28F
01DF:  MOVF   4C,W
01E0:  MOVWF  77
01E1:  CLRF   78
01E2:  CLRF   79
01E3:  CLRF   7A
01E4:  CLRF   4B
01E5:  MOVF   41,W
01E6:  MOVWF  4A
01E7:  BSF    4A.7
01E8:  MOVF   42,W
01E9:  MOVWF  49
01EA:  MOVF   43,W
01EB:  MOVWF  48
01EC:  MOVLW  19
01ED:  MOVWF  4C
01EE:  MOVF   47,W
01EF:  SUBWF  48,F
01F0:  BTFSC  03.0
01F1:  GOTO   202
01F2:  MOVLW  01
01F3:  SUBWF  49,F
01F4:  BTFSC  03.0
01F5:  GOTO   202
01F6:  SUBWF  4A,F
01F7:  BTFSC  03.0
01F8:  GOTO   202
01F9:  SUBWF  4B,F
01FA:  BTFSC  03.0
01FB:  GOTO   202
01FC:  INCF   4B,F
01FD:  INCF   4A,F
01FE:  INCF   49,F
01FF:  MOVF   47,W
0200:  ADDWF  48,F
0201:  GOTO   234
0202:  MOVF   46,W
0203:  SUBWF  49,F
0204:  BTFSC  03.0
0205:  GOTO   21D
0206:  MOVLW  01
0207:  SUBWF  4A,F
0208:  BTFSC  03.0
0209:  GOTO   21D
020A:  SUBWF  4B,F
020B:  BTFSC  03.0
020C:  GOTO   21D
020D:  INCF   4B,F
020E:  INCF   4A,F
020F:  MOVF   46,W
0210:  ADDWF  49,F
0211:  MOVF   47,W
0212:  ADDWF  48,F
0213:  BTFSS  03.0
0214:  GOTO   234
0215:  INCF   49,F
0216:  BTFSS  03.2
0217:  GOTO   234
0218:  INCF   4A,F
0219:  BTFSS  03.2
021A:  GOTO   234
021B:  INCF   4B,F
021C:  GOTO   234
021D:  MOVF   45,W
021E:  IORLW  80
021F:  SUBWF  4A,F
0220:  BTFSC  03.0
0221:  GOTO   233
0222:  MOVLW  01
0223:  SUBWF  4B,F
0224:  BTFSC  03.0
0225:  GOTO   233
0226:  INCF   4B,F
0227:  MOVF   45,W
0228:  IORLW  80
0229:  ADDWF  4A,F
022A:  MOVF   46,W
022B:  ADDWF  49,F
022C:  BTFSS  03.0
022D:  GOTO   211
022E:  INCF   4A,F
022F:  BTFSS  03.2
0230:  GOTO   211
0231:  INCF   4B,F
0232:  GOTO   211
0233:  BSF    7A.0
0234:  DECFSZ 4C,F
0235:  GOTO   237
0236:  GOTO   242
0237:  BCF    03.0
0238:  RLF    48,F
0239:  RLF    49,F
023A:  RLF    4A,F
023B:  RLF    4B,F
023C:  BCF    03.0
023D:  RLF    7A,F
023E:  RLF    79,F
023F:  RLF    78,F
0240:  RLF    4D,F
0241:  GOTO   1EE
0242:  BTFSS  4D.0
0243:  GOTO   24A
0244:  BCF    03.0
0245:  RRF    78,F
0246:  RRF    79,F
0247:  RRF    7A,F
0248:  RRF    4D,F
0249:  GOTO   24D
024A:  DECF   77,F
024B:  BTFSC  03.2
024C:  GOTO   28F
024D:  BTFSC  4D.7
024E:  GOTO   276
024F:  BCF    03.0
0250:  RLF    48,F
0251:  RLF    49,F
0252:  RLF    4A,F
0253:  RLF    4B,F
0254:  MOVF   47,W
0255:  SUBWF  48,F
0256:  BTFSC  03.0
0257:  GOTO   262
0258:  MOVLW  01
0259:  SUBWF  49,F
025A:  BTFSC  03.0
025B:  GOTO   262
025C:  SUBWF  4A,F
025D:  BTFSC  03.0
025E:  GOTO   262
025F:  SUBWF  4B,F
0260:  BTFSS  03.0
0261:  GOTO   285
0262:  MOVF   46,W
0263:  SUBWF  49,F
0264:  BTFSC  03.0
0265:  GOTO   26D
0266:  MOVLW  01
0267:  SUBWF  4A,F
0268:  BTFSC  03.0
0269:  GOTO   26D
026A:  SUBWF  4B,F
026B:  BTFSS  03.0
026C:  GOTO   285
026D:  MOVF   45,W
026E:  IORLW  80
026F:  SUBWF  4A,F
0270:  BTFSC  03.0
0271:  GOTO   276
0272:  MOVLW  01
0273:  SUBWF  4B,F
0274:  BTFSS  03.0
0275:  GOTO   285
0276:  INCF   7A,F
0277:  BTFSS  03.2
0278:  GOTO   285
0279:  INCF   79,F
027A:  BTFSS  03.2
027B:  GOTO   285
027C:  INCF   78,F
027D:  BTFSS  03.2
027E:  GOTO   285
027F:  INCF   77,F
0280:  BTFSC  03.2
0281:  GOTO   28F
0282:  RRF    78,F
0283:  RRF    79,F
0284:  RRF    7A,F
0285:  MOVF   41,W
0286:  MOVWF  4C
0287:  MOVF   45,W
0288:  XORWF  4C,F
0289:  BTFSS  4C.7
028A:  GOTO   28D
028B:  BSF    78.7
028C:  GOTO   293
028D:  BCF    78.7
028E:  GOTO   293
028F:  CLRF   77
0290:  CLRF   78
0291:  CLRF   79
0292:  CLRF   7A
0293:  BSF    0A.3
0294:  BCF    0A.4
0295:  GOTO   2EB (RETURN)
0296:  MOVLW  80
0297:  BTFSC  03.1
0298:  XORWF  41,F
0299:  CLRF   46
029A:  CLRF   47
029B:  MOVF   3D,W
029C:  MOVWF  45
029D:  MOVF   41,W
029E:  XORWF  45,F
029F:  MOVF   3C,W
02A0:  BTFSC  03.2
02A1:  GOTO   386
02A2:  MOVWF  44
02A3:  MOVWF  77
02A4:  MOVF   40,W
02A5:  BTFSC  03.2
02A6:  GOTO   38F
02A7:  SUBWF  44,F
02A8:  BTFSC  03.2
02A9:  GOTO   32B
02AA:  BTFSS  03.0
02AB:  GOTO   2E9
02AC:  MOVF   41,W
02AD:  MOVWF  4A
02AE:  BSF    4A.7
02AF:  MOVF   42,W
02B0:  MOVWF  49
02B1:  MOVF   43,W
02B2:  MOVWF  48
02B3:  CLRF   47
02B4:  BCF    03.0
02B5:  RRF    4A,F
02B6:  RRF    49,F
02B7:  RRF    48,F
02B8:  RRF    47,F
02B9:  DECFSZ 44,F
02BA:  GOTO   2B3
02BB:  BTFSS  45.7
02BC:  GOTO   2C0
02BD:  BSF    46.0
02BE:  GOTO   3A3
02BF:  BCF    46.0
02C0:  BCF    44.0
02C1:  BSF    46.4
02C2:  MOVLW  3F
02C3:  MOVWF  04
02C4:  BCF    03.7
02C5:  GOTO   3B8
02C6:  BCF    46.4
02C7:  BTFSC  45.7
02C8:  GOTO   2D3
02C9:  BTFSS  44.0
02CA:  GOTO   2DE
02CB:  RRF    4A,F
02CC:  RRF    49,F
02CD:  RRF    48,F
02CE:  RRF    47,F
02CF:  INCF   77,F
02D0:  BTFSC  03.2
02D1:  GOTO   39E
02D2:  GOTO   2DE
02D3:  BTFSC  4A.7
02D4:  GOTO   2E1
02D5:  BCF    03.0
02D6:  RLF    47,F
02D7:  RLF    48,F
02D8:  RLF    49,F
02D9:  RLF    4A,F
02DA:  DECF   77,F
02DB:  BTFSC  03.2
02DC:  GOTO   39E
02DD:  GOTO   2D3
02DE:  BSF    46.6
02DF:  GOTO   34B
02E0:  BCF    46.6
02E1:  MOVF   3D,W
02E2:  MOVWF  45
02E3:  BTFSS  45.7
02E4:  GOTO   2E7
02E5:  BSF    4A.7
02E6:  GOTO   397
02E7:  BCF    4A.7
02E8:  GOTO   397
02E9:  MOVF   40,W
02EA:  MOVWF  44
02EB:  MOVWF  77
02EC:  MOVF   3C,W
02ED:  SUBWF  44,F
02EE:  MOVF   3D,W
02EF:  MOVWF  4A
02F0:  BSF    4A.7
02F1:  MOVF   3E,W
02F2:  MOVWF  49
02F3:  MOVF   3F,W
02F4:  MOVWF  48
02F5:  CLRF   47
02F6:  BCF    03.0
02F7:  RRF    4A,F
02F8:  RRF    49,F
02F9:  RRF    48,F
02FA:  RRF    47,F
02FB:  DECFSZ 44,F
02FC:  GOTO   2F5
02FD:  BTFSS  45.7
02FE:  GOTO   302
02FF:  BSF    46.1
0300:  GOTO   3A3
0301:  BCF    46.1
0302:  BCF    44.0
0303:  BSF    46.5
0304:  MOVLW  43
0305:  MOVWF  04
0306:  BCF    03.7
0307:  GOTO   3B8
0308:  BCF    46.5
0309:  BTFSC  45.7
030A:  GOTO   315
030B:  BTFSS  44.0
030C:  GOTO   320
030D:  RRF    4A,F
030E:  RRF    49,F
030F:  RRF    48,F
0310:  RRF    47,F
0311:  INCF   77,F
0312:  BTFSC  03.2
0313:  GOTO   39E
0314:  GOTO   320
0315:  BTFSC  4A.7
0316:  GOTO   323
0317:  BCF    03.0
0318:  RLF    47,F
0319:  RLF    48,F
031A:  RLF    49,F
031B:  RLF    4A,F
031C:  DECF   77,F
031D:  BTFSC  03.2
031E:  GOTO   39E
031F:  GOTO   315
0320:  BSF    46.7
0321:  GOTO   34B
0322:  BCF    46.7
0323:  MOVF   41,W
0324:  MOVWF  45
0325:  BTFSS  45.7
0326:  GOTO   329
0327:  BSF    4A.7
0328:  GOTO   397
0329:  BCF    4A.7
032A:  GOTO   397
032B:  MOVF   41,W
032C:  MOVWF  4A
032D:  BSF    4A.7
032E:  MOVF   42,W
032F:  MOVWF  49
0330:  MOVF   43,W
0331:  MOVWF  48
0332:  BTFSS  45.7
0333:  GOTO   338
0334:  BCF    4A.7
0335:  BSF    46.2
0336:  GOTO   3A3
0337:  BCF    46.2
0338:  CLRF   47
0339:  BCF    44.0
033A:  MOVLW  3F
033B:  MOVWF  04
033C:  BCF    03.7
033D:  GOTO   3B8
033E:  BTFSC  45.7
033F:  GOTO   361
0340:  MOVF   3D,W
0341:  MOVWF  45
0342:  BTFSS  44.0
0343:  GOTO   34B
0344:  RRF    4A,F
0345:  RRF    49,F
0346:  RRF    48,F
0347:  RRF    47,F
0348:  INCF   77,F
0349:  BTFSC  03.2
034A:  GOTO   39E
034B:  BTFSS  47.7
034C:  GOTO   35C
034D:  INCF   48,F
034E:  BTFSS  03.2
034F:  GOTO   35C
0350:  INCF   49,F
0351:  BTFSS  03.2
0352:  GOTO   35C
0353:  INCF   4A,F
0354:  BTFSS  03.2
0355:  GOTO   35C
0356:  RRF    4A,F
0357:  RRF    49,F
0358:  RRF    48,F
0359:  INCF   77,F
035A:  BTFSC  03.2
035B:  GOTO   39E
035C:  BTFSC  46.6
035D:  GOTO   2E0
035E:  BTFSC  46.7
035F:  GOTO   322
0360:  GOTO   380
0361:  MOVLW  80
0362:  XORWF  4A,F
0363:  BTFSS  4A.7
0364:  GOTO   369
0365:  GOTO   3A3
0366:  MOVF   41,W
0367:  MOVWF  45
0368:  GOTO   376
0369:  MOVF   3D,W
036A:  MOVWF  45
036B:  MOVF   4A,F
036C:  BTFSS  03.2
036D:  GOTO   376
036E:  MOVF   49,F
036F:  BTFSS  03.2
0370:  GOTO   376
0371:  MOVF   48,F
0372:  BTFSS  03.2
0373:  GOTO   376
0374:  CLRF   77
0375:  GOTO   397
0376:  BTFSC  4A.7
0377:  GOTO   380
0378:  BCF    03.0
0379:  RLF    47,F
037A:  RLF    48,F
037B:  RLF    49,F
037C:  RLF    4A,F
037D:  DECFSZ 77,F
037E:  GOTO   376
037F:  GOTO   39E
0380:  BTFSS  45.7
0381:  GOTO   384
0382:  BSF    4A.7
0383:  GOTO   397
0384:  BCF    4A.7
0385:  GOTO   397
0386:  MOVF   40,W
0387:  MOVWF  77
0388:  MOVF   41,W
0389:  MOVWF  4A
038A:  MOVF   42,W
038B:  MOVWF  49
038C:  MOVF   43,W
038D:  MOVWF  48
038E:  GOTO   397
038F:  MOVF   3C,W
0390:  MOVWF  77
0391:  MOVF   3D,W
0392:  MOVWF  4A
0393:  MOVF   3E,W
0394:  MOVWF  49
0395:  MOVF   3F,W
0396:  MOVWF  48
0397:  MOVF   4A,W
0398:  MOVWF  78
0399:  MOVF   49,W
039A:  MOVWF  79
039B:  MOVF   48,W
039C:  MOVWF  7A
039D:  GOTO   3D6
039E:  CLRF   77
039F:  CLRF   78
03A0:  CLRF   79
03A1:  CLRF   7A
03A2:  GOTO   3D6
03A3:  CLRF   47
03A4:  COMF   48,F
03A5:  COMF   49,F
03A6:  COMF   4A,F
03A7:  COMF   47,F
03A8:  INCF   47,F
03A9:  BTFSS  03.2
03AA:  GOTO   3B1
03AB:  INCF   48,F
03AC:  BTFSS  03.2
03AD:  GOTO   3B1
03AE:  INCF   49,F
03AF:  BTFSC  03.2
03B0:  INCF   4A,F
03B1:  BTFSC  46.0
03B2:  GOTO   2BF
03B3:  BTFSC  46.1
03B4:  GOTO   301
03B5:  BTFSC  46.2
03B6:  GOTO   337
03B7:  GOTO   366
03B8:  MOVF   00,W
03B9:  ADDWF  48,F
03BA:  BTFSS  03.0
03BB:  GOTO   3C2
03BC:  INCF   49,F
03BD:  BTFSS  03.2
03BE:  GOTO   3C2
03BF:  INCF   4A,F
03C0:  BTFSC  03.2
03C1:  BSF    44.0
03C2:  DECF   04,F
03C3:  MOVF   00,W
03C4:  ADDWF  49,F
03C5:  BTFSS  03.0
03C6:  GOTO   3CA
03C7:  INCF   4A,F
03C8:  BTFSC  03.2
03C9:  BSF    44.0
03CA:  DECF   04,F
03CB:  MOVF   00,W
03CC:  BTFSS  00.7
03CD:  XORLW  80
03CE:  ADDWF  4A,F
03CF:  BTFSC  03.0
03D0:  BSF    44.0
03D1:  BTFSC  46.4
03D2:  GOTO   2C6
03D3:  BTFSC  46.5
03D4:  GOTO   308
03D5:  GOTO   33E
03D6:  RETURN
03D7:  MOVF   41,W
03D8:  MOVWF  48
03D9:  MOVF   45,W
03DA:  XORWF  48,F
03DB:  BTFSS  48.7
03DC:  GOTO   3E2
03DD:  BCF    03.2
03DE:  BCF    03.0
03DF:  BTFSC  41.7
03E0:  BSF    03.0
03E1:  GOTO   415
03E2:  MOVF   41,W
03E3:  MOVWF  48
03E4:  MOVF   44,W
03E5:  MOVWF  49
03E6:  MOVF   40,W
03E7:  SUBWF  49,F
03E8:  BTFSC  03.2
03E9:  GOTO   3F0
03EA:  BTFSS  48.7
03EB:  GOTO   415
03EC:  MOVF   03,W
03ED:  XORLW  01
03EE:  MOVWF  03
03EF:  GOTO   415
03F0:  MOVF   45,W
03F1:  MOVWF  49
03F2:  MOVF   41,W
03F3:  SUBWF  49,F
03F4:  BTFSC  03.2
03F5:  GOTO   3FC
03F6:  BTFSS  48.7
03F7:  GOTO   415
03F8:  MOVF   03,W
03F9:  XORLW  01
03FA:  MOVWF  03
03FB:  GOTO   415
03FC:  MOVF   46,W
03FD:  MOVWF  49
03FE:  MOVF   42,W
03FF:  SUBWF  49,F
0400:  BTFSC  03.2
0401:  GOTO   408
0402:  BTFSS  48.7
0403:  GOTO   415
0404:  MOVF   03,W
0405:  XORLW  01
0406:  MOVWF  03
0407:  GOTO   415
0408:  MOVF   47,W
0409:  MOVWF  49
040A:  MOVF   43,W
040B:  SUBWF  49,F
040C:  BTFSC  03.2
040D:  GOTO   414
040E:  BTFSS  48.7
040F:  GOTO   415
0410:  MOVF   03,W
0411:  XORLW  01
0412:  MOVWF  03
0413:  GOTO   415
0414:  BCF    03.0
0415:  RETURN
*
0454:  MOVF   0B,W
0455:  MOVWF  3E
0456:  BCF    0B.7
0457:  BSF    03.5
0458:  BSF    03.6
0459:  BSF    0C.7
045A:  BSF    0C.0
045B:  NOP
045C:  NOP
045D:  BCF    03.5
045E:  BCF    03.6
045F:  BTFSC  3E.7
0460:  BSF    0B.7
0461:  BTFSC  03.0
0462:  GOTO   48B
0463:  BSF    03.6
0464:  MOVF   0C,W
0465:  ANDLW  7F
0466:  BCF    03.6
0467:  MOVWF  3E
0468:  BSF    03.6
0469:  MOVF   0D,W
046A:  BCF    03.6
046B:  MOVWF  3F
046C:  BSF    03.6
046D:  MOVF   0F,W
046E:  BCF    03.6
046F:  MOVWF  40
0470:  MOVF   3E,W
0471:  MOVWF  4A
0472:  CALL   428
0473:  MOVF   3F,W
0474:  BSF    03.6
0475:  MOVWF  0D
0476:  BCF    03.6
0477:  MOVF   40,W
0478:  BSF    03.6
0479:  MOVWF  0F
047A:  BCF    03.6
047B:  MOVF   0B,W
047C:  MOVWF  41
047D:  BCF    0B.7
047E:  BSF    03.5
047F:  BSF    03.6
0480:  BSF    0C.7
0481:  BSF    0C.0
0482:  NOP
0483:  NOP
0484:  BCF    03.5
0485:  BCF    03.6
0486:  BTFSC  41.7
0487:  BSF    0B.7
0488:  DECFSZ 3D,F
0489:  GOTO   48B
048A:  GOTO   4AA
048B:  BSF    03.6
048C:  RLF    0C,W
048D:  RLF    0E,W
048E:  ANDLW  7F
048F:  BCF    03.6
0490:  MOVWF  3E
0491:  BSF    03.6
0492:  MOVF   0D,W
0493:  BCF    03.6
0494:  MOVWF  3F
0495:  BSF    03.6
0496:  MOVF   0F,W
0497:  BCF    03.6
0498:  MOVWF  40
0499:  MOVF   3E,W
049A:  MOVWF  4A
049B:  CALL   428
049C:  MOVF   3F,W
049D:  BSF    03.6
049E:  MOVWF  0D
049F:  BCF    03.6
04A0:  MOVF   40,W
04A1:  BSF    03.6
04A2:  MOVWF  0F
04A3:  INCF   0D,F
04A4:  BTFSC  03.2
04A5:  INCF   0F,F
04A6:  BCF    03.0
04A7:  BCF    03.6
04A8:  DECFSZ 3D,F
04A9:  GOTO   454
04AA:  RETURN
04AB:  MOVF   4A,W
04AC:  BTFSC  03.2
04AD:  GOTO   51B
04AE:  MOVWF  52
04AF:  MOVF   4E,W
04B0:  BTFSC  03.2
04B1:  GOTO   51B
04B2:  ADDWF  52,F
04B3:  BTFSC  03.0
04B4:  GOTO   4BC
04B5:  MOVLW  7F
04B6:  SUBWF  52,F
04B7:  BTFSS  03.0
04B8:  GOTO   51B
04B9:  BTFSC  03.2
04BA:  GOTO   51B
04BB:  GOTO   4C0
04BC:  MOVLW  81
04BD:  ADDWF  52,F
04BE:  BTFSC  03.0
04BF:  GOTO   51B
04C0:  MOVF   52,W
04C1:  MOVWF  77
04C2:  CLRF   78
04C3:  CLRF   79
04C4:  CLRF   7A
04C5:  MOVF   4B,W
04C6:  MOVWF  56
04C7:  BSF    56.7
04C8:  MOVF   4C,W
04C9:  MOVWF  55
04CA:  MOVF   4D,W
04CB:  MOVWF  54
04CC:  MOVLW  18
04CD:  MOVWF  52
04CE:  CLRF   53
04CF:  BTFSS  54.0
04D0:  GOTO   4E9
04D1:  MOVF   51,W
04D2:  ADDWF  7A,F
04D3:  BTFSS  03.0
04D4:  GOTO   4DB
04D5:  INCF   79,F
04D6:  BTFSS  03.2
04D7:  GOTO   4DB
04D8:  INCF   78,F
04D9:  BTFSC  03.2
04DA:  BSF    53.7
04DB:  MOVF   50,W
04DC:  ADDWF  79,F
04DD:  BTFSS  03.0
04DE:  GOTO   4E2
04DF:  INCF   78,F
04E0:  BTFSC  03.2
04E1:  BSF    53.7
04E2:  MOVF   4F,W
04E3:  MOVWF  4C
04E4:  BSF    4C.7
04E5:  MOVF   4C,W
04E6:  ADDWF  78,F
04E7:  BTFSC  03.0
04E8:  BSF    53.7
04E9:  RLF    53,F
04EA:  RRF    78,F
04EB:  RRF    79,F
04EC:  RRF    7A,F
04ED:  RRF    56,F
04EE:  RRF    55,F
04EF:  RRF    54,F
04F0:  BCF    03.0
04F1:  DECFSZ 52,F
04F2:  GOTO   4CE
04F3:  MOVLW  01
04F4:  ADDWF  77,F
04F5:  BTFSC  03.0
04F6:  GOTO   51B
04F7:  BTFSC  78.7
04F8:  GOTO   500
04F9:  RLF    56,F
04FA:  RLF    7A,F
04FB:  RLF    79,F
04FC:  RLF    78,F
04FD:  DECF   77,F
04FE:  BTFSC  03.2
04FF:  GOTO   51B
0500:  BTFSS  56.7
0501:  GOTO   511
0502:  INCF   7A,F
0503:  BTFSS  03.2
0504:  GOTO   511
0505:  INCF   79,F
0506:  BTFSS  03.2
0507:  GOTO   511
0508:  INCF   78,F
0509:  BTFSS  03.2
050A:  GOTO   511
050B:  RRF    78,F
050C:  RRF    79,F
050D:  RRF    7A,F
050E:  INCF   77,F
050F:  BTFSC  03.2
0510:  GOTO   51B
0511:  MOVF   4B,W
0512:  MOVWF  53
0513:  MOVF   4F,W
0514:  XORWF  53,F
0515:  BTFSS  53.7
0516:  GOTO   519
0517:  BSF    78.7
0518:  GOTO   51F
0519:  BCF    78.7
051A:  GOTO   51F
051B:  CLRF   77
051C:  CLRF   78
051D:  CLRF   79
051E:  CLRF   7A
051F:  RETURN
0520:  MOVF   4A,W
0521:  SUBLW  B6
0522:  MOVWF  4A
0523:  CLRF   7A
0524:  MOVF   4B,W
0525:  MOVWF  4E
0526:  BSF    4B.7
0527:  BCF    03.0
0528:  RRF    4B,F
0529:  RRF    4C,F
052A:  RRF    4D,F
052B:  RRF    7A,F
052C:  RRF    79,F
052D:  RRF    78,F
052E:  RRF    77,F
052F:  DECFSZ 4A,F
0530:  GOTO   527
0531:  BTFSS  4E.7
0532:  GOTO   53E
0533:  COMF   77,F
0534:  COMF   78,F
0535:  COMF   79,F
0536:  COMF   7A,F
0537:  INCF   77,F
0538:  BTFSC  03.2
0539:  INCF   78,F
053A:  BTFSC  03.2
053B:  INCF   79,F
053C:  BTFSC  03.2
053D:  INCF   7A,F
053E:  RETURN
053F:  BTFSC  03.1
0540:  GOTO   544
0541:  MOVLW  52
0542:  MOVWF  04
0543:  BCF    03.7
0544:  CLRF   77
0545:  CLRF   78
0546:  CLRF   79
0547:  CLRF   7A
0548:  CLRF   52
0549:  CLRF   53
054A:  CLRF   54
054B:  CLRF   55
054C:  MOVF   51,W
054D:  IORWF  50,W
054E:  IORWF  4F,W
054F:  IORWF  4E,W
0550:  BTFSC  03.2
0551:  GOTO   582
0552:  MOVLW  20
0553:  MOVWF  56
0554:  BCF    03.0
0555:  RLF    4A,F
0556:  RLF    4B,F
0557:  RLF    4C,F
0558:  RLF    4D,F
0559:  RLF    52,F
055A:  RLF    53,F
055B:  RLF    54,F
055C:  RLF    55,F
055D:  MOVF   51,W
055E:  SUBWF  55,W
055F:  BTFSS  03.2
0560:  GOTO   56B
0561:  MOVF   50,W
0562:  SUBWF  54,W
0563:  BTFSS  03.2
0564:  GOTO   56B
0565:  MOVF   4F,W
0566:  SUBWF  53,W
0567:  BTFSS  03.2
0568:  GOTO   56B
0569:  MOVF   4E,W
056A:  SUBWF  52,W
056B:  BTFSS  03.0
056C:  GOTO   57C
056D:  MOVF   4E,W
056E:  SUBWF  52,F
056F:  MOVF   4F,W
0570:  BTFSS  03.0
0571:  INCFSZ 4F,W
0572:  SUBWF  53,F
0573:  MOVF   50,W
0574:  BTFSS  03.0
0575:  INCFSZ 50,W
0576:  SUBWF  54,F
0577:  MOVF   51,W
0578:  BTFSS  03.0
0579:  INCFSZ 51,W
057A:  SUBWF  55,F
057B:  BSF    03.0
057C:  RLF    77,F
057D:  RLF    78,F
057E:  RLF    79,F
057F:  RLF    7A,F
0580:  DECFSZ 56,F
0581:  GOTO   554
0582:  MOVF   52,W
0583:  MOVWF  00
0584:  INCF   04,F
0585:  MOVF   53,W
0586:  MOVWF  00
0587:  INCF   04,F
0588:  MOVF   54,W
0589:  MOVWF  00
058A:  INCF   04,F
058B:  MOVF   55,W
058C:  MOVWF  00
058D:  RETURN
058E:  MOVF   04,W
058F:  MOVWF  42
0590:  MOVF   41,W
0591:  MOVWF  44
0592:  BTFSC  03.2
0593:  GOTO   5AD
0594:  MOVF   40,W
0595:  MOVWF  4D
0596:  MOVF   3F,W
0597:  MOVWF  4C
0598:  MOVF   3E,W
0599:  MOVWF  4B
059A:  MOVF   3D,W
059B:  MOVWF  4A
059C:  CLRF   51
059D:  CLRF   50
059E:  MOVLW  20
059F:  MOVWF  4F
05A0:  MOVLW  82
05A1:  MOVWF  4E
05A2:  CALL   4AB
05A3:  MOVF   7A,W
05A4:  MOVWF  40
05A5:  MOVF   79,W
05A6:  MOVWF  3F
05A7:  MOVF   78,W
05A8:  MOVWF  3E
05A9:  MOVF   77,W
05AA:  MOVWF  3D
05AB:  DECFSZ 44,F
05AC:  GOTO   594
05AD:  MOVF   40,W
05AE:  MOVWF  4D
05AF:  MOVF   3F,W
05B0:  MOVWF  4C
05B1:  MOVF   3E,W
05B2:  MOVWF  4B
05B3:  MOVF   3D,W
05B4:  MOVWF  4A
05B5:  CALL   520
05B6:  MOVF   7A,W
05B7:  MOVWF  40
05B8:  MOVF   79,W
05B9:  MOVWF  3F
05BA:  MOVF   78,W
05BB:  MOVWF  3E
05BC:  MOVF   77,W
05BD:  MOVWF  3D
05BE:  BTFSS  40.7
05BF:  GOTO   5CD
05C0:  DECF   42,F
05C1:  BSF    42.5
05C2:  COMF   3D,F
05C3:  COMF   3E,F
05C4:  COMF   3F,F
05C5:  COMF   40,F
05C6:  INCF   3D,F
05C7:  BTFSC  03.2
05C8:  INCF   3E,F
05C9:  BTFSC  03.2
05CA:  INCF   3F,F
05CB:  BTFSC  03.2
05CC:  INCF   40,F
05CD:  MOVLW  3B
05CE:  MOVWF  49
05CF:  MOVLW  9A
05D0:  MOVWF  48
05D1:  MOVLW  CA
05D2:  MOVWF  47
05D3:  CLRF   46
05D4:  MOVLW  0A
05D5:  MOVWF  44
05D6:  MOVF   41,W
05D7:  BTFSC  03.2
05D8:  INCF   42,F
05D9:  BSF    03.1
05DA:  MOVLW  3D
05DB:  MOVWF  04
05DC:  BCF    03.7
05DD:  MOVF   40,W
05DE:  MOVWF  4D
05DF:  MOVF   3F,W
05E0:  MOVWF  4C
05E1:  MOVF   3E,W
05E2:  MOVWF  4B
05E3:  MOVF   3D,W
05E4:  MOVWF  4A
05E5:  MOVF   49,W
05E6:  MOVWF  51
05E7:  MOVF   48,W
05E8:  MOVWF  50
05E9:  MOVF   47,W
05EA:  MOVWF  4F
05EB:  MOVF   46,W
05EC:  MOVWF  4E
05ED:  CALL   53F
05EE:  MOVF   78,W
05EF:  MOVF   77,F
05F0:  BTFSS  03.2
05F1:  GOTO   605
05F2:  INCF   41,W
05F3:  SUBWF  44,W
05F4:  BTFSC  03.2
05F5:  GOTO   605
05F6:  MOVF   42,W
05F7:  BTFSC  03.2
05F8:  GOTO   607
05F9:  ANDLW  0F
05FA:  SUBWF  44,W
05FB:  BTFSC  03.2
05FC:  GOTO   5FF
05FD:  BTFSC  03.0
05FE:  GOTO   637
05FF:  BTFSC  42.7
0600:  GOTO   637
0601:  BTFSC  42.6
0602:  GOTO   607
0603:  MOVLW  20
0604:  GOTO   633
0605:  MOVLW  20
0606:  ANDWF  42,F
0607:  BTFSS  42.5
0608:  GOTO   615
0609:  BCF    42.5
060A:  MOVF   41,W
060B:  BTFSS  03.2
060C:  DECF   42,F
060D:  MOVF   77,W
060E:  MOVWF  42
060F:  MOVLW  2D
0610:  MOVWF  4A
0611:  CALL   428
0612:  MOVF   42,W
0613:  MOVWF  77
0614:  CLRF   42
0615:  MOVF   41,W
0616:  SUBWF  44,W
0617:  BTFSS  03.2
0618:  GOTO   623
0619:  MOVF   77,W
061A:  MOVWF  42
061B:  MOVLW  2E
061C:  MOVWF  4A
061D:  CALL   428
061E:  MOVF   42,W
061F:  MOVWF  77
0620:  MOVLW  20
0621:  ANDWF  42,F
0622:  MOVLW  00
0623:  MOVLW  30
0624:  BTFSS  42.5
0625:  GOTO   633
0626:  BCF    42.5
0627:  MOVF   41,W
0628:  BTFSS  03.2
0629:  DECF   42,F
062A:  MOVF   77,W
062B:  MOVWF  42
062C:  MOVLW  2D
062D:  MOVWF  4A
062E:  CALL   428
062F:  MOVF   42,W
0630:  MOVWF  77
0631:  CLRF   42
0632:  MOVLW  30
0633:  ADDWF  77,F
0634:  MOVF   77,W
0635:  MOVWF  4A
0636:  CALL   428
0637:  BCF    03.1
0638:  MOVF   49,W
0639:  MOVWF  4D
063A:  MOVF   48,W
063B:  MOVWF  4C
063C:  MOVF   47,W
063D:  MOVWF  4B
063E:  MOVF   46,W
063F:  MOVWF  4A
0640:  CLRF   51
0641:  CLRF   50
0642:  CLRF   4F
0643:  MOVLW  0A
0644:  MOVWF  4E
0645:  CALL   53F
0646:  MOVF   7A,W
0647:  MOVWF  49
0648:  MOVF   79,W
0649:  MOVWF  48
064A:  MOVF   78,W
064B:  MOVWF  47
064C:  MOVF   77,W
064D:  MOVWF  46
064E:  DECFSZ 44,F
064F:  GOTO   5D9
0650:  RETURN
*
06A1:  CLRF   77
06A2:  CLRF   78
06A3:  MOVF   3E,W
06A4:  BCF    03.0
06A5:  BTFSC  3F.0
06A6:  ADDWF  77,F
06A7:  RRF    77,F
06A8:  RRF    78,F
06A9:  BTFSC  3F.1
06AA:  ADDWF  77,F
06AB:  RRF    77,F
06AC:  RRF    78,F
06AD:  BTFSC  3F.2
06AE:  ADDWF  77,F
06AF:  RRF    77,F
06B0:  RRF    78,F
06B1:  BTFSC  3F.3
06B2:  ADDWF  77,F
06B3:  RRF    77,F
06B4:  RRF    78,F
06B5:  BTFSC  3F.4
06B6:  ADDWF  77,F
06B7:  RRF    77,F
06B8:  RRF    78,F
06B9:  BTFSC  3F.5
06BA:  ADDWF  77,F
06BB:  RRF    77,F
06BC:  RRF    78,F
06BD:  BTFSC  3F.6
06BE:  ADDWF  77,F
06BF:  RRF    77,F
06C0:  RRF    78,F
06C1:  BTFSC  3F.7
06C2:  ADDWF  77,F
06C3:  RRF    77,F
06C4:  RRF    78,F
*
06DB:  MOVF   0B,W
06DC:  MOVWF  3D
06DD:  BCF    0B.7
06DE:  BSF    03.5
06DF:  BSF    03.6
06E0:  BSF    0C.7
06E1:  BSF    0C.0
06E2:  NOP
06E3:  NOP
06E4:  BCF    03.5
06E5:  BCF    03.6
06E6:  BTFSC  3D.7
06E7:  BSF    0B.7
06E8:  BSF    03.6
06E9:  MOVF   0C,W
06EA:  ANDLW  7F
06EB:  BTFSC  03.2
06EC:  GOTO   72F
06ED:  BCF    03.6
06EE:  MOVWF  3D
06EF:  BSF    03.6
06F0:  MOVF   0D,W
06F1:  BCF    03.6
06F2:  MOVWF  3E
06F3:  BSF    03.6
06F4:  MOVF   0F,W
06F5:  BCF    03.6
06F6:  MOVWF  3F
06F7:  MOVF   3D,W
06F8:  MOVWF  4A
06F9:  CALL   428
06FA:  MOVF   3E,W
06FB:  BSF    03.6
06FC:  MOVWF  0D
06FD:  BCF    03.6
06FE:  MOVF   3F,W
06FF:  BSF    03.6
0700:  MOVWF  0F
0701:  BCF    03.6
0702:  MOVF   0B,W
0703:  MOVWF  40
0704:  BCF    0B.7
0705:  BSF    03.5
0706:  BSF    03.6
0707:  BSF    0C.7
0708:  BSF    0C.0
0709:  NOP
070A:  NOP
070B:  BCF    03.5
070C:  BCF    03.6
070D:  BTFSC  40.7
070E:  BSF    0B.7
070F:  BSF    03.6
0710:  RLF    0C,W
0711:  RLF    0E,W
0712:  ANDLW  7F
0713:  BTFSC  03.2
0714:  GOTO   72F
0715:  BCF    03.6
0716:  MOVWF  3D
0717:  BSF    03.6
0718:  MOVF   0D,W
0719:  BCF    03.6
071A:  MOVWF  3E
071B:  BSF    03.6
071C:  MOVF   0F,W
071D:  BCF    03.6
071E:  MOVWF  3F
071F:  MOVF   3D,W
0720:  MOVWF  4A
0721:  CALL   428
0722:  MOVF   3E,W
0723:  BSF    03.6
0724:  MOVWF  0D
0725:  BCF    03.6
0726:  MOVF   3F,W
0727:  BSF    03.6
0728:  MOVWF  0F
0729:  INCF   0D,F
072A:  BTFSC  03.2
072B:  INCF   0F,F
072C:  BCF    03.6
072D:  GOTO   6DB
072E:  BSF    03.6
072F:  BCF    03.6
0730:  RETURN
0731:  MOVF   0B,W
0732:  MOVWF  3E
0733:  BCF    0B.7
0734:  BSF    03.5
0735:  BSF    03.6
0736:  BSF    0C.7
0737:  BSF    0C.0
0738:  NOP
0739:  NOP
073A:  BCF    03.5
073B:  BCF    03.6
073C:  BTFSC  3E.7
073D:  BSF    0B.7
073E:  BTFSC  03.0
073F:  GOTO   769
0740:  BSF    03.6
0741:  MOVF   0C,W
0742:  ANDLW  7F
0743:  BCF    03.6
0744:  MOVWF  3E
0745:  BSF    03.6
0746:  MOVF   0D,W
0747:  BCF    03.6
0748:  MOVWF  3F
0749:  BSF    03.6
074A:  MOVF   0F,W
074B:  BCF    03.6
074C:  MOVWF  40
074D:  MOVF   3E,W
074E:  BTFSS  0C.4
074F:  GOTO   74E
0750:  MOVWF  19
0751:  MOVF   3F,W
0752:  BSF    03.6
0753:  MOVWF  0D
0754:  BCF    03.6
0755:  MOVF   40,W
0756:  BSF    03.6
0757:  MOVWF  0F
0758:  BCF    03.6
0759:  MOVF   0B,W
075A:  MOVWF  41
075B:  BCF    0B.7
075C:  BSF    03.5
075D:  BSF    03.6
075E:  BSF    0C.7
075F:  BSF    0C.0
0760:  NOP
0761:  NOP
0762:  BCF    03.5
0763:  BCF    03.6
0764:  BTFSC  41.7
0765:  BSF    0B.7
0766:  DECFSZ 3D,F
0767:  GOTO   769
0768:  GOTO   789
0769:  BSF    03.6
076A:  RLF    0C,W
076B:  RLF    0E,W
076C:  ANDLW  7F
076D:  BCF    03.6
076E:  MOVWF  3E
076F:  BSF    03.6
0770:  MOVF   0D,W
0771:  BCF    03.6
0772:  MOVWF  3F
0773:  BSF    03.6
0774:  MOVF   0F,W
0775:  BCF    03.6
0776:  MOVWF  40
0777:  MOVF   3E,W
0778:  BTFSS  0C.4
0779:  GOTO   778
077A:  MOVWF  19
077B:  MOVF   3F,W
077C:  BSF    03.6
077D:  MOVWF  0D
077E:  BCF    03.6
077F:  MOVF   40,W
0780:  BSF    03.6
0781:  MOVWF  0F
0782:  INCF   0D,F
0783:  BTFSC  03.2
0784:  INCF   0F,F
0785:  BCF    03.0
0786:  BCF    03.6
0787:  DECFSZ 3D,F
0788:  GOTO   731
0789:  RETURN
*
0800:  MOVF   04,W
0801:  MOVWF  42
0802:  MOVF   41,W
0803:  MOVWF  44
0804:  BTFSC  03.2
0805:  GOTO   021
0806:  MOVF   40,W
0807:  MOVWF  4D
0808:  MOVF   3F,W
0809:  MOVWF  4C
080A:  MOVF   3E,W
080B:  MOVWF  4B
080C:  MOVF   3D,W
080D:  MOVWF  4A
080E:  CLRF   51
080F:  CLRF   50
0810:  MOVLW  20
0811:  MOVWF  4F
0812:  MOVLW  82
0813:  MOVWF  4E
0814:  BCF    0A.3
0815:  CALL   4AB
0816:  BSF    0A.3
0817:  MOVF   7A,W
0818:  MOVWF  40
0819:  MOVF   79,W
081A:  MOVWF  3F
081B:  MOVF   78,W
081C:  MOVWF  3E
081D:  MOVF   77,W
081E:  MOVWF  3D
081F:  DECFSZ 44,F
0820:  GOTO   006
0821:  MOVF   40,W
0822:  MOVWF  4D
0823:  MOVF   3F,W
0824:  MOVWF  4C
0825:  MOVF   3E,W
0826:  MOVWF  4B
0827:  MOVF   3D,W
0828:  MOVWF  4A
0829:  BCF    0A.3
082A:  CALL   520
082B:  BSF    0A.3
082C:  MOVF   7A,W
082D:  MOVWF  40
082E:  MOVF   79,W
082F:  MOVWF  3F
0830:  MOVF   78,W
0831:  MOVWF  3E
0832:  MOVF   77,W
0833:  MOVWF  3D
0834:  BTFSS  40.7
0835:  GOTO   043
0836:  DECF   42,F
0837:  BSF    42.5
0838:  COMF   3D,F
0839:  COMF   3E,F
083A:  COMF   3F,F
083B:  COMF   40,F
083C:  INCF   3D,F
083D:  BTFSC  03.2
083E:  INCF   3E,F
083F:  BTFSC  03.2
0840:  INCF   3F,F
0841:  BTFSC  03.2
0842:  INCF   40,F
0843:  MOVLW  3B
0844:  MOVWF  49
0845:  MOVLW  9A
0846:  MOVWF  48
0847:  MOVLW  CA
0848:  MOVWF  47
0849:  CLRF   46
084A:  MOVLW  0A
084B:  MOVWF  44
084C:  MOVF   41,W
084D:  BTFSC  03.2
084E:  INCF   42,F
084F:  BSF    03.1
0850:  MOVLW  3D
0851:  MOVWF  04
0852:  BCF    03.7
0853:  MOVF   40,W
0854:  MOVWF  4D
0855:  MOVF   3F,W
0856:  MOVWF  4C
0857:  MOVF   3E,W
0858:  MOVWF  4B
0859:  MOVF   3D,W
085A:  MOVWF  4A
085B:  MOVF   49,W
085C:  MOVWF  51
085D:  MOVF   48,W
085E:  MOVWF  50
085F:  MOVF   47,W
0860:  MOVWF  4F
0861:  MOVF   46,W
0862:  MOVWF  4E
0863:  BCF    0A.3
0864:  CALL   53F
0865:  BSF    0A.3
0866:  MOVF   78,W
0867:  MOVF   77,F
0868:  BTFSS  03.2
0869:  GOTO   07D
086A:  INCF   41,W
086B:  SUBWF  44,W
086C:  BTFSC  03.2
086D:  GOTO   07D
086E:  MOVF   42,W
086F:  BTFSC  03.2
0870:  GOTO   07F
0871:  ANDLW  0F
0872:  SUBWF  44,W
0873:  BTFSC  03.2
0874:  GOTO   077
0875:  BTFSC  03.0
0876:  GOTO   0B3
0877:  BTFSC  42.7
0878:  GOTO   0B3
0879:  BTFSC  42.6
087A:  GOTO   07F
087B:  MOVLW  20
087C:  GOTO   0AE
087D:  MOVLW  20
087E:  ANDWF  42,F
087F:  BTFSS  42.5
0880:  GOTO   08E
0881:  BCF    42.5
0882:  MOVF   41,W
0883:  BTFSS  03.2
0884:  DECF   42,F
0885:  MOVF   77,W
0886:  MOVWF  42
0887:  MOVLW  2D
0888:  BTFSS  0C.4
0889:  GOTO   088
088A:  MOVWF  19
088B:  MOVF   42,W
088C:  MOVWF  77
088D:  CLRF   42
088E:  MOVF   41,W
088F:  SUBWF  44,W
0890:  BTFSS  03.2
0891:  GOTO   09D
0892:  MOVF   77,W
0893:  MOVWF  42
0894:  MOVLW  2E
0895:  BTFSS  0C.4
0896:  GOTO   095
0897:  MOVWF  19
0898:  MOVF   42,W
0899:  MOVWF  77
089A:  MOVLW  20
089B:  ANDWF  42,F
089C:  MOVLW  00
089D:  MOVLW  30
089E:  BTFSS  42.5
089F:  GOTO   0AE
08A0:  BCF    42.5
08A1:  MOVF   41,W
08A2:  BTFSS  03.2
08A3:  DECF   42,F
08A4:  MOVF   77,W
08A5:  MOVWF  42
08A6:  MOVLW  2D
08A7:  BTFSS  0C.4
08A8:  GOTO   0A7
08A9:  MOVWF  19
08AA:  MOVF   42,W
08AB:  MOVWF  77
08AC:  CLRF   42
08AD:  MOVLW  30
08AE:  ADDWF  77,F
08AF:  MOVF   77,W
08B0:  BTFSS  0C.4
08B1:  GOTO   0B0
08B2:  MOVWF  19
08B3:  BCF    03.1
08B4:  MOVF   49,W
08B5:  MOVWF  4D
08B6:  MOVF   48,W
08B7:  MOVWF  4C
08B8:  MOVF   47,W
08B9:  MOVWF  4B
08BA:  MOVF   46,W
08BB:  MOVWF  4A
08BC:  CLRF   51
08BD:  CLRF   50
08BE:  CLRF   4F
08BF:  MOVLW  0A
08C0:  MOVWF  4E
08C1:  BCF    0A.3
08C2:  CALL   53F
08C3:  BSF    0A.3
08C4:  MOVF   7A,W
08C5:  MOVWF  49
08C6:  MOVF   79,W
08C7:  MOVWF  48
08C8:  MOVF   78,W
08C9:  MOVWF  47
08CA:  MOVF   77,W
08CB:  MOVWF  46
08CC:  DECFSZ 44,F
08CD:  GOTO   04F
08CE:  RETURN
.................... 
.................... #list
.................... 
.................... #fuses xt,nowdt,HS,NOWDT,NOPROTECT,NOLVP,BROWNOUT
.................... #device *=16
.................... #device adc=10
.................... #use delay(clock = 4M)
*
00AC:  MOVLW  4B
00AD:  MOVWF  04
00AE:  BCF    03.7
00AF:  MOVF   00,W
00B0:  BTFSC  03.2
00B1:  GOTO   0C0
00B2:  MOVLW  01
00B3:  MOVWF  78
00B4:  CLRF   77
00B5:  DECFSZ 77,F
00B6:  GOTO   0B5
00B7:  DECFSZ 78,F
00B8:  GOTO   0B4
00B9:  MOVLW  4A
00BA:  MOVWF  77
00BB:  DECFSZ 77,F
00BC:  GOTO   0BB
00BD:  GOTO   0BE
00BE:  DECFSZ 00,F
00BF:  GOTO   0B2
00C0:  RETURN
.................... #define use_portb_kbd TRUE
.................... #define use_portd_lcd TRUE
.................... #include <lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
....................    output_float(LCD_DATA5);
....................    output_float(LCD_DATA6);
....................    output_float(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0xF;
*
00D9:  MOVLW  0F
00DA:  BSF    03.5
00DB:  ANDWF  08,W
00DC:  IORLW  F0
00DD:  MOVWF  08
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
00DE:  BCF    03.5
00DF:  BSF    08.2
....................    delay_cycles(1);
00E0:  NOP
....................    lcd_output_enable(1);
00E1:  BSF    08.0
....................    delay_cycles(1);
00E2:  NOP
....................    high = lcd_read_nibble();
00E3:  CALL   0CD
00E4:  MOVF   78,W
00E5:  MOVWF  52
....................       
....................    lcd_output_enable(0);
00E6:  BCF    08.0
....................    delay_cycles(1);
00E7:  NOP
....................    lcd_output_enable(1);
00E8:  BSF    08.0
....................    delay_us(1);
00E9:  NOP
....................    low = lcd_read_nibble();
00EA:  CALL   0CD
00EB:  MOVF   78,W
00EC:  MOVWF  51
....................       
....................    lcd_output_enable(0);
00ED:  BCF    08.0
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
00EE:  MOVLW  0F
00EF:  BSF    03.5
00F0:  ANDWF  08,W
00F1:  MOVWF  08
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
00F2:  BCF    03.5
00F3:  SWAPF  52,W
00F4:  MOVWF  77
00F5:  MOVLW  F0
00F6:  ANDWF  77,F
00F7:  MOVF   77,W
00F8:  IORWF  51,W
00F9:  MOVWF  78
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
....................    n |= input(LCD_DATA5) << 1;
....................    n |= input(LCD_DATA6) << 2;
....................    n |= input(LCD_DATA7) << 3;
....................    
....................    return(n);
....................   #else
....................    return(lcd.data);
*
00CD:  MOVF   08,W
00CE:  MOVWF  77
00CF:  SWAPF  08,W
00D0:  ANDLW  0F
00D1:  MOVWF  78
....................   #endif
00D2:  RETURN
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
....................    output_bit(LCD_DATA5, bit_test(n, 1));
....................    output_bit(LCD_DATA6, bit_test(n, 2));
....................    output_bit(LCD_DATA7, bit_test(n, 3));
....................   #else      
....................    lcdlat.data = n;
*
00C1:  SWAPF  52,W
00C2:  ANDLW  F0
00C3:  MOVWF  77
00C4:  MOVLW  0F
00C5:  ANDWF  08,W
00C6:  IORWF  77,W
00C7:  MOVWF  08
....................   #endif
....................       
....................    delay_cycles(1);
00C8:  NOP
....................    lcd_output_enable(1);
00C9:  BSF    08.0
....................    delay_us(2);
00CA:  GOTO   0CB
....................    lcd_output_enable(0);
00CB:  BCF    08.0
00CC:  RETURN
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
00D3:  BSF    03.5
00D4:  BCF    08.0
....................    lcd_rs_tris();
00D5:  BCF    08.1
....................    lcd_rw_tris();
00D6:  BCF    08.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
00D7:  BCF    03.5
00D8:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ;
*
00FA:  MOVF   78,W
00FB:  MOVWF  51
00FC:  BTFSC  51.7
00FD:  GOTO   0D9
....................    lcd_output_rs(address);
00FE:  BTFSS  4F.0
00FF:  BCF    08.1
0100:  BTFSC  4F.0
0101:  BSF    08.1
....................    delay_cycles(1);
0102:  NOP
....................    lcd_output_rw(0);
0103:  BCF    08.2
....................    delay_cycles(1);
0104:  NOP
....................    lcd_output_enable(0);
0105:  BCF    08.0
....................    lcd_send_nibble(n >> 4);
0106:  SWAPF  50,W
0107:  MOVWF  51
0108:  MOVLW  0F
0109:  ANDWF  51,F
010A:  MOVF   51,W
010B:  MOVWF  52
010C:  CALL   0C1
....................    lcd_send_nibble(n & 0xf);
010D:  MOVF   50,W
010E:  ANDLW  0F
010F:  MOVWF  51
0110:  MOVWF  52
0111:  CALL   0C1
0112:  RETURN
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
0113:  MOVLW  28
0114:  MOVWF  3D
0115:  MOVLW  0C
0116:  MOVWF  3E
0117:  MOVLW  01
0118:  MOVWF  3F
0119:  MOVLW  06
011A:  MOVWF  40
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
011B:  BCF    08.0
....................    lcd_output_rs(0);
011C:  BCF    08.1
....................    lcd_output_rw(0);
011D:  BCF    08.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
011E:  MOVLW  0F
011F:  BSF    03.5
0120:  ANDWF  08,W
0121:  MOVWF  08
....................   #endif
....................    lcd_enable_tris();
0122:  BCF    08.0
....................    lcd_rs_tris();
0123:  BCF    08.1
....................    lcd_rw_tris();
0124:  BCF    08.2
....................  #endif
....................     
....................    delay_ms(15);
0125:  MOVLW  0F
0126:  BCF    03.5
0127:  MOVWF  4B
0128:  CALL   0AC
....................    for(i=1;i<=3;++i)
0129:  MOVLW  01
012A:  MOVWF  3C
012B:  MOVF   3C,W
012C:  SUBLW  03
012D:  BTFSS  03.0
012E:  GOTO   137
....................    {
....................        lcd_send_nibble(3);
012F:  MOVLW  03
0130:  MOVWF  52
0131:  CALL   0C1
....................        delay_ms(5);
0132:  MOVLW  05
0133:  MOVWF  4B
0134:  CALL   0AC
0135:  INCF   3C,F
0136:  GOTO   12B
....................    }
....................    
....................    lcd_send_nibble(2);
0137:  MOVLW  02
0138:  MOVWF  52
0139:  CALL   0C1
....................    delay_ms(5);
013A:  MOVLW  05
013B:  MOVWF  4B
013C:  CALL   0AC
....................    for(i=0;i<=3;++i)
013D:  CLRF   3C
013E:  MOVF   3C,W
013F:  SUBLW  03
0140:  BTFSS  03.0
0141:  GOTO   14E
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
0142:  MOVLW  3D
0143:  ADDWF  3C,W
0144:  MOVWF  04
0145:  BCF    03.7
0146:  MOVF   00,W
0147:  MOVWF  41
0148:  CLRF   4F
0149:  MOVF   41,W
014A:  MOVWF  50
014B:  CALL   0D3
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
014C:  INCF   3C,F
014D:  GOTO   13E
014E:  BSF    0A.3
014F:  BCF    0A.4
0150:  GOTO   2AB (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
*
0416:  DECFSZ 4C,W
0417:  GOTO   419
0418:  GOTO   41C
....................       address=LCD_LINE_TWO;
0419:  MOVLW  40
041A:  MOVWF  4D
041B:  GOTO   41D
....................    else
....................       address=0;
041C:  CLRF   4D
....................      
....................    address+=x-1;
041D:  MOVLW  01
041E:  SUBWF  4B,W
041F:  ADDWF  4D,F
....................    lcd_send_byte(0,0x80|address);
0420:  MOVF   4D,W
0421:  IORLW  80
0422:  MOVWF  4E
0423:  CLRF   4F
0424:  MOVF   4E,W
0425:  MOVWF  50
0426:  CALL   0D3
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0427:  RETURN
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
0428:  MOVF   4A,W
0429:  XORLW  07
042A:  BTFSC  03.2
042B:  GOTO   436
042C:  XORLW  0B
042D:  BTFSC  03.2
042E:  GOTO   43B
042F:  XORLW  06
0430:  BTFSC  03.2
0431:  GOTO   443
0432:  XORLW  02
0433:  BTFSC  03.2
0434:  GOTO   449
0435:  GOTO   44E
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
0436:  MOVLW  01
0437:  MOVWF  4B
0438:  MOVWF  4C
0439:  CALL   416
043A:  GOTO   453
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
043B:  CLRF   4F
043C:  MOVLW  01
043D:  MOVWF  50
043E:  CALL   0D3
....................                      delay_ms(2);
043F:  MOVLW  02
0440:  MOVWF  4B
0441:  CALL   0AC
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
0442:  GOTO   453
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
0443:  MOVLW  01
0444:  MOVWF  4B
0445:  MOVLW  02
0446:  MOVWF  4C
0447:  CALL   416
0448:  GOTO   453
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
0449:  CLRF   4F
044A:  MOVLW  10
044B:  MOVWF  50
044C:  CALL   0D3
044D:  GOTO   453
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
044E:  MOVLW  01
044F:  MOVWF  4F
0450:  MOVF   4A,W
0451:  MOVWF  50
0452:  CALL   0D3
....................      #endif
....................    }
0453:  RETURN
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <kbd.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             KBD.C                                 ////
.................... ////                  Generic keypad scan driver                       ////
.................... ////                                                                   ////
.................... ////  kbd_init()   Must be called before any other function.           ////
.................... ////                                                                   ////
.................... ////  c = kbd_getc()  Will return a key value if pressed or /0 if not  ////
.................... ////                   This function should be called frequently so as ////
.................... ////                   not to miss a key press.                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////// The following defines the keypad layout on port D
.................... 
.................... // Un-comment the following define to use port B
.................... // #define use_portb_kbd TRUE
.................... 
.................... // Make sure the port used has pull-up resistors (or the LCD) on
.................... // the column pins
.................... 
.................... #if defined use_portb_kbd
....................    #byte kbd = getenv("SFR:PORTB")
.................... #else
....................    #byte kbd = getenv("SFR:PORTD")
.................... #endif
.................... 
.................... #if defined use_portb_kbd
....................    #define set_tris_kbd(x) set_tris_b(x)
.................... #else
....................    #define set_tris_kbd(x) set_tris_d(x)
.................... #endif
.................... 
.................... //Keypad connection:   (for example column 0 is B2)
.................... //                Bx:
.................... 
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad
.................... #define COL0 (1 << 2)
.................... #define COL1 (1 << 3)
.................... #define COL2 (1 << 6)
.................... 
.................... #define ROW0 (1 << 4)
.................... #define ROW1 (1 << 7)
.................... #define ROW2 (1 << 1)
.................... #define ROW3 (1 << 5)
.................... 
.................... #else ////////////////////////////////////////////////// For the black keypad
.................... #define COL0 (1 << 5)
.................... #define COL1 (1 << 6)
.................... #define COL2 (1 << 7)
.................... 
.................... #define ROW0 (1 << 1)
.................... #define ROW1 (1 << 2)
.................... #define ROW2 (1 << 3)
.................... #define ROW3 (1 << 4)
.................... 
.................... #endif
.................... 
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3)
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2)
.................... 
.................... // Keypad layout:
.................... char const KEYS[4][3] = {{'1','2','3'},
....................                          {'4','5','6'},
....................                          {'7','8','9'},
....................                          {'*','0','#'}};
.................... 
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where
....................                                   // n is the number of times you expect
....................                                   // to call kbd_getc each second
.................... 
.................... 
.................... void kbd_init() {
*
00A9:  BSF    0A.3
00AA:  BCF    0A.4
00AB:  GOTO   2A8 (RETURN)
.................... }
.................... 
.................... char kbd_getc( ) {
....................    static BYTE kbd_call_count;
*
0A6A:  BCF    03.5
0A6B:  CLRF   20
....................    static int1 kbd_down;
0A6C:  BCF    21.0
....................    static char last_key;
0A6D:  CLRF   22
....................    static BYTE col;
0A6E:  CLRF   23
.................... 
....................    BYTE kchar;
....................    BYTE row;
.................... 
....................    kchar='\0';
*
0651:  CLRF   3C
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) {
0652:  INCF   20,F
0653:  MOVF   20,W
0654:  SUBLW  21
0655:  BTFSC  03.0
0656:  GOTO   6D2
....................        switch (col) {
0657:  MOVF   23,W
0658:  BTFSC  03.2
0659:  GOTO   661
065A:  XORLW  01
065B:  BTFSC  03.2
065C:  GOTO   667
065D:  XORLW  03
065E:  BTFSC  03.2
065F:  GOTO   66D
0660:  GOTO   672
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0);
0661:  MOVLW  DE
0662:  BSF    03.5
0663:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS;
0664:  BCF    03.5
0665:  MOVWF  06
....................                     break;
0666:  GOTO   672
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1);
0667:  MOVLW  BE
0668:  BSF    03.5
0669:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS;
066A:  BCF    03.5
066B:  MOVWF  06
....................                     break;
066C:  GOTO   672
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2);
066D:  MOVLW  7E
066E:  BSF    03.5
066F:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS;
0670:  BCF    03.5
0671:  MOVWF  06
....................                     break;
....................        }
.................... 
....................        if(kbd_down) {
0672:  BTFSS  21.0
0673:  GOTO   67E
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) {
0674:  MOVF   06,W
0675:  ANDLW  1E
0676:  SUBLW  1E
0677:  BTFSS  03.2
0678:  GOTO   67D
....................            kbd_down=FALSE;
0679:  BCF    21.0
....................            kchar=last_key;
067A:  MOVF   22,W
067B:  MOVWF  3C
....................            last_key='\0';
067C:  CLRF   22
....................          }
....................        } else {
067D:  GOTO   6D1
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) {
067E:  MOVF   06,W
067F:  ANDLW  1E
0680:  SUBLW  1E
0681:  BTFSC  03.2
0682:  GOTO   6CC
....................              if((kbd & ROW0)==0)
0683:  MOVF   06,W
0684:  ANDLW  02
0685:  BTFSS  03.2
0686:  GOTO   689
....................                row=0;
0687:  CLRF   3D
0688:  GOTO   69D
....................              else if((kbd & ROW1)==0)
0689:  MOVF   06,W
068A:  ANDLW  04
068B:  BTFSS  03.2
068C:  GOTO   690
....................                row=1;
068D:  MOVLW  01
068E:  MOVWF  3D
068F:  GOTO   69D
....................              else if((kbd & ROW2)==0)
0690:  MOVF   06,W
0691:  ANDLW  08
0692:  BTFSS  03.2
0693:  GOTO   697
....................                row=2;
0694:  MOVLW  02
0695:  MOVWF  3D
0696:  GOTO   69D
....................              else if((kbd & ROW3)==0)
0697:  MOVF   06,W
0698:  ANDLW  10
0699:  BTFSS  03.2
069A:  GOTO   69D
....................                row=3;
069B:  MOVLW  03
069C:  MOVWF  3D
....................              last_key =KEYS[row][col];
069D:  MOVF   3D,W
069E:  MOVWF  3E
069F:  MOVLW  03
06A0:  MOVWF  3F
*
06C5:  MOVF   23,W
06C6:  ADDWF  78,W
06C7:  CALL   004
06C8:  MOVWF  78
06C9:  MOVWF  22
....................              kbd_down = TRUE;
06CA:  BSF    21.0
....................           } else {
06CB:  GOTO   6D1
....................              ++col;
06CC:  INCF   23,F
....................              if(col==3)
06CD:  MOVF   23,W
06CE:  SUBLW  03
06CF:  BTFSC  03.2
....................                col=0;
06D0:  CLRF   23
....................           }
....................        }
....................       kbd_call_count=0;
06D1:  CLRF   20
....................    }
....................   set_tris_kbd(ALL_PINS);
06D2:  MOVLW  FE
06D3:  BSF    03.5
06D4:  MOVWF  06
....................   return(kchar);
06D5:  BCF    03.5
06D6:  MOVF   3C,W
06D7:  MOVWF  78
06D8:  BSF    0A.3
06D9:  BCF    0A.4
06DA:  GOTO   40C (RETURN)
.................... }
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
0A6F:  CLRF   24
0A70:  CLRF   25
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #use rs232(uart1, baud = 9600)                // Initialize UART module
.................... 
.................... float temperatura;
.................... char keypad;
.................... int i;
.................... char keys_pressed[5];
.................... 
.................... void checkTemp(int value){
....................     if(temperatura<20)  {
*
08CF:  MOVF   29,W
08D0:  MOVWF  43
08D1:  MOVF   28,W
08D2:  MOVWF  42
08D3:  MOVF   27,W
08D4:  MOVWF  41
08D5:  MOVF   26,W
08D6:  MOVWF  40
08D7:  CLRF   47
08D8:  CLRF   46
08D9:  MOVLW  20
08DA:  MOVWF  45
08DB:  MOVLW  83
08DC:  MOVWF  44
08DD:  BCF    0A.3
08DE:  CALL   3D7
08DF:  BSF    0A.3
08E0:  BTFSS  03.0
08E1:  GOTO   123
....................         //Abre
....................         output_low(PIN_D3);
08E2:  BSF    03.5
08E3:  BCF    08.3
08E4:  BCF    03.5
08E5:  BCF    08.3
....................         lcd_gotoxy(1,2);
08E6:  MOVLW  01
08E7:  MOVWF  4B
08E8:  MOVLW  02
08E9:  MOVWF  4C
08EA:  BCF    0A.3
08EB:  CALL   416
08EC:  BSF    0A.3
....................         set_pwm1_duty(150);
08ED:  MOVLW  96
08EE:  MOVWF  15
....................         printf(lcd_putc,"\fPuerta abierta");
08EF:  MOVLW  14
08F0:  BSF    03.6
08F1:  MOVWF  0D
08F2:  MOVLW  00
08F3:  MOVWF  0F
08F4:  BCF    0A.3
08F5:  BCF    03.6
08F6:  CALL   6DB
08F7:  BSF    0A.3
....................         delay_ms(10000);
08F8:  MOVLW  28
08F9:  MOVWF  3D
08FA:  MOVLW  FA
08FB:  MOVWF  4B
08FC:  BCF    0A.3
08FD:  CALL   0AC
08FE:  BSF    0A.3
08FF:  DECFSZ 3D,F
0900:  GOTO   0FA
....................         set_pwm1_duty(0);
0901:  CLRF   15
....................         
....................         //Cierra
....................         lcd_gotoxy (1,2);
0902:  MOVLW  01
0903:  MOVWF  4B
0904:  MOVLW  02
0905:  MOVWF  4C
0906:  BCF    0A.3
0907:  CALL   416
0908:  BSF    0A.3
....................         set_pwm2_duty(150);
0909:  MOVLW  96
090A:  MOVWF  1B
....................         printf(lcd_putc,"\fPuerta cerrada");
090B:  MOVLW  1C
090C:  BSF    03.6
090D:  MOVWF  0D
090E:  MOVLW  00
090F:  MOVWF  0F
0910:  BCF    0A.3
0911:  BCF    03.6
0912:  CALL   6DB
0913:  BSF    0A.3
....................         delay_ms(10000);
0914:  MOVLW  28
0915:  MOVWF  3D
0916:  MOVLW  FA
0917:  MOVWF  4B
0918:  BCF    0A.3
0919:  CALL   0AC
091A:  BSF    0A.3
091B:  DECFSZ 3D,F
091C:  GOTO   116
....................         output_high(PIN_D3);
091D:  BSF    03.5
091E:  BCF    08.3
091F:  BCF    03.5
0920:  BSF    08.3
....................         set_pwm2_duty(0);
0921:  CLRF   1B
....................     }
0922:  GOTO   1C3
....................     else if(temperatura>=20&&temperatura<=35)  {         
0923:  CLRF   43
0924:  CLRF   42
0925:  MOVLW  20
0926:  MOVWF  41
0927:  MOVLW  83
0928:  MOVWF  40
0929:  MOVF   29,W
092A:  MOVWF  47
092B:  MOVF   28,W
092C:  MOVWF  46
092D:  MOVF   27,W
092E:  MOVWF  45
092F:  MOVF   26,W
0930:  MOVWF  44
0931:  BCF    0A.3
0932:  CALL   3D7
0933:  BSF    0A.3
0934:  BTFSC  03.0
0935:  GOTO   138
0936:  BTFSS  03.2
0937:  GOTO   18E
0938:  MOVF   29,W
0939:  MOVWF  43
093A:  MOVF   28,W
093B:  MOVWF  42
093C:  MOVF   27,W
093D:  MOVWF  41
093E:  MOVF   26,W
093F:  MOVWF  40
0940:  CLRF   47
0941:  CLRF   46
0942:  MOVLW  0C
0943:  MOVWF  45
0944:  MOVLW  84
0945:  MOVWF  44
0946:  BCF    0A.3
0947:  CALL   3D7
0948:  BSF    0A.3
0949:  BTFSC  03.0
094A:  GOTO   14D
094B:  BTFSS  03.2
094C:  GOTO   18E
....................         //Abre
....................         output_low(PIN_D3);
094D:  BSF    03.5
094E:  BCF    08.3
094F:  BCF    03.5
0950:  BCF    08.3
....................         lcd_gotoxy(1,2);
0951:  MOVLW  01
0952:  MOVWF  4B
0953:  MOVLW  02
0954:  MOVWF  4C
0955:  BCF    0A.3
0956:  CALL   416
0957:  BSF    0A.3
....................         set_pwm1_duty(150);
0958:  MOVLW  96
0959:  MOVWF  15
....................         printf(lcd_putc,"\fPuerta abierta");
095A:  MOVLW  24
095B:  BSF    03.6
095C:  MOVWF  0D
095D:  MOVLW  00
095E:  MOVWF  0F
095F:  BCF    0A.3
0960:  BCF    03.6
0961:  CALL   6DB
0962:  BSF    0A.3
....................         delay_ms(5000);
0963:  MOVLW  14
0964:  MOVWF  3D
0965:  MOVLW  FA
0966:  MOVWF  4B
0967:  BCF    0A.3
0968:  CALL   0AC
0969:  BSF    0A.3
096A:  DECFSZ 3D,F
096B:  GOTO   165
....................         set_pwm1_duty(0);
096C:  CLRF   15
.................... 
....................         //Cierra
....................         lcd_gotoxy (1,2);
096D:  MOVLW  01
096E:  MOVWF  4B
096F:  MOVLW  02
0970:  MOVWF  4C
0971:  BCF    0A.3
0972:  CALL   416
0973:  BSF    0A.3
....................         set_pwm2_duty(150);
0974:  MOVLW  96
0975:  MOVWF  1B
....................         printf(lcd_putc,"\fPuerta cerrada");
0976:  MOVLW  2C
0977:  BSF    03.6
0978:  MOVWF  0D
0979:  MOVLW  00
097A:  MOVWF  0F
097B:  BCF    0A.3
097C:  BCF    03.6
097D:  CALL   6DB
097E:  BSF    0A.3
....................         delay_ms(5000);
097F:  MOVLW  14
0980:  MOVWF  3D
0981:  MOVLW  FA
0982:  MOVWF  4B
0983:  BCF    0A.3
0984:  CALL   0AC
0985:  BSF    0A.3
0986:  DECFSZ 3D,F
0987:  GOTO   181
....................         set_pwm2_duty(0);
0988:  CLRF   1B
....................         output_high(PIN_D3);
0989:  BSF    03.5
098A:  BCF    08.3
098B:  BCF    03.5
098C:  BSF    08.3
....................     }
098D:  GOTO   1C3
....................     else if(temperatura>35)  {
098E:  CLRF   43
098F:  CLRF   42
0990:  MOVLW  0C
0991:  MOVWF  41
0992:  MOVLW  84
0993:  MOVWF  40
0994:  MOVF   29,W
0995:  MOVWF  47
0996:  MOVF   28,W
0997:  MOVWF  46
0998:  MOVF   27,W
0999:  MOVWF  45
099A:  MOVF   26,W
099B:  MOVWF  44
099C:  BCF    0A.3
099D:  CALL   3D7
099E:  BSF    0A.3
099F:  BTFSS  03.0
09A0:  GOTO   1C3
....................         printf(lcd_putc,"\fTemp alta,");
09A1:  MOVLW  34
09A2:  BSF    03.6
09A3:  MOVWF  0D
09A4:  MOVLW  00
09A5:  MOVWF  0F
09A6:  BCF    0A.3
09A7:  BCF    03.6
09A8:  CALL   6DB
09A9:  BSF    0A.3
....................         lcd_gotoxy (1,2);
09AA:  MOVLW  01
09AB:  MOVWF  4B
09AC:  MOVLW  02
09AD:  MOVWF  4C
09AE:  BCF    0A.3
09AF:  CALL   416
09B0:  BSF    0A.3
....................         printf(lcd_putc,"intentar despues.");
09B1:  MOVLW  3A
09B2:  BSF    03.6
09B3:  MOVWF  0D
09B4:  MOVLW  00
09B5:  MOVWF  0F
09B6:  BCF    0A.3
09B7:  BCF    03.6
09B8:  CALL   6DB
09B9:  BSF    0A.3
....................         delay_ms(500);
09BA:  MOVLW  02
09BB:  MOVWF  3D
09BC:  MOVLW  FA
09BD:  MOVWF  4B
09BE:  BCF    0A.3
09BF:  CALL   0AC
09C0:  BSF    0A.3
09C1:  DECFSZ 3D,F
09C2:  GOTO   1BC
....................     }
....................     keys_pressed[0]='*';
09C3:  MOVLW  2A
09C4:  MOVWF  2C
....................     keys_pressed[1]='*';
09C5:  MOVWF  2D
....................     keys_pressed[2]='*';
09C6:  MOVWF  2E
....................     keys_pressed[3]='*';
09C7:  MOVWF  2F
....................     keys_pressed[4]='*';
09C8:  MOVWF  30
....................     
....................     lcd_gotoxy(1,1);           
09C9:  MOVLW  01
09CA:  MOVWF  4B
09CB:  MOVWF  4C
09CC:  BCF    0A.3
09CD:  CALL   416
09CE:  BSF    0A.3
....................     printf(lcd_putc,"\fTEMP: %f ",temperatura);
09CF:  MOVLW  43
09D0:  BSF    03.6
09D1:  MOVWF  0D
09D2:  MOVLW  00
09D3:  MOVWF  0F
09D4:  BCF    03.0
09D5:  MOVLW  07
09D6:  BCF    03.6
09D7:  MOVWF  3D
09D8:  BCF    0A.3
09D9:  CALL   454
09DA:  BSF    0A.3
09DB:  MOVLW  89
09DC:  MOVWF  04
09DD:  MOVF   29,W
09DE:  MOVWF  40
09DF:  MOVF   28,W
09E0:  MOVWF  3F
09E1:  MOVF   27,W
09E2:  MOVWF  3E
09E3:  MOVF   26,W
09E4:  MOVWF  3D
09E5:  MOVLW  02
09E6:  MOVWF  41
09E7:  BCF    0A.3
09E8:  CALL   58E
09E9:  BSF    0A.3
09EA:  MOVLW  20
09EB:  MOVWF  4A
09EC:  BCF    0A.3
09ED:  CALL   428
09EE:  BSF    0A.3
....................     lcd_gotoxy(12,1);
09EF:  MOVLW  0C
09F0:  MOVWF  4B
09F1:  MOVLW  01
09F2:  MOVWF  4C
09F3:  BCF    0A.3
09F4:  CALL   416
09F5:  BSF    0A.3
....................     printf (lcd_putc,"C");
09F6:  MOVLW  43
09F7:  MOVWF  4A
09F8:  BCF    0A.3
09F9:  CALL   428
09FA:  BSF    0A.3
....................     
....................     putc(13);                                   // Go to first column
09FB:  MOVLW  0D
09FC:  BTFSS  0C.4
09FD:  GOTO   1FC
09FE:  MOVWF  19
....................     putc(10);                                   // Start a new lin
09FF:  MOVLW  0A
0A00:  BTFSS  0C.4
0A01:  GOTO   200
0A02:  MOVWF  19
....................     if(value==1){
0A03:  DECFSZ 3C,W
0A04:  GOTO   22B
....................         printf("Code:12345-Temp:%fC \n",temperatura );
0A05:  MOVLW  49
0A06:  BSF    03.6
0A07:  MOVWF  0D
0A08:  MOVLW  00
0A09:  MOVWF  0F
0A0A:  BCF    03.0
0A0B:  MOVLW  10
0A0C:  BCF    03.6
0A0D:  MOVWF  3D
0A0E:  BCF    0A.3
0A0F:  CALL   731
0A10:  BSF    0A.3
0A11:  MOVLW  89
0A12:  MOVWF  04
0A13:  MOVF   29,W
0A14:  MOVWF  40
0A15:  MOVF   28,W
0A16:  MOVWF  3F
0A17:  MOVF   27,W
0A18:  MOVWF  3E
0A19:  MOVF   26,W
0A1A:  MOVWF  3D
0A1B:  MOVLW  02
0A1C:  MOVWF  41
0A1D:  CALL   000
0A1E:  MOVLW  43
0A1F:  BTFSS  0C.4
0A20:  GOTO   21F
0A21:  MOVWF  19
0A22:  MOVLW  20
0A23:  BTFSS  0C.4
0A24:  GOTO   223
0A25:  MOVWF  19
0A26:  MOVLW  0A
0A27:  BTFSS  0C.4
0A28:  GOTO   227
0A29:  MOVWF  19
....................     }
0A2A:  GOTO   254
....................     else if(value==2){
0A2B:  MOVF   3C,W
0A2C:  SUBLW  02
0A2D:  BTFSS  03.2
0A2E:  GOTO   254
....................         printf("Code:67890-Temp:%fC \n",temperatura );
0A2F:  MOVLW  54
0A30:  BSF    03.6
0A31:  MOVWF  0D
0A32:  MOVLW  00
0A33:  MOVWF  0F
0A34:  BCF    03.0
0A35:  MOVLW  10
0A36:  BCF    03.6
0A37:  MOVWF  3D
0A38:  BCF    0A.3
0A39:  CALL   731
0A3A:  BSF    0A.3
0A3B:  MOVLW  89
0A3C:  MOVWF  04
0A3D:  MOVF   29,W
0A3E:  MOVWF  40
0A3F:  MOVF   28,W
0A40:  MOVWF  3F
0A41:  MOVF   27,W
0A42:  MOVWF  3E
0A43:  MOVF   26,W
0A44:  MOVWF  3D
0A45:  MOVLW  02
0A46:  MOVWF  41
0A47:  CALL   000
0A48:  MOVLW  43
0A49:  BTFSS  0C.4
0A4A:  GOTO   249
0A4B:  MOVWF  19
0A4C:  MOVLW  20
0A4D:  BTFSS  0C.4
0A4E:  GOTO   24D
0A4F:  MOVWF  19
0A50:  MOVLW  0A
0A51:  BTFSS  0C.4
0A52:  GOTO   251
0A53:  MOVWF  19
....................     }
0A54:  RETURN
....................     
.................... }
.................... 
.................... void main() {
0A55:  MOVF   03,W
0A56:  ANDLW  1F
0A57:  MOVWF  03
0A58:  MOVLW  19
0A59:  BSF    03.5
0A5A:  MOVWF  19
0A5B:  MOVLW  A6
0A5C:  MOVWF  18
0A5D:  MOVLW  90
0A5E:  BCF    03.5
0A5F:  MOVWF  18
0A60:  CLRF   32
0A61:  CLRF   31
0A62:  MOVLW  FF
0A63:  MOVWF  33
0A64:  BSF    03.5
0A65:  BSF    1F.0
0A66:  BSF    1F.1
0A67:  BSF    1F.2
0A68:  BCF    1F.3
0A69:  BCF    03.7
*
0A71:  CLRF   34
0A72:  MOVLW  01
0A73:  MOVWF  35
0A74:  CLRF   36
0A75:  CLRF   37
....................     
....................     int checkPassword=0;
....................     int valid=1;
....................     int maintinaing=0;
....................     int buttonState=0;
....................     keys_pressed[0]='*';
0A76:  MOVLW  2A
0A77:  MOVWF  2C
....................     keys_pressed[1]='*';
0A78:  MOVWF  2D
....................     keys_pressed[2]='*';
0A79:  MOVWF  2E
....................     keys_pressed[3]='*';
0A7A:  MOVWF  2F
....................     keys_pressed[4]='*';
0A7B:  MOVWF  30
....................     float previousTemp=0;
0A7C:  CLRF   3B
0A7D:  CLRF   3A
0A7E:  CLRF   39
0A7F:  CLRF   38
....................     
....................     setup_adc_ports(ALL_ANALOG); 
0A80:  BSF    03.5
0A81:  BCF    1F.0
0A82:  BCF    1F.1
0A83:  BCF    1F.2
0A84:  BCF    1F.3
....................     setup_adc(ADC_CLOCK_INTERNAL);
0A85:  BCF    03.5
0A86:  BSF    1F.6
0A87:  BSF    1F.7
0A88:  BSF    03.5
0A89:  BSF    1F.7
0A8A:  BCF    03.5
0A8B:  BSF    1F.0
....................     setup_ccp1(0x0C);
0A8C:  BCF    33.2
0A8D:  MOVF   33,W
0A8E:  BSF    03.5
0A8F:  MOVWF  07
0A90:  BCF    03.5
0A91:  BCF    07.2
0A92:  MOVLW  0C
0A93:  MOVWF  17
....................     setup_ccp2(0x0C);
0A94:  BCF    33.1
0A95:  MOVF   33,W
0A96:  BSF    03.5
0A97:  MOVWF  07
0A98:  BCF    03.5
0A99:  BCF    07.1
0A9A:  MOVLW  0C
0A9B:  MOVWF  1D
....................     //setup_timer_2(T2_DIV_BY_16,255,2); //For 8MHz
....................     setup_timer_2(T2_DIV_BY_16,255,1); //For 4MHz
0A9C:  MOVLW  00
0A9D:  MOVWF  78
0A9E:  IORLW  06
0A9F:  MOVWF  12
0AA0:  MOVLW  FF
0AA1:  BSF    03.5
0AA2:  MOVWF  12
....................     output_high(PIN_D3);
0AA3:  BCF    08.3
0AA4:  BCF    03.5
0AA5:  BSF    08.3
.................... 
....................     kbd_init();
0AA6:  BCF    0A.3
0AA7:  GOTO   0A9
0AA8:  BSF    0A.3
....................     lcd_init();
0AA9:  BCF    0A.3
0AAA:  GOTO   113
0AAB:  BSF    0A.3
.................... 
....................     port_b_pullups(TRUE);   //habilitan las resistencias pull up para evitar resistencias en el teclado
0AAC:  BSF    03.5
0AAD:  BCF    01.7
....................     i=0;
0AAE:  BCF    03.5
0AAF:  CLRF   2B
....................     delay_ms(2000);
0AB0:  MOVLW  08
0AB1:  MOVWF  3C
0AB2:  MOVLW  FA
0AB3:  MOVWF  4B
0AB4:  BCF    0A.3
0AB5:  CALL   0AC
0AB6:  BSF    0A.3
0AB7:  DECFSZ 3C,F
0AB8:  GOTO   2B2
....................     printf("Examen Pablo Garcia Brenes y Marco Fernandez Granados.\n");
0AB9:  MOVLW  5F
0ABA:  BSF    03.6
0ABB:  MOVWF  0D
0ABC:  MOVLW  00
0ABD:  MOVWF  0F
0ABE:  BCF    0A.3
0ABF:  BCF    03.6
0AC0:  GOTO   151
0AC1:  BSF    0A.3
....................     
....................     
....................     while (TRUE)   {
....................         //Muestra Temperatura
....................         temperatura=(float)read_adc()/2;
0AC2:  BSF    1F.2
0AC3:  BTFSC  1F.2
0AC4:  GOTO   2C3
0AC5:  MOVF   1E,W
0AC6:  MOVWF  79
0AC7:  BSF    03.5
0AC8:  MOVF   1E,W
0AC9:  MOVWF  78
0ACA:  MOVF   79,W
0ACB:  MOVWF  7A
0ACC:  MOVF   1E,W
0ACD:  BCF    03.5
0ACE:  MOVWF  3C
0ACF:  MOVF   79,W
0AD0:  MOVWF  3D
0AD1:  BCF    0A.3
0AD2:  GOTO   1AB
0AD3:  BSF    0A.3
0AD4:  MOVF   7A,W
0AD5:  MOVWF  3F
0AD6:  MOVF   79,W
0AD7:  MOVWF  3E
0AD8:  MOVF   78,W
0AD9:  MOVWF  3D
0ADA:  MOVF   77,W
0ADB:  MOVWF  3C
0ADC:  MOVF   7A,W
0ADD:  MOVWF  43
0ADE:  MOVF   79,W
0ADF:  MOVWF  42
0AE0:  MOVF   78,W
0AE1:  MOVWF  41
0AE2:  MOVF   77,W
0AE3:  MOVWF  40
0AE4:  CLRF   47
0AE5:  CLRF   46
0AE6:  CLRF   45
0AE7:  MOVLW  80
0AE8:  MOVWF  44
0AE9:  BCF    0A.3
0AEA:  GOTO   1CA
0AEB:  BSF    0A.3
0AEC:  MOVF   7A,W
0AED:  MOVWF  29
0AEE:  MOVF   79,W
0AEF:  MOVWF  28
0AF0:  MOVF   78,W
0AF1:  MOVWF  27
0AF2:  MOVF   77,W
0AF3:  MOVWF  26
....................         temperatura=temperatura-(float)1;
0AF4:  BSF    03.1
0AF5:  MOVF   29,W
0AF6:  MOVWF  3F
0AF7:  MOVF   28,W
0AF8:  MOVWF  3E
0AF9:  MOVF   27,W
0AFA:  MOVWF  3D
0AFB:  MOVF   26,W
0AFC:  MOVWF  3C
0AFD:  CLRF   43
0AFE:  CLRF   42
0AFF:  CLRF   41
0B00:  MOVLW  7F
0B01:  MOVWF  40
0B02:  BCF    0A.3
0B03:  CALL   296
0B04:  BSF    0A.3
0B05:  MOVF   7A,W
0B06:  MOVWF  29
0B07:  MOVF   79,W
0B08:  MOVWF  28
0B09:  MOVF   78,W
0B0A:  MOVWF  27
0B0B:  MOVF   77,W
0B0C:  MOVWF  26
....................         buttonState=input_state(PIN_C5);
0B0D:  CLRF   37
0B0E:  BTFSC  07.5
0B0F:  INCF   37,F
....................         if(buttonState==0){
0B10:  MOVF   37,F
0B11:  BTFSS  03.2
0B12:  GOTO   31C
....................             if(maintinaing==0){
0B13:  MOVF   36,F
0B14:  BTFSS  03.2
0B15:  GOTO   319
....................                 maintinaing=1;
0B16:  MOVLW  01
0B17:  MOVWF  36
....................             }
0B18:  GOTO   31C
....................             else if(maintinaing==1){
0B19:  DECFSZ 36,W
0B1A:  GOTO   31C
....................                 maintinaing=0;
0B1B:  CLRF   36
....................             }
....................         }
....................         if(temperatura>previousTemp && temperatura-previousTemp>1){
0B1C:  MOVF   3B,W
0B1D:  MOVWF  43
0B1E:  MOVF   3A,W
0B1F:  MOVWF  42
0B20:  MOVF   39,W
0B21:  MOVWF  41
0B22:  MOVF   38,W
0B23:  MOVWF  40
0B24:  MOVF   29,W
0B25:  MOVWF  47
0B26:  MOVF   28,W
0B27:  MOVWF  46
0B28:  MOVF   27,W
0B29:  MOVWF  45
0B2A:  MOVF   26,W
0B2B:  MOVWF  44
0B2C:  BCF    0A.3
0B2D:  CALL   3D7
0B2E:  BSF    0A.3
0B2F:  BTFSS  03.0
0B30:  GOTO   39A
0B31:  BSF    03.1
0B32:  MOVF   29,W
0B33:  MOVWF  3F
0B34:  MOVF   28,W
0B35:  MOVWF  3E
0B36:  MOVF   27,W
0B37:  MOVWF  3D
0B38:  MOVF   26,W
0B39:  MOVWF  3C
0B3A:  MOVF   3B,W
0B3B:  MOVWF  43
0B3C:  MOVF   3A,W
0B3D:  MOVWF  42
0B3E:  MOVF   39,W
0B3F:  MOVWF  41
0B40:  MOVF   38,W
0B41:  MOVWF  40
0B42:  BCF    0A.3
0B43:  CALL   296
0B44:  BSF    0A.3
0B45:  MOVF   7A,W
0B46:  MOVWF  3F
0B47:  MOVF   79,W
0B48:  MOVWF  3E
0B49:  MOVF   78,W
0B4A:  MOVWF  3D
0B4B:  MOVF   77,W
0B4C:  MOVWF  3C
0B4D:  CLRF   43
0B4E:  CLRF   42
0B4F:  CLRF   41
0B50:  MOVLW  7F
0B51:  MOVWF  40
0B52:  MOVF   3F,W
0B53:  MOVWF  47
0B54:  MOVF   3E,W
0B55:  MOVWF  46
0B56:  MOVF   3D,W
0B57:  MOVWF  45
0B58:  MOVF   3C,W
0B59:  MOVWF  44
0B5A:  BCF    0A.3
0B5B:  CALL   3D7
0B5C:  BSF    0A.3
0B5D:  BTFSS  03.0
0B5E:  GOTO   39A
....................             lcd_gotoxy(1,1);           
0B5F:  MOVLW  01
0B60:  MOVWF  4B
0B61:  MOVWF  4C
0B62:  BCF    0A.3
0B63:  CALL   416
0B64:  BSF    0A.3
....................             printf(lcd_putc,"\fTEMP: %f ",temperatura);
0B65:  MOVLW  7B
0B66:  BSF    03.6
0B67:  MOVWF  0D
0B68:  MOVLW  00
0B69:  MOVWF  0F
0B6A:  BCF    03.0
0B6B:  MOVLW  07
0B6C:  BCF    03.6
0B6D:  MOVWF  3D
0B6E:  BCF    0A.3
0B6F:  CALL   454
0B70:  BSF    0A.3
0B71:  MOVLW  89
0B72:  MOVWF  04
0B73:  MOVF   29,W
0B74:  MOVWF  40
0B75:  MOVF   28,W
0B76:  MOVWF  3F
0B77:  MOVF   27,W
0B78:  MOVWF  3E
0B79:  MOVF   26,W
0B7A:  MOVWF  3D
0B7B:  MOVLW  02
0B7C:  MOVWF  41
0B7D:  BCF    0A.3
0B7E:  CALL   58E
0B7F:  BSF    0A.3
0B80:  MOVLW  20
0B81:  MOVWF  4A
0B82:  BCF    0A.3
0B83:  CALL   428
0B84:  BSF    0A.3
....................             lcd_gotoxy(12,1);
0B85:  MOVLW  0C
0B86:  MOVWF  4B
0B87:  MOVLW  01
0B88:  MOVWF  4C
0B89:  BCF    0A.3
0B8A:  CALL   416
0B8B:  BSF    0A.3
....................             printf (lcd_putc,"C");
0B8C:  MOVLW  43
0B8D:  MOVWF  4A
0B8E:  BCF    0A.3
0B8F:  CALL   428
0B90:  BSF    0A.3
....................             previousTemp=temperatura;
0B91:  MOVF   29,W
0B92:  MOVWF  3B
0B93:  MOVF   28,W
0B94:  MOVWF  3A
0B95:  MOVF   27,W
0B96:  MOVWF  39
0B97:  MOVF   26,W
0B98:  MOVWF  38
....................         }
0B99:  GOTO   403
....................         else if( temperatura-previousTemp<-1){
0B9A:  BSF    03.1
0B9B:  MOVF   29,W
0B9C:  MOVWF  3F
0B9D:  MOVF   28,W
0B9E:  MOVWF  3E
0B9F:  MOVF   27,W
0BA0:  MOVWF  3D
0BA1:  MOVF   26,W
0BA2:  MOVWF  3C
0BA3:  MOVF   3B,W
0BA4:  MOVWF  43
0BA5:  MOVF   3A,W
0BA6:  MOVWF  42
0BA7:  MOVF   39,W
0BA8:  MOVWF  41
0BA9:  MOVF   38,W
0BAA:  MOVWF  40
0BAB:  BCF    0A.3
0BAC:  CALL   296
0BAD:  BSF    0A.3
0BAE:  MOVF   7A,W
0BAF:  MOVWF  3F
0BB0:  MOVF   79,W
0BB1:  MOVWF  3E
0BB2:  MOVF   78,W
0BB3:  MOVWF  3D
0BB4:  MOVF   77,W
0BB5:  MOVWF  3C
0BB6:  MOVF   3F,W
0BB7:  MOVWF  43
0BB8:  MOVF   3E,W
0BB9:  MOVWF  42
0BBA:  MOVF   3D,W
0BBB:  MOVWF  41
0BBC:  MOVF   3C,W
0BBD:  MOVWF  40
0BBE:  CLRF   47
0BBF:  CLRF   46
0BC0:  MOVLW  80
0BC1:  MOVWF  45
0BC2:  MOVLW  7F
0BC3:  MOVWF  44
0BC4:  BCF    0A.3
0BC5:  CALL   3D7
0BC6:  BSF    0A.3
0BC7:  BTFSS  03.0
0BC8:  GOTO   403
....................             lcd_gotoxy(1,1);           
0BC9:  MOVLW  01
0BCA:  MOVWF  4B
0BCB:  MOVWF  4C
0BCC:  BCF    0A.3
0BCD:  CALL   416
0BCE:  BSF    0A.3
....................             printf(lcd_putc,"\fTEMP: %f ",temperatura);
0BCF:  MOVLW  81
0BD0:  BSF    03.6
0BD1:  MOVWF  0D
0BD2:  MOVLW  00
0BD3:  MOVWF  0F
0BD4:  BCF    03.0
0BD5:  MOVLW  07
0BD6:  BCF    03.6
0BD7:  MOVWF  3D
0BD8:  BCF    0A.3
0BD9:  CALL   454
0BDA:  BSF    0A.3
0BDB:  MOVLW  89
0BDC:  MOVWF  04
0BDD:  MOVF   29,W
0BDE:  MOVWF  40
0BDF:  MOVF   28,W
0BE0:  MOVWF  3F
0BE1:  MOVF   27,W
0BE2:  MOVWF  3E
0BE3:  MOVF   26,W
0BE4:  MOVWF  3D
0BE5:  MOVLW  02
0BE6:  MOVWF  41
0BE7:  BCF    0A.3
0BE8:  CALL   58E
0BE9:  BSF    0A.3
0BEA:  MOVLW  20
0BEB:  MOVWF  4A
0BEC:  BCF    0A.3
0BED:  CALL   428
0BEE:  BSF    0A.3
....................             lcd_gotoxy(12,1);
0BEF:  MOVLW  0C
0BF0:  MOVWF  4B
0BF1:  MOVLW  01
0BF2:  MOVWF  4C
0BF3:  BCF    0A.3
0BF4:  CALL   416
0BF5:  BSF    0A.3
....................             printf (lcd_putc,"C");
0BF6:  MOVLW  43
0BF7:  MOVWF  4A
0BF8:  BCF    0A.3
0BF9:  CALL   428
0BFA:  BSF    0A.3
....................             previousTemp=temperatura;
0BFB:  MOVF   29,W
0BFC:  MOVWF  3B
0BFD:  MOVF   28,W
0BFE:  MOVWF  3A
0BFF:  MOVF   27,W
0C00:  MOVWF  39
0C01:  MOVF   26,W
0C02:  MOVWF  38
....................         }
.................... 
....................         if(maintinaing==0){
0C03:  MOVF   36,F
0C04:  BTFSS  03.2
0C05:  GOTO   4DC
....................             output_high(PIN_D3);
0C06:  BSF    03.5
0C07:  BCF    08.3
0C08:  BCF    03.5
0C09:  BSF    08.3
....................             //lee teclado
....................             keypad=kbd_getc();           
0C0A:  BCF    0A.3
0C0B:  GOTO   651
0C0C:  BSF    0A.3
0C0D:  MOVF   78,W
0C0E:  MOVWF  2A
....................             if(keypad!=0){
0C0F:  MOVF   2A,F
0C10:  BTFSC  03.2
0C11:  GOTO   437
....................                 printf(lcd_putc,"\f Tecla: %c",keypad);
0C12:  MOVLW  87
0C13:  BSF    03.6
0C14:  MOVWF  0D
0C15:  MOVLW  00
0C16:  MOVWF  0F
0C17:  BCF    03.0
0C18:  MOVLW  09
0C19:  BCF    03.6
0C1A:  MOVWF  3D
0C1B:  BCF    0A.3
0C1C:  CALL   454
0C1D:  BSF    0A.3
0C1E:  MOVF   2A,W
0C1F:  MOVWF  4A
0C20:  BCF    0A.3
0C21:  CALL   428
0C22:  BSF    0A.3
....................                 if(keypad=='#'){
0C23:  MOVF   2A,W
0C24:  SUBLW  23
0C25:  BTFSS  03.2
0C26:  GOTO   42A
....................                     checkPassword=1;
0C27:  MOVLW  01
0C28:  MOVWF  34
....................                 }
0C29:  GOTO   437
....................                 else if(i>4){
0C2A:  MOVF   2B,W
0C2B:  SUBLW  04
0C2C:  BTFSC  03.0
0C2D:  GOTO   430
....................                     valid=0;
0C2E:  CLRF   35
....................                 }
0C2F:  GOTO   437
....................                 else{
....................                     keys_pressed[i]=keypad;
0C30:  MOVLW  2C
0C31:  ADDWF  2B,W
0C32:  MOVWF  04
0C33:  BCF    03.7
0C34:  MOVF   2A,W
0C35:  MOVWF  00
....................                     i++;   
0C36:  INCF   2B,F
....................                 }
....................             }
....................             //Cuando digita contrasena
....................             if(checkPassword==1){
0C37:  DECFSZ 34,W
0C38:  GOTO   4DB
....................                 if( keys_pressed[0]=='1' && 
....................                     keys_pressed[1]=='2' && 
....................                     keys_pressed[2]=='3' &&
....................                     keys_pressed[3]=='4' &&
....................                     keys_pressed[4]=='5' && valid==1){
0C39:  MOVF   2C,W
0C3A:  SUBLW  31
0C3B:  BTFSS  03.2
0C3C:  GOTO   466
0C3D:  MOVF   2D,W
0C3E:  SUBLW  32
0C3F:  BTFSS  03.2
0C40:  GOTO   466
0C41:  MOVF   2E,W
0C42:  SUBLW  33
0C43:  BTFSS  03.2
0C44:  GOTO   466
0C45:  MOVF   2F,W
0C46:  SUBLW  34
0C47:  BTFSS  03.2
0C48:  GOTO   466
0C49:  MOVF   30,W
0C4A:  SUBLW  35
0C4B:  BTFSS  03.2
0C4C:  GOTO   466
0C4D:  DECFSZ 35,W
0C4E:  GOTO   466
....................                     i=0;
0C4F:  CLRF   2B
....................                     printf(lcd_putc,"\fPIN Correcto");
0C50:  MOVLW  8D
0C51:  BSF    03.6
0C52:  MOVWF  0D
0C53:  MOVLW  00
0C54:  MOVWF  0F
0C55:  BCF    0A.3
0C56:  BCF    03.6
0C57:  CALL   6DB
0C58:  BSF    0A.3
....................                     delay_ms(2000);
0C59:  MOVLW  08
0C5A:  MOVWF  3C
0C5B:  MOVLW  FA
0C5C:  MOVWF  4B
0C5D:  BCF    0A.3
0C5E:  CALL   0AC
0C5F:  BSF    0A.3
0C60:  DECFSZ 3C,F
0C61:  GOTO   45B
....................                     checkTemp(1);
0C62:  MOVLW  01
0C63:  MOVWF  3C
0C64:  CALL   0CF
....................                 }
0C65:  GOTO   4D8
....................                 else if(keys_pressed[0]=='6' && 
....................                         keys_pressed[1]=='7' && 
....................                         keys_pressed[2]=='8' &&
....................                         keys_pressed[3]=='9' &&
....................                         keys_pressed[4]=='0' && valid==1){
0C66:  MOVF   2C,W
0C67:  SUBLW  36
0C68:  BTFSS  03.2
0C69:  GOTO   493
0C6A:  MOVF   2D,W
0C6B:  SUBLW  37
0C6C:  BTFSS  03.2
0C6D:  GOTO   493
0C6E:  MOVF   2E,W
0C6F:  SUBLW  38
0C70:  BTFSS  03.2
0C71:  GOTO   493
0C72:  MOVF   2F,W
0C73:  SUBLW  39
0C74:  BTFSS  03.2
0C75:  GOTO   493
0C76:  MOVF   30,W
0C77:  SUBLW  30
0C78:  BTFSS  03.2
0C79:  GOTO   493
0C7A:  DECFSZ 35,W
0C7B:  GOTO   493
....................                     i=0;
0C7C:  CLRF   2B
....................                     printf(lcd_putc,"\fPIN Correcto");
0C7D:  MOVLW  94
0C7E:  BSF    03.6
0C7F:  MOVWF  0D
0C80:  MOVLW  00
0C81:  MOVWF  0F
0C82:  BCF    0A.3
0C83:  BCF    03.6
0C84:  CALL   6DB
0C85:  BSF    0A.3
....................                     delay_ms(2000);
0C86:  MOVLW  08
0C87:  MOVWF  3C
0C88:  MOVLW  FA
0C89:  MOVWF  4B
0C8A:  BCF    0A.3
0C8B:  CALL   0AC
0C8C:  BSF    0A.3
0C8D:  DECFSZ 3C,F
0C8E:  GOTO   488
....................                     checkTemp(2);
0C8F:  MOVLW  02
0C90:  MOVWF  3C
0C91:  CALL   0CF
....................                 }
0C92:  GOTO   4D8
....................                 else {
....................                     printf(lcd_putc,"\fPIN Incorrecto");
0C93:  MOVLW  9B
0C94:  BSF    03.6
0C95:  MOVWF  0D
0C96:  MOVLW  00
0C97:  MOVWF  0F
0C98:  BCF    0A.3
0C99:  BCF    03.6
0C9A:  CALL   6DB
0C9B:  BSF    0A.3
....................                     i=0;
0C9C:  CLRF   2B
....................                     delay_ms(2000);
0C9D:  MOVLW  08
0C9E:  MOVWF  3C
0C9F:  MOVLW  FA
0CA0:  MOVWF  4B
0CA1:  BCF    0A.3
0CA2:  CALL   0AC
0CA3:  BSF    0A.3
0CA4:  DECFSZ 3C,F
0CA5:  GOTO   49F
....................                     lcd_gotoxy(1,1);           
0CA6:  MOVLW  01
0CA7:  MOVWF  4B
0CA8:  MOVWF  4C
0CA9:  BCF    0A.3
0CAA:  CALL   416
0CAB:  BSF    0A.3
....................                     printf(lcd_putc,"\fTEMP: %f ",temperatura);
0CAC:  MOVLW  A3
0CAD:  BSF    03.6
0CAE:  MOVWF  0D
0CAF:  MOVLW  00
0CB0:  MOVWF  0F
0CB1:  BCF    03.0
0CB2:  MOVLW  07
0CB3:  BCF    03.6
0CB4:  MOVWF  3D
0CB5:  BCF    0A.3
0CB6:  CALL   454
0CB7:  BSF    0A.3
0CB8:  MOVLW  89
0CB9:  MOVWF  04
0CBA:  MOVF   29,W
0CBB:  MOVWF  40
0CBC:  MOVF   28,W
0CBD:  MOVWF  3F
0CBE:  MOVF   27,W
0CBF:  MOVWF  3E
0CC0:  MOVF   26,W
0CC1:  MOVWF  3D
0CC2:  MOVLW  02
0CC3:  MOVWF  41
0CC4:  BCF    0A.3
0CC5:  CALL   58E
0CC6:  BSF    0A.3
0CC7:  MOVLW  20
0CC8:  MOVWF  4A
0CC9:  BCF    0A.3
0CCA:  CALL   428
0CCB:  BSF    0A.3
....................                     lcd_gotoxy(12,1);
0CCC:  MOVLW  0C
0CCD:  MOVWF  4B
0CCE:  MOVLW  01
0CCF:  MOVWF  4C
0CD0:  BCF    0A.3
0CD1:  CALL   416
0CD2:  BSF    0A.3
....................                     printf (lcd_putc,"C");
0CD3:  MOVLW  43
0CD4:  MOVWF  4A
0CD5:  BCF    0A.3
0CD6:  CALL   428
0CD7:  BSF    0A.3
....................                 }
....................                 checkPassword=0;
0CD8:  CLRF   34
....................                 valid=1;
0CD9:  MOVLW  01
0CDA:  MOVWF  35
....................             }
....................         }
0CDB:  GOTO   4E2
....................         else if(maintinaing==1){
0CDC:  DECFSZ 36,W
0CDD:  GOTO   4E2
....................             output_low(PIN_D3);
0CDE:  BSF    03.5
0CDF:  BCF    08.3
0CE0:  BCF    03.5
0CE1:  BCF    08.3
....................         }
0CE2:  GOTO   2C2
....................         
....................     }
.................... }
0CE3:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
