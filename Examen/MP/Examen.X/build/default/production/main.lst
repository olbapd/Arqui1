CCS PCM C Compiler, Version 5.088d, 1               11-Nov-19 17:23
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\pablo\Documents\1-TEC\Arqui1\Examen\MP\Examen.X\build\default\production\main.lst

               ROM used:   3184 words (39%)
                           Largest free fragment is 2048
               RAM used:   37 (10%) at main() level
                           60 (16%) worst case
               Stack used: 6 locations
               Stack size: 8

*
0000:  MOVLW  0A
0001:  MOVWF  0A
0002:  GOTO   255
0003:  NOP
.................... #include <16f877.h>
.................... //////////// Standard Header file for the PIC16F877 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  34
000C:  RETLW  35
000D:  RETLW  36
000E:  RETLW  37
000F:  RETLW  38
0010:  RETLW  39
0011:  RETLW  2A
0012:  RETLW  30
0013:  RETLW  23
0014:  DATA 0C,38
0015:  DATA F5,32
0016:  DATA 72,3A
0017:  DATA 61,10
0018:  DATA 61,31
0019:  DATA E9,32
001A:  DATA 72,3A
001B:  DATA 61,00
001C:  DATA 0C,38
001D:  DATA F5,32
001E:  DATA 72,3A
001F:  DATA 61,10
0020:  DATA E3,32
0021:  DATA 72,39
0022:  DATA 61,32
0023:  DATA 61,00
0024:  DATA 0C,38
0025:  DATA F5,32
0026:  DATA 72,3A
0027:  DATA 61,10
0028:  DATA 61,31
0029:  DATA E9,32
002A:  DATA 72,3A
002B:  DATA 61,00
002C:  DATA 0C,38
002D:  DATA F5,32
002E:  DATA 72,3A
002F:  DATA 61,10
0030:  DATA E3,32
0031:  DATA 72,39
0032:  DATA 61,32
0033:  DATA 61,00
0034:  DATA 0C,2A
0035:  DATA E5,36
0036:  DATA 70,10
0037:  DATA 61,36
0038:  DATA F4,30
0039:  DATA 2C,00
003A:  DATA 69,37
003B:  DATA F4,32
003C:  DATA 6E,3A
003D:  DATA 61,39
003E:  DATA 20,32
003F:  DATA E5,39
0040:  DATA F0,3A
0041:  DATA E5,39
0042:  DATA 2E,00
0043:  DATA 0C,2A
0044:  DATA C5,26
0045:  DATA 50,1D
0046:  DATA A0,12
0047:  DATA 66,10
0048:  DATA 00,00
0049:  DATA C3,37
004A:  DATA E4,32
004B:  DATA BA,18
004C:  DATA B2,19
004D:  DATA B4,1A
004E:  DATA 2D,2A
004F:  DATA E5,36
0050:  DATA 70,1D
0051:  DATA 25,33
0052:  DATA 43,10
0053:  DATA 0A,00
0054:  DATA C3,37
0055:  DATA E4,32
0056:  DATA 3A,1B
0057:  DATA 37,1C
0058:  DATA 39,18
0059:  DATA 2D,2A
005A:  DATA E5,36
005B:  DATA 70,1D
005C:  DATA 25,33
005D:  DATA 43,10
005E:  DATA 0A,00
005F:  DATA 45,3C
0060:  DATA E1,36
0061:  DATA 65,37
0062:  DATA 20,28
0063:  DATA 61,31
0064:  DATA EC,37
0065:  DATA A0,23
0066:  DATA 61,39
0067:  DATA E3,34
0068:  DATA 61,10
0069:  DATA 42,39
006A:  DATA 65,37
006B:  DATA E5,39
006C:  DATA A0,3C
006D:  DATA A0,26
006E:  DATA 61,39
006F:  DATA E3,37
0070:  DATA 20,23
0071:  DATA 65,39
0072:  DATA EE,30
0073:  DATA 6E,32
0074:  DATA 65,3D
0075:  DATA A0,23
0076:  DATA F2,30
0077:  DATA EE,30
0078:  DATA E4,37
0079:  DATA 73,17
007A:  DATA 0A,00
007B:  DATA 0C,2A
007C:  DATA C5,26
007D:  DATA 50,1D
007E:  DATA A0,12
007F:  DATA 66,10
0080:  DATA 00,01
0081:  DATA 0C,2A
0082:  DATA C5,26
0083:  DATA 50,1D
0084:  DATA A0,12
0085:  DATA 66,10
0086:  DATA 00,01
0087:  DATA 0C,10
0088:  DATA F4,32
0089:  DATA 63,36
008A:  DATA 61,10
008B:  DATA CE,37
008C:  DATA 3D,10
008D:  DATA A5,31
008E:  DATA 00,01
008F:  DATA 0C,28
0090:  DATA 49,27
0091:  DATA A0,21
0092:  DATA 6F,39
0093:  DATA F2,32
0094:  DATA 63,3A
0095:  DATA 6F,00
0096:  DATA 0C,28
0097:  DATA 49,27
0098:  DATA A0,21
0099:  DATA 6F,39
009A:  DATA F2,32
009B:  DATA 63,3A
009C:  DATA 6F,00
009D:  DATA 0C,28
009E:  DATA 49,27
009F:  DATA A0,24
00A0:  DATA EE,31
00A1:  DATA 6F,39
00A2:  DATA F2,32
00A3:  DATA 63,3A
00A4:  DATA 6F,00
00A5:  DATA 0C,2A
00A6:  DATA C5,26
00A7:  DATA 50,1D
00A8:  DATA A0,12
00A9:  DATA 66,10
00AA:  DATA 00,01
*
0153:  MOVF   0B,W
0154:  MOVWF  3C
0155:  BCF    0B.7
0156:  BSF    03.5
0157:  BSF    03.6
0158:  BSF    0C.7
0159:  BSF    0C.0
015A:  NOP
015B:  NOP
015C:  BCF    03.5
015D:  BCF    03.6
015E:  BTFSC  3C.7
015F:  BSF    0B.7
0160:  BSF    03.6
0161:  MOVF   0C,W
0162:  ANDLW  7F
0163:  BTFSC  03.2
0164:  GOTO   1A9
0165:  BCF    03.6
0166:  MOVWF  3C
0167:  BSF    03.6
0168:  MOVF   0D,W
0169:  BCF    03.6
016A:  MOVWF  3D
016B:  BSF    03.6
016C:  MOVF   0F,W
016D:  BCF    03.6
016E:  MOVWF  3E
016F:  MOVF   3C,W
0170:  BTFSS  0C.4
0171:  GOTO   170
0172:  MOVWF  19
0173:  MOVF   3D,W
0174:  BSF    03.6
0175:  MOVWF  0D
0176:  BCF    03.6
0177:  MOVF   3E,W
0178:  BSF    03.6
0179:  MOVWF  0F
017A:  BCF    03.6
017B:  MOVF   0B,W
017C:  MOVWF  3F
017D:  BCF    0B.7
017E:  BSF    03.5
017F:  BSF    03.6
0180:  BSF    0C.7
0181:  BSF    0C.0
0182:  NOP
0183:  NOP
0184:  BCF    03.5
0185:  BCF    03.6
0186:  BTFSC  3F.7
0187:  BSF    0B.7
0188:  BSF    03.6
0189:  RLF    0C,W
018A:  RLF    0E,W
018B:  ANDLW  7F
018C:  BTFSC  03.2
018D:  GOTO   1A9
018E:  BCF    03.6
018F:  MOVWF  3C
0190:  BSF    03.6
0191:  MOVF   0D,W
0192:  BCF    03.6
0193:  MOVWF  3D
0194:  BSF    03.6
0195:  MOVF   0F,W
0196:  BCF    03.6
0197:  MOVWF  3E
0198:  MOVF   3C,W
0199:  BTFSS  0C.4
019A:  GOTO   199
019B:  MOVWF  19
019C:  MOVF   3D,W
019D:  BSF    03.6
019E:  MOVWF  0D
019F:  BCF    03.6
01A0:  MOVF   3E,W
01A1:  BSF    03.6
01A2:  MOVWF  0F
01A3:  INCF   0D,F
01A4:  BTFSC  03.2
01A5:  INCF   0F,F
01A6:  BCF    03.6
01A7:  GOTO   153
01A8:  BSF    03.6
01A9:  BCF    03.6
01AA:  BSF    0A.3
01AB:  BCF    0A.4
01AC:  GOTO   2C1 (RETURN)
01AD:  MOVLW  8E
01AE:  MOVWF  77
01AF:  MOVF   3D,W
01B0:  MOVWF  78
01B1:  MOVF   3C,W
01B2:  MOVWF  79
01B3:  CLRF   7A
01B4:  MOVF   78,F
01B5:  BTFSS  03.2
01B6:  GOTO   1C1
01B7:  MOVF   79,W
01B8:  MOVWF  78
01B9:  CLRF   79
01BA:  MOVLW  08
01BB:  SUBWF  77,F
01BC:  MOVF   78,F
01BD:  BTFSS  03.2
01BE:  GOTO   1C1
01BF:  CLRF   77
01C0:  GOTO   1C9
01C1:  BCF    03.0
01C2:  BTFSC  78.7
01C3:  GOTO   1C8
01C4:  RLF    79,F
01C5:  RLF    78,F
01C6:  DECF   77,F
01C7:  GOTO   1C1
01C8:  BCF    78.7
01C9:  BSF    0A.3
01CA:  BCF    0A.4
01CB:  GOTO   2D3 (RETURN)
01CC:  MOVF   40,W
01CD:  BTFSC  03.2
01CE:  GOTO   291
01CF:  MOVWF  4C
01D0:  MOVF   44,W
01D1:  BTFSC  03.2
01D2:  GOTO   291
01D3:  SUBWF  4C,F
01D4:  BTFSS  03.0
01D5:  GOTO   1DB
01D6:  MOVLW  7F
01D7:  ADDWF  4C,F
01D8:  BTFSC  03.0
01D9:  GOTO   291
01DA:  GOTO   1E1
01DB:  MOVLW  81
01DC:  SUBWF  4C,F
01DD:  BTFSS  03.0
01DE:  GOTO   291
01DF:  BTFSC  03.2
01E0:  GOTO   291
01E1:  MOVF   4C,W
01E2:  MOVWF  77
01E3:  CLRF   78
01E4:  CLRF   79
01E5:  CLRF   7A
01E6:  CLRF   4B
01E7:  MOVF   41,W
01E8:  MOVWF  4A
01E9:  BSF    4A.7
01EA:  MOVF   42,W
01EB:  MOVWF  49
01EC:  MOVF   43,W
01ED:  MOVWF  48
01EE:  MOVLW  19
01EF:  MOVWF  4C
01F0:  MOVF   47,W
01F1:  SUBWF  48,F
01F2:  BTFSC  03.0
01F3:  GOTO   204
01F4:  MOVLW  01
01F5:  SUBWF  49,F
01F6:  BTFSC  03.0
01F7:  GOTO   204
01F8:  SUBWF  4A,F
01F9:  BTFSC  03.0
01FA:  GOTO   204
01FB:  SUBWF  4B,F
01FC:  BTFSC  03.0
01FD:  GOTO   204
01FE:  INCF   4B,F
01FF:  INCF   4A,F
0200:  INCF   49,F
0201:  MOVF   47,W
0202:  ADDWF  48,F
0203:  GOTO   236
0204:  MOVF   46,W
0205:  SUBWF  49,F
0206:  BTFSC  03.0
0207:  GOTO   21F
0208:  MOVLW  01
0209:  SUBWF  4A,F
020A:  BTFSC  03.0
020B:  GOTO   21F
020C:  SUBWF  4B,F
020D:  BTFSC  03.0
020E:  GOTO   21F
020F:  INCF   4B,F
0210:  INCF   4A,F
0211:  MOVF   46,W
0212:  ADDWF  49,F
0213:  MOVF   47,W
0214:  ADDWF  48,F
0215:  BTFSS  03.0
0216:  GOTO   236
0217:  INCF   49,F
0218:  BTFSS  03.2
0219:  GOTO   236
021A:  INCF   4A,F
021B:  BTFSS  03.2
021C:  GOTO   236
021D:  INCF   4B,F
021E:  GOTO   236
021F:  MOVF   45,W
0220:  IORLW  80
0221:  SUBWF  4A,F
0222:  BTFSC  03.0
0223:  GOTO   235
0224:  MOVLW  01
0225:  SUBWF  4B,F
0226:  BTFSC  03.0
0227:  GOTO   235
0228:  INCF   4B,F
0229:  MOVF   45,W
022A:  IORLW  80
022B:  ADDWF  4A,F
022C:  MOVF   46,W
022D:  ADDWF  49,F
022E:  BTFSS  03.0
022F:  GOTO   213
0230:  INCF   4A,F
0231:  BTFSS  03.2
0232:  GOTO   213
0233:  INCF   4B,F
0234:  GOTO   213
0235:  BSF    7A.0
0236:  DECFSZ 4C,F
0237:  GOTO   239
0238:  GOTO   244
0239:  BCF    03.0
023A:  RLF    48,F
023B:  RLF    49,F
023C:  RLF    4A,F
023D:  RLF    4B,F
023E:  BCF    03.0
023F:  RLF    7A,F
0240:  RLF    79,F
0241:  RLF    78,F
0242:  RLF    4D,F
0243:  GOTO   1F0
0244:  BTFSS  4D.0
0245:  GOTO   24C
0246:  BCF    03.0
0247:  RRF    78,F
0248:  RRF    79,F
0249:  RRF    7A,F
024A:  RRF    4D,F
024B:  GOTO   24F
024C:  DECF   77,F
024D:  BTFSC  03.2
024E:  GOTO   291
024F:  BTFSC  4D.7
0250:  GOTO   278
0251:  BCF    03.0
0252:  RLF    48,F
0253:  RLF    49,F
0254:  RLF    4A,F
0255:  RLF    4B,F
0256:  MOVF   47,W
0257:  SUBWF  48,F
0258:  BTFSC  03.0
0259:  GOTO   264
025A:  MOVLW  01
025B:  SUBWF  49,F
025C:  BTFSC  03.0
025D:  GOTO   264
025E:  SUBWF  4A,F
025F:  BTFSC  03.0
0260:  GOTO   264
0261:  SUBWF  4B,F
0262:  BTFSS  03.0
0263:  GOTO   287
0264:  MOVF   46,W
0265:  SUBWF  49,F
0266:  BTFSC  03.0
0267:  GOTO   26F
0268:  MOVLW  01
0269:  SUBWF  4A,F
026A:  BTFSC  03.0
026B:  GOTO   26F
026C:  SUBWF  4B,F
026D:  BTFSS  03.0
026E:  GOTO   287
026F:  MOVF   45,W
0270:  IORLW  80
0271:  SUBWF  4A,F
0272:  BTFSC  03.0
0273:  GOTO   278
0274:  MOVLW  01
0275:  SUBWF  4B,F
0276:  BTFSS  03.0
0277:  GOTO   287
0278:  INCF   7A,F
0279:  BTFSS  03.2
027A:  GOTO   287
027B:  INCF   79,F
027C:  BTFSS  03.2
027D:  GOTO   287
027E:  INCF   78,F
027F:  BTFSS  03.2
0280:  GOTO   287
0281:  INCF   77,F
0282:  BTFSC  03.2
0283:  GOTO   291
0284:  RRF    78,F
0285:  RRF    79,F
0286:  RRF    7A,F
0287:  MOVF   41,W
0288:  MOVWF  4C
0289:  MOVF   45,W
028A:  XORWF  4C,F
028B:  BTFSS  4C.7
028C:  GOTO   28F
028D:  BSF    78.7
028E:  GOTO   295
028F:  BCF    78.7
0290:  GOTO   295
0291:  CLRF   77
0292:  CLRF   78
0293:  CLRF   79
0294:  CLRF   7A
0295:  BSF    0A.3
0296:  BCF    0A.4
0297:  GOTO   2EB (RETURN)
0298:  MOVLW  80
0299:  BTFSC  03.1
029A:  XORWF  41,F
029B:  CLRF   46
029C:  CLRF   47
029D:  MOVF   3D,W
029E:  MOVWF  45
029F:  MOVF   41,W
02A0:  XORWF  45,F
02A1:  MOVF   3C,W
02A2:  BTFSC  03.2
02A3:  GOTO   388
02A4:  MOVWF  44
02A5:  MOVWF  77
02A6:  MOVF   40,W
02A7:  BTFSC  03.2
02A8:  GOTO   391
02A9:  SUBWF  44,F
02AA:  BTFSC  03.2
02AB:  GOTO   32D
02AC:  BTFSS  03.0
02AD:  GOTO   2EB
02AE:  MOVF   41,W
02AF:  MOVWF  4A
02B0:  BSF    4A.7
02B1:  MOVF   42,W
02B2:  MOVWF  49
02B3:  MOVF   43,W
02B4:  MOVWF  48
02B5:  CLRF   47
02B6:  BCF    03.0
02B7:  RRF    4A,F
02B8:  RRF    49,F
02B9:  RRF    48,F
02BA:  RRF    47,F
02BB:  DECFSZ 44,F
02BC:  GOTO   2B5
02BD:  BTFSS  45.7
02BE:  GOTO   2C2
02BF:  BSF    46.0
02C0:  GOTO   3A5
02C1:  BCF    46.0
02C2:  BCF    44.0
02C3:  BSF    46.4
02C4:  MOVLW  3F
02C5:  MOVWF  04
02C6:  BCF    03.7
02C7:  GOTO   3BA
02C8:  BCF    46.4
02C9:  BTFSC  45.7
02CA:  GOTO   2D5
02CB:  BTFSS  44.0
02CC:  GOTO   2E0
02CD:  RRF    4A,F
02CE:  RRF    49,F
02CF:  RRF    48,F
02D0:  RRF    47,F
02D1:  INCF   77,F
02D2:  BTFSC  03.2
02D3:  GOTO   3A0
02D4:  GOTO   2E0
02D5:  BTFSC  4A.7
02D6:  GOTO   2E3
02D7:  BCF    03.0
02D8:  RLF    47,F
02D9:  RLF    48,F
02DA:  RLF    49,F
02DB:  RLF    4A,F
02DC:  DECF   77,F
02DD:  BTFSC  03.2
02DE:  GOTO   3A0
02DF:  GOTO   2D5
02E0:  BSF    46.6
02E1:  GOTO   34D
02E2:  BCF    46.6
02E3:  MOVF   3D,W
02E4:  MOVWF  45
02E5:  BTFSS  45.7
02E6:  GOTO   2E9
02E7:  BSF    4A.7
02E8:  GOTO   399
02E9:  BCF    4A.7
02EA:  GOTO   399
02EB:  MOVF   40,W
02EC:  MOVWF  44
02ED:  MOVWF  77
02EE:  MOVF   3C,W
02EF:  SUBWF  44,F
02F0:  MOVF   3D,W
02F1:  MOVWF  4A
02F2:  BSF    4A.7
02F3:  MOVF   3E,W
02F4:  MOVWF  49
02F5:  MOVF   3F,W
02F6:  MOVWF  48
02F7:  CLRF   47
02F8:  BCF    03.0
02F9:  RRF    4A,F
02FA:  RRF    49,F
02FB:  RRF    48,F
02FC:  RRF    47,F
02FD:  DECFSZ 44,F
02FE:  GOTO   2F7
02FF:  BTFSS  45.7
0300:  GOTO   304
0301:  BSF    46.1
0302:  GOTO   3A5
0303:  BCF    46.1
0304:  BCF    44.0
0305:  BSF    46.5
0306:  MOVLW  43
0307:  MOVWF  04
0308:  BCF    03.7
0309:  GOTO   3BA
030A:  BCF    46.5
030B:  BTFSC  45.7
030C:  GOTO   317
030D:  BTFSS  44.0
030E:  GOTO   322
030F:  RRF    4A,F
0310:  RRF    49,F
0311:  RRF    48,F
0312:  RRF    47,F
0313:  INCF   77,F
0314:  BTFSC  03.2
0315:  GOTO   3A0
0316:  GOTO   322
0317:  BTFSC  4A.7
0318:  GOTO   325
0319:  BCF    03.0
031A:  RLF    47,F
031B:  RLF    48,F
031C:  RLF    49,F
031D:  RLF    4A,F
031E:  DECF   77,F
031F:  BTFSC  03.2
0320:  GOTO   3A0
0321:  GOTO   317
0322:  BSF    46.7
0323:  GOTO   34D
0324:  BCF    46.7
0325:  MOVF   41,W
0326:  MOVWF  45
0327:  BTFSS  45.7
0328:  GOTO   32B
0329:  BSF    4A.7
032A:  GOTO   399
032B:  BCF    4A.7
032C:  GOTO   399
032D:  MOVF   41,W
032E:  MOVWF  4A
032F:  BSF    4A.7
0330:  MOVF   42,W
0331:  MOVWF  49
0332:  MOVF   43,W
0333:  MOVWF  48
0334:  BTFSS  45.7
0335:  GOTO   33A
0336:  BCF    4A.7
0337:  BSF    46.2
0338:  GOTO   3A5
0339:  BCF    46.2
033A:  CLRF   47
033B:  BCF    44.0
033C:  MOVLW  3F
033D:  MOVWF  04
033E:  BCF    03.7
033F:  GOTO   3BA
0340:  BTFSC  45.7
0341:  GOTO   363
0342:  MOVF   3D,W
0343:  MOVWF  45
0344:  BTFSS  44.0
0345:  GOTO   34D
0346:  RRF    4A,F
0347:  RRF    49,F
0348:  RRF    48,F
0349:  RRF    47,F
034A:  INCF   77,F
034B:  BTFSC  03.2
034C:  GOTO   3A0
034D:  BTFSS  47.7
034E:  GOTO   35E
034F:  INCF   48,F
0350:  BTFSS  03.2
0351:  GOTO   35E
0352:  INCF   49,F
0353:  BTFSS  03.2
0354:  GOTO   35E
0355:  INCF   4A,F
0356:  BTFSS  03.2
0357:  GOTO   35E
0358:  RRF    4A,F
0359:  RRF    49,F
035A:  RRF    48,F
035B:  INCF   77,F
035C:  BTFSC  03.2
035D:  GOTO   3A0
035E:  BTFSC  46.6
035F:  GOTO   2E2
0360:  BTFSC  46.7
0361:  GOTO   324
0362:  GOTO   382
0363:  MOVLW  80
0364:  XORWF  4A,F
0365:  BTFSS  4A.7
0366:  GOTO   36B
0367:  GOTO   3A5
0368:  MOVF   41,W
0369:  MOVWF  45
036A:  GOTO   378
036B:  MOVF   3D,W
036C:  MOVWF  45
036D:  MOVF   4A,F
036E:  BTFSS  03.2
036F:  GOTO   378
0370:  MOVF   49,F
0371:  BTFSS  03.2
0372:  GOTO   378
0373:  MOVF   48,F
0374:  BTFSS  03.2
0375:  GOTO   378
0376:  CLRF   77
0377:  GOTO   399
0378:  BTFSC  4A.7
0379:  GOTO   382
037A:  BCF    03.0
037B:  RLF    47,F
037C:  RLF    48,F
037D:  RLF    49,F
037E:  RLF    4A,F
037F:  DECFSZ 77,F
0380:  GOTO   378
0381:  GOTO   3A0
0382:  BTFSS  45.7
0383:  GOTO   386
0384:  BSF    4A.7
0385:  GOTO   399
0386:  BCF    4A.7
0387:  GOTO   399
0388:  MOVF   40,W
0389:  MOVWF  77
038A:  MOVF   41,W
038B:  MOVWF  4A
038C:  MOVF   42,W
038D:  MOVWF  49
038E:  MOVF   43,W
038F:  MOVWF  48
0390:  GOTO   399
0391:  MOVF   3C,W
0392:  MOVWF  77
0393:  MOVF   3D,W
0394:  MOVWF  4A
0395:  MOVF   3E,W
0396:  MOVWF  49
0397:  MOVF   3F,W
0398:  MOVWF  48
0399:  MOVF   4A,W
039A:  MOVWF  78
039B:  MOVF   49,W
039C:  MOVWF  79
039D:  MOVF   48,W
039E:  MOVWF  7A
039F:  GOTO   3D8
03A0:  CLRF   77
03A1:  CLRF   78
03A2:  CLRF   79
03A3:  CLRF   7A
03A4:  GOTO   3D8
03A5:  CLRF   47
03A6:  COMF   48,F
03A7:  COMF   49,F
03A8:  COMF   4A,F
03A9:  COMF   47,F
03AA:  INCF   47,F
03AB:  BTFSS  03.2
03AC:  GOTO   3B3
03AD:  INCF   48,F
03AE:  BTFSS  03.2
03AF:  GOTO   3B3
03B0:  INCF   49,F
03B1:  BTFSC  03.2
03B2:  INCF   4A,F
03B3:  BTFSC  46.0
03B4:  GOTO   2C1
03B5:  BTFSC  46.1
03B6:  GOTO   303
03B7:  BTFSC  46.2
03B8:  GOTO   339
03B9:  GOTO   368
03BA:  MOVF   00,W
03BB:  ADDWF  48,F
03BC:  BTFSS  03.0
03BD:  GOTO   3C4
03BE:  INCF   49,F
03BF:  BTFSS  03.2
03C0:  GOTO   3C4
03C1:  INCF   4A,F
03C2:  BTFSC  03.2
03C3:  BSF    44.0
03C4:  DECF   04,F
03C5:  MOVF   00,W
03C6:  ADDWF  49,F
03C7:  BTFSS  03.0
03C8:  GOTO   3CC
03C9:  INCF   4A,F
03CA:  BTFSC  03.2
03CB:  BSF    44.0
03CC:  DECF   04,F
03CD:  MOVF   00,W
03CE:  BTFSS  00.7
03CF:  XORLW  80
03D0:  ADDWF  4A,F
03D1:  BTFSC  03.0
03D2:  BSF    44.0
03D3:  BTFSC  46.4
03D4:  GOTO   2C8
03D5:  BTFSC  46.5
03D6:  GOTO   30A
03D7:  GOTO   340
03D8:  RETURN
03D9:  MOVF   41,W
03DA:  MOVWF  48
03DB:  MOVF   45,W
03DC:  XORWF  48,F
03DD:  BTFSS  48.7
03DE:  GOTO   3E4
03DF:  BCF    03.2
03E0:  BCF    03.0
03E1:  BTFSC  41.7
03E2:  BSF    03.0
03E3:  GOTO   417
03E4:  MOVF   41,W
03E5:  MOVWF  48
03E6:  MOVF   44,W
03E7:  MOVWF  49
03E8:  MOVF   40,W
03E9:  SUBWF  49,F
03EA:  BTFSC  03.2
03EB:  GOTO   3F2
03EC:  BTFSS  48.7
03ED:  GOTO   417
03EE:  MOVF   03,W
03EF:  XORLW  01
03F0:  MOVWF  03
03F1:  GOTO   417
03F2:  MOVF   45,W
03F3:  MOVWF  49
03F4:  MOVF   41,W
03F5:  SUBWF  49,F
03F6:  BTFSC  03.2
03F7:  GOTO   3FE
03F8:  BTFSS  48.7
03F9:  GOTO   417
03FA:  MOVF   03,W
03FB:  XORLW  01
03FC:  MOVWF  03
03FD:  GOTO   417
03FE:  MOVF   46,W
03FF:  MOVWF  49
0400:  MOVF   42,W
0401:  SUBWF  49,F
0402:  BTFSC  03.2
0403:  GOTO   40A
0404:  BTFSS  48.7
0405:  GOTO   417
0406:  MOVF   03,W
0407:  XORLW  01
0408:  MOVWF  03
0409:  GOTO   417
040A:  MOVF   47,W
040B:  MOVWF  49
040C:  MOVF   43,W
040D:  SUBWF  49,F
040E:  BTFSC  03.2
040F:  GOTO   416
0410:  BTFSS  48.7
0411:  GOTO   417
0412:  MOVF   03,W
0413:  XORLW  01
0414:  MOVWF  03
0415:  GOTO   417
0416:  BCF    03.0
0417:  RETURN
*
0456:  MOVF   0B,W
0457:  MOVWF  3E
0458:  BCF    0B.7
0459:  BSF    03.5
045A:  BSF    03.6
045B:  BSF    0C.7
045C:  BSF    0C.0
045D:  NOP
045E:  NOP
045F:  BCF    03.5
0460:  BCF    03.6
0461:  BTFSC  3E.7
0462:  BSF    0B.7
0463:  BTFSC  03.0
0464:  GOTO   48D
0465:  BSF    03.6
0466:  MOVF   0C,W
0467:  ANDLW  7F
0468:  BCF    03.6
0469:  MOVWF  3E
046A:  BSF    03.6
046B:  MOVF   0D,W
046C:  BCF    03.6
046D:  MOVWF  3F
046E:  BSF    03.6
046F:  MOVF   0F,W
0470:  BCF    03.6
0471:  MOVWF  40
0472:  MOVF   3E,W
0473:  MOVWF  4A
0474:  CALL   42A
0475:  MOVF   3F,W
0476:  BSF    03.6
0477:  MOVWF  0D
0478:  BCF    03.6
0479:  MOVF   40,W
047A:  BSF    03.6
047B:  MOVWF  0F
047C:  BCF    03.6
047D:  MOVF   0B,W
047E:  MOVWF  41
047F:  BCF    0B.7
0480:  BSF    03.5
0481:  BSF    03.6
0482:  BSF    0C.7
0483:  BSF    0C.0
0484:  NOP
0485:  NOP
0486:  BCF    03.5
0487:  BCF    03.6
0488:  BTFSC  41.7
0489:  BSF    0B.7
048A:  DECFSZ 3D,F
048B:  GOTO   48D
048C:  GOTO   4AC
048D:  BSF    03.6
048E:  RLF    0C,W
048F:  RLF    0E,W
0490:  ANDLW  7F
0491:  BCF    03.6
0492:  MOVWF  3E
0493:  BSF    03.6
0494:  MOVF   0D,W
0495:  BCF    03.6
0496:  MOVWF  3F
0497:  BSF    03.6
0498:  MOVF   0F,W
0499:  BCF    03.6
049A:  MOVWF  40
049B:  MOVF   3E,W
049C:  MOVWF  4A
049D:  CALL   42A
049E:  MOVF   3F,W
049F:  BSF    03.6
04A0:  MOVWF  0D
04A1:  BCF    03.6
04A2:  MOVF   40,W
04A3:  BSF    03.6
04A4:  MOVWF  0F
04A5:  INCF   0D,F
04A6:  BTFSC  03.2
04A7:  INCF   0F,F
04A8:  BCF    03.0
04A9:  BCF    03.6
04AA:  DECFSZ 3D,F
04AB:  GOTO   456
04AC:  RETURN
04AD:  MOVF   4A,W
04AE:  BTFSC  03.2
04AF:  GOTO   51D
04B0:  MOVWF  52
04B1:  MOVF   4E,W
04B2:  BTFSC  03.2
04B3:  GOTO   51D
04B4:  ADDWF  52,F
04B5:  BTFSC  03.0
04B6:  GOTO   4BE
04B7:  MOVLW  7F
04B8:  SUBWF  52,F
04B9:  BTFSS  03.0
04BA:  GOTO   51D
04BB:  BTFSC  03.2
04BC:  GOTO   51D
04BD:  GOTO   4C2
04BE:  MOVLW  81
04BF:  ADDWF  52,F
04C0:  BTFSC  03.0
04C1:  GOTO   51D
04C2:  MOVF   52,W
04C3:  MOVWF  77
04C4:  CLRF   78
04C5:  CLRF   79
04C6:  CLRF   7A
04C7:  MOVF   4B,W
04C8:  MOVWF  56
04C9:  BSF    56.7
04CA:  MOVF   4C,W
04CB:  MOVWF  55
04CC:  MOVF   4D,W
04CD:  MOVWF  54
04CE:  MOVLW  18
04CF:  MOVWF  52
04D0:  CLRF   53
04D1:  BTFSS  54.0
04D2:  GOTO   4EB
04D3:  MOVF   51,W
04D4:  ADDWF  7A,F
04D5:  BTFSS  03.0
04D6:  GOTO   4DD
04D7:  INCF   79,F
04D8:  BTFSS  03.2
04D9:  GOTO   4DD
04DA:  INCF   78,F
04DB:  BTFSC  03.2
04DC:  BSF    53.7
04DD:  MOVF   50,W
04DE:  ADDWF  79,F
04DF:  BTFSS  03.0
04E0:  GOTO   4E4
04E1:  INCF   78,F
04E2:  BTFSC  03.2
04E3:  BSF    53.7
04E4:  MOVF   4F,W
04E5:  MOVWF  4C
04E6:  BSF    4C.7
04E7:  MOVF   4C,W
04E8:  ADDWF  78,F
04E9:  BTFSC  03.0
04EA:  BSF    53.7
04EB:  RLF    53,F
04EC:  RRF    78,F
04ED:  RRF    79,F
04EE:  RRF    7A,F
04EF:  RRF    56,F
04F0:  RRF    55,F
04F1:  RRF    54,F
04F2:  BCF    03.0
04F3:  DECFSZ 52,F
04F4:  GOTO   4D0
04F5:  MOVLW  01
04F6:  ADDWF  77,F
04F7:  BTFSC  03.0
04F8:  GOTO   51D
04F9:  BTFSC  78.7
04FA:  GOTO   502
04FB:  RLF    56,F
04FC:  RLF    7A,F
04FD:  RLF    79,F
04FE:  RLF    78,F
04FF:  DECF   77,F
0500:  BTFSC  03.2
0501:  GOTO   51D
0502:  BTFSS  56.7
0503:  GOTO   513
0504:  INCF   7A,F
0505:  BTFSS  03.2
0506:  GOTO   513
0507:  INCF   79,F
0508:  BTFSS  03.2
0509:  GOTO   513
050A:  INCF   78,F
050B:  BTFSS  03.2
050C:  GOTO   513
050D:  RRF    78,F
050E:  RRF    79,F
050F:  RRF    7A,F
0510:  INCF   77,F
0511:  BTFSC  03.2
0512:  GOTO   51D
0513:  MOVF   4B,W
0514:  MOVWF  53
0515:  MOVF   4F,W
0516:  XORWF  53,F
0517:  BTFSS  53.7
0518:  GOTO   51B
0519:  BSF    78.7
051A:  GOTO   521
051B:  BCF    78.7
051C:  GOTO   521
051D:  CLRF   77
051E:  CLRF   78
051F:  CLRF   79
0520:  CLRF   7A
0521:  RETURN
0522:  MOVF   4A,W
0523:  SUBLW  B6
0524:  MOVWF  4A
0525:  CLRF   7A
0526:  MOVF   4B,W
0527:  MOVWF  4E
0528:  BSF    4B.7
0529:  BCF    03.0
052A:  RRF    4B,F
052B:  RRF    4C,F
052C:  RRF    4D,F
052D:  RRF    7A,F
052E:  RRF    79,F
052F:  RRF    78,F
0530:  RRF    77,F
0531:  DECFSZ 4A,F
0532:  GOTO   529
0533:  BTFSS  4E.7
0534:  GOTO   540
0535:  COMF   77,F
0536:  COMF   78,F
0537:  COMF   79,F
0538:  COMF   7A,F
0539:  INCF   77,F
053A:  BTFSC  03.2
053B:  INCF   78,F
053C:  BTFSC  03.2
053D:  INCF   79,F
053E:  BTFSC  03.2
053F:  INCF   7A,F
0540:  RETURN
0541:  BTFSC  03.1
0542:  GOTO   546
0543:  MOVLW  52
0544:  MOVWF  04
0545:  BCF    03.7
0546:  CLRF   77
0547:  CLRF   78
0548:  CLRF   79
0549:  CLRF   7A
054A:  CLRF   52
054B:  CLRF   53
054C:  CLRF   54
054D:  CLRF   55
054E:  MOVF   51,W
054F:  IORWF  50,W
0550:  IORWF  4F,W
0551:  IORWF  4E,W
0552:  BTFSC  03.2
0553:  GOTO   584
0554:  MOVLW  20
0555:  MOVWF  56
0556:  BCF    03.0
0557:  RLF    4A,F
0558:  RLF    4B,F
0559:  RLF    4C,F
055A:  RLF    4D,F
055B:  RLF    52,F
055C:  RLF    53,F
055D:  RLF    54,F
055E:  RLF    55,F
055F:  MOVF   51,W
0560:  SUBWF  55,W
0561:  BTFSS  03.2
0562:  GOTO   56D
0563:  MOVF   50,W
0564:  SUBWF  54,W
0565:  BTFSS  03.2
0566:  GOTO   56D
0567:  MOVF   4F,W
0568:  SUBWF  53,W
0569:  BTFSS  03.2
056A:  GOTO   56D
056B:  MOVF   4E,W
056C:  SUBWF  52,W
056D:  BTFSS  03.0
056E:  GOTO   57E
056F:  MOVF   4E,W
0570:  SUBWF  52,F
0571:  MOVF   4F,W
0572:  BTFSS  03.0
0573:  INCFSZ 4F,W
0574:  SUBWF  53,F
0575:  MOVF   50,W
0576:  BTFSS  03.0
0577:  INCFSZ 50,W
0578:  SUBWF  54,F
0579:  MOVF   51,W
057A:  BTFSS  03.0
057B:  INCFSZ 51,W
057C:  SUBWF  55,F
057D:  BSF    03.0
057E:  RLF    77,F
057F:  RLF    78,F
0580:  RLF    79,F
0581:  RLF    7A,F
0582:  DECFSZ 56,F
0583:  GOTO   556
0584:  MOVF   52,W
0585:  MOVWF  00
0586:  INCF   04,F
0587:  MOVF   53,W
0588:  MOVWF  00
0589:  INCF   04,F
058A:  MOVF   54,W
058B:  MOVWF  00
058C:  INCF   04,F
058D:  MOVF   55,W
058E:  MOVWF  00
058F:  RETURN
0590:  MOVF   04,W
0591:  MOVWF  42
0592:  MOVF   41,W
0593:  MOVWF  44
0594:  BTFSC  03.2
0595:  GOTO   5AF
0596:  MOVF   40,W
0597:  MOVWF  4D
0598:  MOVF   3F,W
0599:  MOVWF  4C
059A:  MOVF   3E,W
059B:  MOVWF  4B
059C:  MOVF   3D,W
059D:  MOVWF  4A
059E:  CLRF   51
059F:  CLRF   50
05A0:  MOVLW  20
05A1:  MOVWF  4F
05A2:  MOVLW  82
05A3:  MOVWF  4E
05A4:  CALL   4AD
05A5:  MOVF   7A,W
05A6:  MOVWF  40
05A7:  MOVF   79,W
05A8:  MOVWF  3F
05A9:  MOVF   78,W
05AA:  MOVWF  3E
05AB:  MOVF   77,W
05AC:  MOVWF  3D
05AD:  DECFSZ 44,F
05AE:  GOTO   596
05AF:  MOVF   40,W
05B0:  MOVWF  4D
05B1:  MOVF   3F,W
05B2:  MOVWF  4C
05B3:  MOVF   3E,W
05B4:  MOVWF  4B
05B5:  MOVF   3D,W
05B6:  MOVWF  4A
05B7:  CALL   522
05B8:  MOVF   7A,W
05B9:  MOVWF  40
05BA:  MOVF   79,W
05BB:  MOVWF  3F
05BC:  MOVF   78,W
05BD:  MOVWF  3E
05BE:  MOVF   77,W
05BF:  MOVWF  3D
05C0:  BTFSS  40.7
05C1:  GOTO   5CF
05C2:  DECF   42,F
05C3:  BSF    42.5
05C4:  COMF   3D,F
05C5:  COMF   3E,F
05C6:  COMF   3F,F
05C7:  COMF   40,F
05C8:  INCF   3D,F
05C9:  BTFSC  03.2
05CA:  INCF   3E,F
05CB:  BTFSC  03.2
05CC:  INCF   3F,F
05CD:  BTFSC  03.2
05CE:  INCF   40,F
05CF:  MOVLW  3B
05D0:  MOVWF  49
05D1:  MOVLW  9A
05D2:  MOVWF  48
05D3:  MOVLW  CA
05D4:  MOVWF  47
05D5:  CLRF   46
05D6:  MOVLW  0A
05D7:  MOVWF  44
05D8:  MOVF   41,W
05D9:  BTFSC  03.2
05DA:  INCF   42,F
05DB:  BSF    03.1
05DC:  MOVLW  3D
05DD:  MOVWF  04
05DE:  BCF    03.7
05DF:  MOVF   40,W
05E0:  MOVWF  4D
05E1:  MOVF   3F,W
05E2:  MOVWF  4C
05E3:  MOVF   3E,W
05E4:  MOVWF  4B
05E5:  MOVF   3D,W
05E6:  MOVWF  4A
05E7:  MOVF   49,W
05E8:  MOVWF  51
05E9:  MOVF   48,W
05EA:  MOVWF  50
05EB:  MOVF   47,W
05EC:  MOVWF  4F
05ED:  MOVF   46,W
05EE:  MOVWF  4E
05EF:  CALL   541
05F0:  MOVF   78,W
05F1:  MOVF   77,F
05F2:  BTFSS  03.2
05F3:  GOTO   607
05F4:  INCF   41,W
05F5:  SUBWF  44,W
05F6:  BTFSC  03.2
05F7:  GOTO   607
05F8:  MOVF   42,W
05F9:  BTFSC  03.2
05FA:  GOTO   609
05FB:  ANDLW  0F
05FC:  SUBWF  44,W
05FD:  BTFSC  03.2
05FE:  GOTO   601
05FF:  BTFSC  03.0
0600:  GOTO   639
0601:  BTFSC  42.7
0602:  GOTO   639
0603:  BTFSC  42.6
0604:  GOTO   609
0605:  MOVLW  20
0606:  GOTO   635
0607:  MOVLW  20
0608:  ANDWF  42,F
0609:  BTFSS  42.5
060A:  GOTO   617
060B:  BCF    42.5
060C:  MOVF   41,W
060D:  BTFSS  03.2
060E:  DECF   42,F
060F:  MOVF   77,W
0610:  MOVWF  42
0611:  MOVLW  2D
0612:  MOVWF  4A
0613:  CALL   42A
0614:  MOVF   42,W
0615:  MOVWF  77
0616:  CLRF   42
0617:  MOVF   41,W
0618:  SUBWF  44,W
0619:  BTFSS  03.2
061A:  GOTO   625
061B:  MOVF   77,W
061C:  MOVWF  42
061D:  MOVLW  2E
061E:  MOVWF  4A
061F:  CALL   42A
0620:  MOVF   42,W
0621:  MOVWF  77
0622:  MOVLW  20
0623:  ANDWF  42,F
0624:  MOVLW  00
0625:  MOVLW  30
0626:  BTFSS  42.5
0627:  GOTO   635
0628:  BCF    42.5
0629:  MOVF   41,W
062A:  BTFSS  03.2
062B:  DECF   42,F
062C:  MOVF   77,W
062D:  MOVWF  42
062E:  MOVLW  2D
062F:  MOVWF  4A
0630:  CALL   42A
0631:  MOVF   42,W
0632:  MOVWF  77
0633:  CLRF   42
0634:  MOVLW  30
0635:  ADDWF  77,F
0636:  MOVF   77,W
0637:  MOVWF  4A
0638:  CALL   42A
0639:  BCF    03.1
063A:  MOVF   49,W
063B:  MOVWF  4D
063C:  MOVF   48,W
063D:  MOVWF  4C
063E:  MOVF   47,W
063F:  MOVWF  4B
0640:  MOVF   46,W
0641:  MOVWF  4A
0642:  CLRF   51
0643:  CLRF   50
0644:  CLRF   4F
0645:  MOVLW  0A
0646:  MOVWF  4E
0647:  CALL   541
0648:  MOVF   7A,W
0649:  MOVWF  49
064A:  MOVF   79,W
064B:  MOVWF  48
064C:  MOVF   78,W
064D:  MOVWF  47
064E:  MOVF   77,W
064F:  MOVWF  46
0650:  DECFSZ 44,F
0651:  GOTO   5DB
0652:  RETURN
*
06A3:  CLRF   77
06A4:  CLRF   78
06A5:  MOVF   3E,W
06A6:  BCF    03.0
06A7:  BTFSC  3F.0
06A8:  ADDWF  77,F
06A9:  RRF    77,F
06AA:  RRF    78,F
06AB:  BTFSC  3F.1
06AC:  ADDWF  77,F
06AD:  RRF    77,F
06AE:  RRF    78,F
06AF:  BTFSC  3F.2
06B0:  ADDWF  77,F
06B1:  RRF    77,F
06B2:  RRF    78,F
06B3:  BTFSC  3F.3
06B4:  ADDWF  77,F
06B5:  RRF    77,F
06B6:  RRF    78,F
06B7:  BTFSC  3F.4
06B8:  ADDWF  77,F
06B9:  RRF    77,F
06BA:  RRF    78,F
06BB:  BTFSC  3F.5
06BC:  ADDWF  77,F
06BD:  RRF    77,F
06BE:  RRF    78,F
06BF:  BTFSC  3F.6
06C0:  ADDWF  77,F
06C1:  RRF    77,F
06C2:  RRF    78,F
06C3:  BTFSC  3F.7
06C4:  ADDWF  77,F
06C5:  RRF    77,F
06C6:  RRF    78,F
*
06DD:  MOVF   0B,W
06DE:  MOVWF  3D
06DF:  BCF    0B.7
06E0:  BSF    03.5
06E1:  BSF    03.6
06E2:  BSF    0C.7
06E3:  BSF    0C.0
06E4:  NOP
06E5:  NOP
06E6:  BCF    03.5
06E7:  BCF    03.6
06E8:  BTFSC  3D.7
06E9:  BSF    0B.7
06EA:  BSF    03.6
06EB:  MOVF   0C,W
06EC:  ANDLW  7F
06ED:  BTFSC  03.2
06EE:  GOTO   731
06EF:  BCF    03.6
06F0:  MOVWF  3D
06F1:  BSF    03.6
06F2:  MOVF   0D,W
06F3:  BCF    03.6
06F4:  MOVWF  3E
06F5:  BSF    03.6
06F6:  MOVF   0F,W
06F7:  BCF    03.6
06F8:  MOVWF  3F
06F9:  MOVF   3D,W
06FA:  MOVWF  4A
06FB:  CALL   42A
06FC:  MOVF   3E,W
06FD:  BSF    03.6
06FE:  MOVWF  0D
06FF:  BCF    03.6
0700:  MOVF   3F,W
0701:  BSF    03.6
0702:  MOVWF  0F
0703:  BCF    03.6
0704:  MOVF   0B,W
0705:  MOVWF  40
0706:  BCF    0B.7
0707:  BSF    03.5
0708:  BSF    03.6
0709:  BSF    0C.7
070A:  BSF    0C.0
070B:  NOP
070C:  NOP
070D:  BCF    03.5
070E:  BCF    03.6
070F:  BTFSC  40.7
0710:  BSF    0B.7
0711:  BSF    03.6
0712:  RLF    0C,W
0713:  RLF    0E,W
0714:  ANDLW  7F
0715:  BTFSC  03.2
0716:  GOTO   731
0717:  BCF    03.6
0718:  MOVWF  3D
0719:  BSF    03.6
071A:  MOVF   0D,W
071B:  BCF    03.6
071C:  MOVWF  3E
071D:  BSF    03.6
071E:  MOVF   0F,W
071F:  BCF    03.6
0720:  MOVWF  3F
0721:  MOVF   3D,W
0722:  MOVWF  4A
0723:  CALL   42A
0724:  MOVF   3E,W
0725:  BSF    03.6
0726:  MOVWF  0D
0727:  BCF    03.6
0728:  MOVF   3F,W
0729:  BSF    03.6
072A:  MOVWF  0F
072B:  INCF   0D,F
072C:  BTFSC  03.2
072D:  INCF   0F,F
072E:  BCF    03.6
072F:  GOTO   6DD
0730:  BSF    03.6
0731:  BCF    03.6
0732:  RETURN
0733:  MOVF   0B,W
0734:  MOVWF  3E
0735:  BCF    0B.7
0736:  BSF    03.5
0737:  BSF    03.6
0738:  BSF    0C.7
0739:  BSF    0C.0
073A:  NOP
073B:  NOP
073C:  BCF    03.5
073D:  BCF    03.6
073E:  BTFSC  3E.7
073F:  BSF    0B.7
0740:  BTFSC  03.0
0741:  GOTO   76B
0742:  BSF    03.6
0743:  MOVF   0C,W
0744:  ANDLW  7F
0745:  BCF    03.6
0746:  MOVWF  3E
0747:  BSF    03.6
0748:  MOVF   0D,W
0749:  BCF    03.6
074A:  MOVWF  3F
074B:  BSF    03.6
074C:  MOVF   0F,W
074D:  BCF    03.6
074E:  MOVWF  40
074F:  MOVF   3E,W
0750:  BTFSS  0C.4
0751:  GOTO   750
0752:  MOVWF  19
0753:  MOVF   3F,W
0754:  BSF    03.6
0755:  MOVWF  0D
0756:  BCF    03.6
0757:  MOVF   40,W
0758:  BSF    03.6
0759:  MOVWF  0F
075A:  BCF    03.6
075B:  MOVF   0B,W
075C:  MOVWF  41
075D:  BCF    0B.7
075E:  BSF    03.5
075F:  BSF    03.6
0760:  BSF    0C.7
0761:  BSF    0C.0
0762:  NOP
0763:  NOP
0764:  BCF    03.5
0765:  BCF    03.6
0766:  BTFSC  41.7
0767:  BSF    0B.7
0768:  DECFSZ 3D,F
0769:  GOTO   76B
076A:  GOTO   78B
076B:  BSF    03.6
076C:  RLF    0C,W
076D:  RLF    0E,W
076E:  ANDLW  7F
076F:  BCF    03.6
0770:  MOVWF  3E
0771:  BSF    03.6
0772:  MOVF   0D,W
0773:  BCF    03.6
0774:  MOVWF  3F
0775:  BSF    03.6
0776:  MOVF   0F,W
0777:  BCF    03.6
0778:  MOVWF  40
0779:  MOVF   3E,W
077A:  BTFSS  0C.4
077B:  GOTO   77A
077C:  MOVWF  19
077D:  MOVF   3F,W
077E:  BSF    03.6
077F:  MOVWF  0D
0780:  BCF    03.6
0781:  MOVF   40,W
0782:  BSF    03.6
0783:  MOVWF  0F
0784:  INCF   0D,F
0785:  BTFSC  03.2
0786:  INCF   0F,F
0787:  BCF    03.0
0788:  BCF    03.6
0789:  DECFSZ 3D,F
078A:  GOTO   733
078B:  RETURN
*
0800:  MOVF   04,W
0801:  MOVWF  42
0802:  MOVF   41,W
0803:  MOVWF  44
0804:  BTFSC  03.2
0805:  GOTO   021
0806:  MOVF   40,W
0807:  MOVWF  4D
0808:  MOVF   3F,W
0809:  MOVWF  4C
080A:  MOVF   3E,W
080B:  MOVWF  4B
080C:  MOVF   3D,W
080D:  MOVWF  4A
080E:  CLRF   51
080F:  CLRF   50
0810:  MOVLW  20
0811:  MOVWF  4F
0812:  MOVLW  82
0813:  MOVWF  4E
0814:  BCF    0A.3
0815:  CALL   4AD
0816:  BSF    0A.3
0817:  MOVF   7A,W
0818:  MOVWF  40
0819:  MOVF   79,W
081A:  MOVWF  3F
081B:  MOVF   78,W
081C:  MOVWF  3E
081D:  MOVF   77,W
081E:  MOVWF  3D
081F:  DECFSZ 44,F
0820:  GOTO   006
0821:  MOVF   40,W
0822:  MOVWF  4D
0823:  MOVF   3F,W
0824:  MOVWF  4C
0825:  MOVF   3E,W
0826:  MOVWF  4B
0827:  MOVF   3D,W
0828:  MOVWF  4A
0829:  BCF    0A.3
082A:  CALL   522
082B:  BSF    0A.3
082C:  MOVF   7A,W
082D:  MOVWF  40
082E:  MOVF   79,W
082F:  MOVWF  3F
0830:  MOVF   78,W
0831:  MOVWF  3E
0832:  MOVF   77,W
0833:  MOVWF  3D
0834:  BTFSS  40.7
0835:  GOTO   043
0836:  DECF   42,F
0837:  BSF    42.5
0838:  COMF   3D,F
0839:  COMF   3E,F
083A:  COMF   3F,F
083B:  COMF   40,F
083C:  INCF   3D,F
083D:  BTFSC  03.2
083E:  INCF   3E,F
083F:  BTFSC  03.2
0840:  INCF   3F,F
0841:  BTFSC  03.2
0842:  INCF   40,F
0843:  MOVLW  3B
0844:  MOVWF  49
0845:  MOVLW  9A
0846:  MOVWF  48
0847:  MOVLW  CA
0848:  MOVWF  47
0849:  CLRF   46
084A:  MOVLW  0A
084B:  MOVWF  44
084C:  MOVF   41,W
084D:  BTFSC  03.2
084E:  INCF   42,F
084F:  BSF    03.1
0850:  MOVLW  3D
0851:  MOVWF  04
0852:  BCF    03.7
0853:  MOVF   40,W
0854:  MOVWF  4D
0855:  MOVF   3F,W
0856:  MOVWF  4C
0857:  MOVF   3E,W
0858:  MOVWF  4B
0859:  MOVF   3D,W
085A:  MOVWF  4A
085B:  MOVF   49,W
085C:  MOVWF  51
085D:  MOVF   48,W
085E:  MOVWF  50
085F:  MOVF   47,W
0860:  MOVWF  4F
0861:  MOVF   46,W
0862:  MOVWF  4E
0863:  BCF    0A.3
0864:  CALL   541
0865:  BSF    0A.3
0866:  MOVF   78,W
0867:  MOVF   77,F
0868:  BTFSS  03.2
0869:  GOTO   07D
086A:  INCF   41,W
086B:  SUBWF  44,W
086C:  BTFSC  03.2
086D:  GOTO   07D
086E:  MOVF   42,W
086F:  BTFSC  03.2
0870:  GOTO   07F
0871:  ANDLW  0F
0872:  SUBWF  44,W
0873:  BTFSC  03.2
0874:  GOTO   077
0875:  BTFSC  03.0
0876:  GOTO   0B3
0877:  BTFSC  42.7
0878:  GOTO   0B3
0879:  BTFSC  42.6
087A:  GOTO   07F
087B:  MOVLW  20
087C:  GOTO   0AE
087D:  MOVLW  20
087E:  ANDWF  42,F
087F:  BTFSS  42.5
0880:  GOTO   08E
0881:  BCF    42.5
0882:  MOVF   41,W
0883:  BTFSS  03.2
0884:  DECF   42,F
0885:  MOVF   77,W
0886:  MOVWF  42
0887:  MOVLW  2D
0888:  BTFSS  0C.4
0889:  GOTO   088
088A:  MOVWF  19
088B:  MOVF   42,W
088C:  MOVWF  77
088D:  CLRF   42
088E:  MOVF   41,W
088F:  SUBWF  44,W
0890:  BTFSS  03.2
0891:  GOTO   09D
0892:  MOVF   77,W
0893:  MOVWF  42
0894:  MOVLW  2E
0895:  BTFSS  0C.4
0896:  GOTO   095
0897:  MOVWF  19
0898:  MOVF   42,W
0899:  MOVWF  77
089A:  MOVLW  20
089B:  ANDWF  42,F
089C:  MOVLW  00
089D:  MOVLW  30
089E:  BTFSS  42.5
089F:  GOTO   0AE
08A0:  BCF    42.5
08A1:  MOVF   41,W
08A2:  BTFSS  03.2
08A3:  DECF   42,F
08A4:  MOVF   77,W
08A5:  MOVWF  42
08A6:  MOVLW  2D
08A7:  BTFSS  0C.4
08A8:  GOTO   0A7
08A9:  MOVWF  19
08AA:  MOVF   42,W
08AB:  MOVWF  77
08AC:  CLRF   42
08AD:  MOVLW  30
08AE:  ADDWF  77,F
08AF:  MOVF   77,W
08B0:  BTFSS  0C.4
08B1:  GOTO   0B0
08B2:  MOVWF  19
08B3:  BCF    03.1
08B4:  MOVF   49,W
08B5:  MOVWF  4D
08B6:  MOVF   48,W
08B7:  MOVWF  4C
08B8:  MOVF   47,W
08B9:  MOVWF  4B
08BA:  MOVF   46,W
08BB:  MOVWF  4A
08BC:  CLRF   51
08BD:  CLRF   50
08BE:  CLRF   4F
08BF:  MOVLW  0A
08C0:  MOVWF  4E
08C1:  BCF    0A.3
08C2:  CALL   541
08C3:  BSF    0A.3
08C4:  MOVF   7A,W
08C5:  MOVWF  49
08C6:  MOVF   79,W
08C7:  MOVWF  48
08C8:  MOVF   78,W
08C9:  MOVWF  47
08CA:  MOVF   77,W
08CB:  MOVWF  46
08CC:  DECFSZ 44,F
08CD:  GOTO   04F
08CE:  RETURN
.................... 
.................... #list
.................... 
.................... #fuses xt,nowdt,HS,NOWDT,NOPROTECT,NOLVP,BROWNOUT
.................... #device *=16
.................... #device adc=10
.................... #use delay(clock = 4M)
*
00AE:  MOVLW  4B
00AF:  MOVWF  04
00B0:  BCF    03.7
00B1:  MOVF   00,W
00B2:  BTFSC  03.2
00B3:  GOTO   0C2
00B4:  MOVLW  01
00B5:  MOVWF  78
00B6:  CLRF   77
00B7:  DECFSZ 77,F
00B8:  GOTO   0B7
00B9:  DECFSZ 78,F
00BA:  GOTO   0B6
00BB:  MOVLW  4A
00BC:  MOVWF  77
00BD:  DECFSZ 77,F
00BE:  GOTO   0BD
00BF:  GOTO   0C0
00C0:  DECFSZ 00,F
00C1:  GOTO   0B4
00C2:  RETURN
.................... #define use_portb_kbd TRUE
.................... #define use_portd_lcd TRUE
.................... #include <lcd.c>
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
....................    output_float(LCD_DATA5);
....................    output_float(LCD_DATA6);
....................    output_float(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0xF;
*
00DB:  MOVLW  0F
00DC:  BSF    03.5
00DD:  ANDWF  08,W
00DE:  IORLW  F0
00DF:  MOVWF  08
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
00E0:  BCF    03.5
00E1:  BSF    08.2
....................    delay_cycles(1);
00E2:  NOP
....................    lcd_output_enable(1);
00E3:  BSF    08.0
....................    delay_cycles(1);
00E4:  NOP
....................    high = lcd_read_nibble();
00E5:  CALL   0CF
00E6:  MOVF   78,W
00E7:  MOVWF  52
....................       
....................    lcd_output_enable(0);
00E8:  BCF    08.0
....................    delay_cycles(1);
00E9:  NOP
....................    lcd_output_enable(1);
00EA:  BSF    08.0
....................    delay_us(1);
00EB:  NOP
....................    low = lcd_read_nibble();
00EC:  CALL   0CF
00ED:  MOVF   78,W
00EE:  MOVWF  51
....................       
....................    lcd_output_enable(0);
00EF:  BCF    08.0
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
00F0:  MOVLW  0F
00F1:  BSF    03.5
00F2:  ANDWF  08,W
00F3:  MOVWF  08
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
00F4:  BCF    03.5
00F5:  SWAPF  52,W
00F6:  MOVWF  77
00F7:  MOVLW  F0
00F8:  ANDWF  77,F
00F9:  MOVF   77,W
00FA:  IORWF  51,W
00FB:  MOVWF  78
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
....................    n |= input(LCD_DATA5) << 1;
....................    n |= input(LCD_DATA6) << 2;
....................    n |= input(LCD_DATA7) << 3;
....................    
....................    return(n);
....................   #else
....................    return(lcd.data);
*
00CF:  MOVF   08,W
00D0:  MOVWF  77
00D1:  SWAPF  08,W
00D2:  ANDLW  0F
00D3:  MOVWF  78
....................   #endif
00D4:  RETURN
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
....................    output_bit(LCD_DATA5, bit_test(n, 1));
....................    output_bit(LCD_DATA6, bit_test(n, 2));
....................    output_bit(LCD_DATA7, bit_test(n, 3));
....................   #else      
....................    lcdlat.data = n;
*
00C3:  SWAPF  52,W
00C4:  ANDLW  F0
00C5:  MOVWF  77
00C6:  MOVLW  0F
00C7:  ANDWF  08,W
00C8:  IORWF  77,W
00C9:  MOVWF  08
....................   #endif
....................       
....................    delay_cycles(1);
00CA:  NOP
....................    lcd_output_enable(1);
00CB:  BSF    08.0
....................    delay_us(2);
00CC:  GOTO   0CD
....................    lcd_output_enable(0);
00CD:  BCF    08.0
00CE:  RETURN
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
00D5:  BSF    03.5
00D6:  BCF    08.0
....................    lcd_rs_tris();
00D7:  BCF    08.1
....................    lcd_rw_tris();
00D8:  BCF    08.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
00D9:  BCF    03.5
00DA:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ;
*
00FC:  MOVF   78,W
00FD:  MOVWF  51
00FE:  BTFSC  51.7
00FF:  GOTO   0DB
....................    lcd_output_rs(address);
0100:  BTFSS  4F.0
0101:  BCF    08.1
0102:  BTFSC  4F.0
0103:  BSF    08.1
....................    delay_cycles(1);
0104:  NOP
....................    lcd_output_rw(0);
0105:  BCF    08.2
....................    delay_cycles(1);
0106:  NOP
....................    lcd_output_enable(0);
0107:  BCF    08.0
....................    lcd_send_nibble(n >> 4);
0108:  SWAPF  50,W
0109:  MOVWF  51
010A:  MOVLW  0F
010B:  ANDWF  51,F
010C:  MOVF   51,W
010D:  MOVWF  52
010E:  CALL   0C3
....................    lcd_send_nibble(n & 0xf);
010F:  MOVF   50,W
0110:  ANDLW  0F
0111:  MOVWF  51
0112:  MOVWF  52
0113:  CALL   0C3
0114:  RETURN
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
0115:  MOVLW  28
0116:  MOVWF  3D
0117:  MOVLW  0C
0118:  MOVWF  3E
0119:  MOVLW  01
011A:  MOVWF  3F
011B:  MOVLW  06
011C:  MOVWF  40
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
011D:  BCF    08.0
....................    lcd_output_rs(0);
011E:  BCF    08.1
....................    lcd_output_rw(0);
011F:  BCF    08.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
0120:  MOVLW  0F
0121:  BSF    03.5
0122:  ANDWF  08,W
0123:  MOVWF  08
....................   #endif
....................    lcd_enable_tris();
0124:  BCF    08.0
....................    lcd_rs_tris();
0125:  BCF    08.1
....................    lcd_rw_tris();
0126:  BCF    08.2
....................  #endif
....................     
....................    delay_ms(15);
0127:  MOVLW  0F
0128:  BCF    03.5
0129:  MOVWF  4B
012A:  CALL   0AE
....................    for(i=1;i<=3;++i)
012B:  MOVLW  01
012C:  MOVWF  3C
012D:  MOVF   3C,W
012E:  SUBLW  03
012F:  BTFSS  03.0
0130:  GOTO   139
....................    {
....................        lcd_send_nibble(3);
0131:  MOVLW  03
0132:  MOVWF  52
0133:  CALL   0C3
....................        delay_ms(5);
0134:  MOVLW  05
0135:  MOVWF  4B
0136:  CALL   0AE
0137:  INCF   3C,F
0138:  GOTO   12D
....................    }
....................    
....................    lcd_send_nibble(2);
0139:  MOVLW  02
013A:  MOVWF  52
013B:  CALL   0C3
....................    delay_ms(5);
013C:  MOVLW  05
013D:  MOVWF  4B
013E:  CALL   0AE
....................    for(i=0;i<=3;++i)
013F:  CLRF   3C
0140:  MOVF   3C,W
0141:  SUBLW  03
0142:  BTFSS  03.0
0143:  GOTO   150
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
0144:  MOVLW  3D
0145:  ADDWF  3C,W
0146:  MOVWF  04
0147:  BCF    03.7
0148:  MOVF   00,W
0149:  MOVWF  41
014A:  CLRF   4F
014B:  MOVF   41,W
014C:  MOVWF  50
014D:  CALL   0D5
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
014E:  INCF   3C,F
014F:  GOTO   140
0150:  BSF    0A.3
0151:  BCF    0A.4
0152:  GOTO   2AB (RETURN)
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
*
0418:  DECFSZ 4C,W
0419:  GOTO   41B
041A:  GOTO   41E
....................       address=LCD_LINE_TWO;
041B:  MOVLW  40
041C:  MOVWF  4D
041D:  GOTO   41F
....................    else
....................       address=0;
041E:  CLRF   4D
....................      
....................    address+=x-1;
041F:  MOVLW  01
0420:  SUBWF  4B,W
0421:  ADDWF  4D,F
....................    lcd_send_byte(0,0x80|address);
0422:  MOVF   4D,W
0423:  IORLW  80
0424:  MOVWF  4E
0425:  CLRF   4F
0426:  MOVF   4E,W
0427:  MOVWF  50
0428:  CALL   0D5
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
0429:  RETURN
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
042A:  MOVF   4A,W
042B:  XORLW  07
042C:  BTFSC  03.2
042D:  GOTO   438
042E:  XORLW  0B
042F:  BTFSC  03.2
0430:  GOTO   43D
0431:  XORLW  06
0432:  BTFSC  03.2
0433:  GOTO   445
0434:  XORLW  02
0435:  BTFSC  03.2
0436:  GOTO   44B
0437:  GOTO   450
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
0438:  MOVLW  01
0439:  MOVWF  4B
043A:  MOVWF  4C
043B:  CALL   418
043C:  GOTO   455
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
043D:  CLRF   4F
043E:  MOVLW  01
043F:  MOVWF  50
0440:  CALL   0D5
....................                      delay_ms(2);
0441:  MOVLW  02
0442:  MOVWF  4B
0443:  CALL   0AE
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
0444:  GOTO   455
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
0445:  MOVLW  01
0446:  MOVWF  4B
0447:  MOVLW  02
0448:  MOVWF  4C
0449:  CALL   418
044A:  GOTO   455
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
044B:  CLRF   4F
044C:  MOVLW  10
044D:  MOVWF  50
044E:  CALL   0D5
044F:  GOTO   455
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
0450:  MOVLW  01
0451:  MOVWF  4F
0452:  MOVF   4A,W
0453:  MOVWF  50
0454:  CALL   0D5
....................      #endif
....................    }
0455:  RETURN
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #include <kbd.c>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             KBD.C                                 ////
.................... ////                  Generic keypad scan driver                       ////
.................... ////                                                                   ////
.................... ////  kbd_init()   Must be called before any other function.           ////
.................... ////                                                                   ////
.................... ////  c = kbd_getc()  Will return a key value if pressed or /0 if not  ////
.................... ////                   This function should be called frequently so as ////
.................... ////                   not to miss a key press.                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////// The following defines the keypad layout on port D
.................... 
.................... // Un-comment the following define to use port B
.................... // #define use_portb_kbd TRUE
.................... 
.................... // Make sure the port used has pull-up resistors (or the LCD) on
.................... // the column pins
.................... 
.................... #if defined use_portb_kbd
....................    #byte kbd = getenv("SFR:PORTB")
.................... #else
....................    #byte kbd = getenv("SFR:PORTD")
.................... #endif
.................... 
.................... #if defined use_portb_kbd
....................    #define set_tris_kbd(x) set_tris_b(x)
.................... #else
....................    #define set_tris_kbd(x) set_tris_d(x)
.................... #endif
.................... 
.................... //Keypad connection:   (for example column 0 is B2)
.................... //                Bx:
.................... 
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad
.................... #define COL0 (1 << 2)
.................... #define COL1 (1 << 3)
.................... #define COL2 (1 << 6)
.................... 
.................... #define ROW0 (1 << 4)
.................... #define ROW1 (1 << 7)
.................... #define ROW2 (1 << 1)
.................... #define ROW3 (1 << 5)
.................... 
.................... #else ////////////////////////////////////////////////// For the black keypad
.................... #define COL0 (1 << 5)
.................... #define COL1 (1 << 6)
.................... #define COL2 (1 << 7)
.................... 
.................... #define ROW0 (1 << 1)
.................... #define ROW1 (1 << 2)
.................... #define ROW2 (1 << 3)
.................... #define ROW3 (1 << 4)
.................... 
.................... #endif
.................... 
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3)
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2)
.................... 
.................... // Keypad layout:
.................... char const KEYS[4][3] = {{'1','2','3'},
....................                          {'4','5','6'},
....................                          {'7','8','9'},
....................                          {'*','0','#'}};
.................... 
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where
....................                                   // n is the number of times you expect
....................                                   // to call kbd_getc each second
.................... 
.................... 
.................... void kbd_init() {
*
00AB:  BSF    0A.3
00AC:  BCF    0A.4
00AD:  GOTO   2A8 (RETURN)
.................... }
.................... 
.................... char kbd_getc( ) {
....................    static BYTE kbd_call_count;
*
0A6A:  BCF    03.5
0A6B:  CLRF   20
....................    static int1 kbd_down;
0A6C:  BCF    21.0
....................    static char last_key;
0A6D:  CLRF   22
....................    static BYTE col;
0A6E:  CLRF   23
.................... 
....................    BYTE kchar;
....................    BYTE row;
.................... 
....................    kchar='\0';
*
0653:  CLRF   3C
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) {
0654:  INCF   20,F
0655:  MOVF   20,W
0656:  SUBLW  21
0657:  BTFSC  03.0
0658:  GOTO   6D4
....................        switch (col) {
0659:  MOVF   23,W
065A:  BTFSC  03.2
065B:  GOTO   663
065C:  XORLW  01
065D:  BTFSC  03.2
065E:  GOTO   669
065F:  XORLW  03
0660:  BTFSC  03.2
0661:  GOTO   66F
0662:  GOTO   674
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0);
0663:  MOVLW  DE
0664:  BSF    03.5
0665:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS;
0666:  BCF    03.5
0667:  MOVWF  06
....................                     break;
0668:  GOTO   674
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1);
0669:  MOVLW  BE
066A:  BSF    03.5
066B:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS;
066C:  BCF    03.5
066D:  MOVWF  06
....................                     break;
066E:  GOTO   674
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2);
066F:  MOVLW  7E
0670:  BSF    03.5
0671:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS;
0672:  BCF    03.5
0673:  MOVWF  06
....................                     break;
....................        }
.................... 
....................        if(kbd_down) {
0674:  BTFSS  21.0
0675:  GOTO   680
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) {
0676:  MOVF   06,W
0677:  ANDLW  1E
0678:  SUBLW  1E
0679:  BTFSS  03.2
067A:  GOTO   67F
....................            kbd_down=FALSE;
067B:  BCF    21.0
....................            kchar=last_key;
067C:  MOVF   22,W
067D:  MOVWF  3C
....................            last_key='\0';
067E:  CLRF   22
....................          }
....................        } else {
067F:  GOTO   6D3
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) {
0680:  MOVF   06,W
0681:  ANDLW  1E
0682:  SUBLW  1E
0683:  BTFSC  03.2
0684:  GOTO   6CE
....................              if((kbd & ROW0)==0)
0685:  MOVF   06,W
0686:  ANDLW  02
0687:  BTFSS  03.2
0688:  GOTO   68B
....................                row=0;
0689:  CLRF   3D
068A:  GOTO   69F
....................              else if((kbd & ROW1)==0)
068B:  MOVF   06,W
068C:  ANDLW  04
068D:  BTFSS  03.2
068E:  GOTO   692
....................                row=1;
068F:  MOVLW  01
0690:  MOVWF  3D
0691:  GOTO   69F
....................              else if((kbd & ROW2)==0)
0692:  MOVF   06,W
0693:  ANDLW  08
0694:  BTFSS  03.2
0695:  GOTO   699
....................                row=2;
0696:  MOVLW  02
0697:  MOVWF  3D
0698:  GOTO   69F
....................              else if((kbd & ROW3)==0)
0699:  MOVF   06,W
069A:  ANDLW  10
069B:  BTFSS  03.2
069C:  GOTO   69F
....................                row=3;
069D:  MOVLW  03
069E:  MOVWF  3D
....................              last_key =KEYS[row][col];
069F:  MOVF   3D,W
06A0:  MOVWF  3E
06A1:  MOVLW  03
06A2:  MOVWF  3F
*
06C7:  MOVF   23,W
06C8:  ADDWF  78,W
06C9:  CALL   004
06CA:  MOVWF  78
06CB:  MOVWF  22
....................              kbd_down = TRUE;
06CC:  BSF    21.0
....................           } else {
06CD:  GOTO   6D3
....................              ++col;
06CE:  INCF   23,F
....................              if(col==3)
06CF:  MOVF   23,W
06D0:  SUBLW  03
06D1:  BTFSC  03.2
....................                col=0;
06D2:  CLRF   23
....................           }
....................        }
....................       kbd_call_count=0;
06D3:  CLRF   20
....................    }
....................   set_tris_kbd(ALL_PINS);
06D4:  MOVLW  FE
06D5:  BSF    03.5
06D6:  MOVWF  06
....................   return(kchar);
06D7:  BCF    03.5
06D8:  MOVF   3C,W
06D9:  MOVWF  78
06DA:  BSF    0A.3
06DB:  BCF    0A.4
06DC:  GOTO   40C (RETURN)
.................... }
.................... 
.................... #include <stdio.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDIO
.................... #define _STDIO
.................... #include <string.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STRING
.................... #define _STRING
.................... #include <stddef.h>
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _STDDEF
.................... 
.................... #define _STDDEF
.................... 
.................... #if sizeof(unsigned int8 *)==1
.................... #define ptrdiff_t unsigned int8
.................... #else
.................... #define ptrdiff_t unsigned int16
.................... #endif
.................... 
.................... #if defined(__PCB__) || defined(__PCM__)
.................... #define size_t unsigned int8
.................... #else
.................... #define size_t unsigned int16
.................... #endif
.................... #define wchar_t unsigned char
.................... #define NULL 0
.................... 
.................... #define offsetof(s,f) (offsetofbit(s,f)/8)
.................... 
.................... #endif
.................... 
.................... #include <ctype.h>
.................... ////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            ////
.................... //// This source code may only be used by licensed users of the CCS C   ////
.................... //// compiler.  This source code may only be distributed to other       ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  ////
.................... //// or distribution is permitted without written permission.           ////
.................... //// Derivative programs created using this software in object code     ////
.................... //// form are not restricted in any way.                                ////
.................... ////////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef _CTYPE
.................... #define _CTYPE
.................... 
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz")
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ")
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz")
.................... #define isdigit(x)  isamong(x,"0123456789")
.................... #define isspace(x)  ((x)==' ')
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef")
.................... #define iscntrl(x)  ((x)<' ')
.................... #define isprint(x)  ((x)>=' ')
.................... #define isgraph(x)  ((x)>' ')
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x))
.................... 
.................... #endif
.................... 
.................... 
.................... 
.................... 
.................... 
.................... //////////////////////////////////////////////
.................... //// Uncomment the following define to    ////
.................... //// allow some functions to use a        ////
.................... //// quicker algorithm, but use more ROM  ////
.................... ////                                      ////
.................... //// #define FASTER_BUT_MORE_ROM          ////
.................... //////////////////////////////////////////////
.................... 
.................... 
.................... 
.................... /*Copying functions*/
.................... /* standard template:
....................    void *memmove(void *s1, void *s2, size_t n).
....................    Copies max of n characters safely (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... unsigned char *memmove(void *s1,void *s2,size_t n)
.................... {
....................    unsigned char *sc1;
....................    unsigned char *sc2;
....................    sc1=s1;
....................    sc2=s2;
....................    if(sc2<sc1 && sc1 <sc2 +n)
....................       for(sc1+=n,sc2+=n;0<n;--n)
....................          *--sc1=*--sc2;
....................    else
....................       for(;0<n;--n)
....................          *sc1++=*sc2++;
....................   return s1;
....................   }
.................... 
.................... /* Standard template: char *strcpy(char *s1, const char *s2)
....................    copies the string s2 including the null character to s1.
....................    This is a compiler built in to handle the different address
....................    spaces */
.................... 
.................... #define strcopy strcpy
.................... 
.................... /* standard template:
....................    char *strncpy(char *s1, const char *s2, size_t n).
....................    Copies max of n characters (not following ending '\0')
....................    from s2 in s1; if s2 has less than n characters, appends 0 */
.................... 
.................... char *strncpy(char *s1, char *s2, size_t n)
.................... {
....................   char *s;
.................... 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--)
....................      *s++ = *s2++;
....................   for (; n > 0; n--)
....................      *s++ = '\0';
.................... 
....................   return(s1);
.................... }
.................... /***********************************************************/
.................... 
.................... /*concatenation functions*/
.................... /* standard template: char *strcat(char *s1, const char *s2)
.................... appends s2 to s1*/
.................... 
.................... char *strcat(char *s1, char *s2)
.................... {
....................    unsigned char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0')
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n)
.................... appends not more than n characters from s2 to s1*/
.................... 
.................... char *strncat(char *s1, char *s2, size_t n)
.................... {
....................    char *s;
.................... 
....................    for (s = s1; *s != '\0'; ++s);
....................    while(*s2 != '\0' && 0<n)
....................    {
....................       *s = *s2;
....................       ++s;
....................       ++s2;
....................       --n;
....................    }
.................... 
....................    *s = '\0';
....................    return(s1);
.................... }
.................... 
.................... /***********************************************************/
.................... 
.................... 
.................... /*comparison functions*/
.................... /* standard template: signed int memcmp(void *s1, void *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int memcmp(void * s1,void *s2,size_t n)
.................... {
.................... unsigned char *su1, *su2;
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n)
.................... {
....................    if(*su1!=*su2)
....................       return ((*su1<*su2)?-1:1);
.................... }
.................... return 0;
.................... }
.................... 
.................... /* standard template: int strcmp(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcmp(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... /* standard template: int strcoll(const char *s1, const char *s2).
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */
.................... 
.................... signed int strcoll(char *s1, char *s2)
.................... {
....................    for (; *s1 == *s2; s1++, s2++)
....................       if (*s1 == '\0')
....................          return(0);
....................    return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... /* standard template:
....................    int strncmp(const char *s1, const char *s2, size_t n).
....................    Compares max of n characters (not following 0) from s1 to s2;
....................    returns same as strcmp */
.................... 
.................... signed int strncmp(char *s1, char *s2, size_t n)
.................... {
....................    for (; n > 0; s1++, s2++, n--)
....................       if (*s1 != *s2)
....................          return((*s1 <*s2) ? -1: 1);
....................       else if (*s1 == '\0')
....................          return(0);
....................    return(0);
.................... }
.................... /* standard template:
....................    int strxfrm(const char *s1, const char *s2, size_t n).
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1.
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/
.................... size_t strxfrm(char *s1, char *s2, size_t n)
.................... {
....................    char c;
....................    unsigned int8 n1;
....................    
....................    if (!s1 && !n)
....................       n = -1; //find length
.................... 
....................    n1 = 0;
....................    
....................    for (; n1 < n; n1++)
....................    {
....................       c = *s2++;
....................       if (!c)
....................          break;
....................       if (s1)
....................          *s1++ = c;
....................    }
.................... 
....................   return(n1);
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... /***********************************************************/
.................... /*Search functions*/
.................... /* standard template: void *memchr(const char *s, int c).
....................    Finds first occurrence of c in n characters of s */
.................... 
.................... char *memchr(void *s,unsigned int8 c,size_t n)
.................... {
....................    char uc;
....................    char *su;
....................    uc=c;
....................    for(su=s;0<n;++su,--n)
....................       if(*su==uc)
....................       return su;
....................    return NULL;
.................... }
.................... 
.................... /* standard template: char *strchr(const char *s, int c).
....................    Finds first occurrence of c in s */
.................... 
.................... char *strchr(char *s, char c)
.................... {
....................    for (; *s != c; s++)
....................       if (*s == '\0')
....................          return(0);
....................    return(s);
.................... }
.................... /* standard template:
....................    size_t strcspn(const char *s1, const char *s2).
....................    Computes length of max initial segment of s1 that
....................    consists entirely of characters NOT from s2*/
.................... 
.................... size_t strcspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1 - s1);
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strpbrk(const char *s1, const char *s2).
....................    Locates first occurence of any character from s2 in s1;
....................    returns s1 if s2 is empty string */
.................... 
.................... char *strpbrk(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; *sc2 != 0; sc2++)
....................          if (*sc1 == *sc2)
....................             return(sc1);
....................    return(0);
.................... }
.................... 
.................... 
.................... /* standard template: char *strrchr(const char *s, int c).
....................    Finds last occurrence of c in s */
.................... 
.................... char *strrchr(char *s, char c)
.................... {
....................    char *p;
.................... 
....................    for (p = 0; ; s++)
....................    {
....................       if (*s == c)
....................          p = s;
....................       if (*s == '\0')
....................          return(p);
....................    }
.................... }
.................... /* computes length of max initial segment of s1 consisting
....................    entirely of characters from s2 */
.................... 
.................... size_t strspn(char *s1, char *s2)
.................... {
....................    char *sc1, *sc2;
.................... 
....................    for (sc1 = s1; *sc1 != 0; sc1++)
....................       for (sc2 = s2; ; sc2++)
....................     if (*sc2 == '\0')
....................        return(sc1 - s1);
....................          else if (*sc1 == *sc2)
....................             break;
....................    return(sc1 - s1);
.................... }
.................... /* standard template:
....................    char *strstr(const char *s1, const char *s2);
....................    Locates first occurence of character sequence s2 in s1;
....................    returns 0 if s2 is empty string
.................... 
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the
....................    file to use the faster algorithm */
.................... char *strstr(char *s1, char *s2)
.................... {
....................    char *s, *t;
.................... 
....................    #ifdef FASTER_BUT_MORE_ROM
....................    if (*s2 == '\0')
....................          return(s1);
....................    #endif
.................... 
....................    while (*s1)
....................    {
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t);
.................... 
....................       if (*t == '\0')
....................          return s1;
....................       ++s1;
....................       #ifdef FASTER_BUT_MORE_ROM
....................          while(*s1 != '\0' && *s1 != *s2)
....................             ++s1;
....................       #endif
....................    }
....................    return 0;
.................... }
.................... 
.................... /* standard template: size_t strlen(const char *s).
....................    Computes length of s1 (preceding terminating 0) */
.................... 
.................... size_t strlen(char *s)
.................... {
....................    char *sc;
.................... 
....................    for (sc = s; *sc != 0; sc++);
....................    return(sc - s);
.................... }
.................... 
.................... /* standard template: char *strtok(char *s1, const char *s2).
.................... 
....................    Finds next token in s1 delimited by a character from separator
....................    string s2 (which can be different from call to call).  First call
....................    starts at beginning of s1 searching for first character NOT
....................    contained in s2; returns 0 if none is found.
....................    If one is found, it is the start of first token (return value).
....................    Function then searches from there for a character contained in s2.
....................    If none is found, current token extends to end of s1, and subsequent
....................    searches for a token will return 0.  If one is found, it is
....................    overwritten by '\0', which terminates current token.  Function saves
....................    pointer to following character from which next search will start.
....................    Each subsequent call, with 0 as first argument, starts searching
....................    from saved pointer */
.................... 
.................... char *strtok(char *s1, char *s2)
.................... {
....................    char *beg, *end;
....................    static char *save;
*
0A6F:  CLRF   24
0A70:  CLRF   25
.................... 
....................    beg = (s1)? s1: save;
....................    beg += strspn(beg, s2);
....................    if (*beg == '\0')
....................       return(0);
....................       
....................    end = strpbrk(beg, s2);
....................    if (end != '\0')
....................    {
....................       *end = '\0';
....................       end++;
....................       save = end;
....................    }
....................    else
....................       save = beg + strlen(beg);
....................    
....................    return(beg);
.................... }
.................... 
.................... /*****************************************************************/
.................... /*Miscellaneous functions*/
.................... /* standard template
.................... maps error number in errnum to an error message string
.................... Returns: Pointer to string
.................... */
.................... #ifdef _ERRNO
.................... char * strerror(unsigned int8 errnum)
.................... {
.................... static unsigned char s[13];
.................... switch( errnum)
.................... {
.................... case 0:
....................    strcpy(s,"no errors");
....................    return s;
.................... case EDOM :
....................    strcpy(s,"domain error");
....................    return s;
.................... case ERANGE:
....................    strcpy(s,"range error");
....................    return s;
.................... }
.................... }
.................... #ENDIF
.................... 
.................... /* standard template: size_t stricmp(const char *s1, const char *s2).
....................    Compares s1 to s2 ignoring case (upper vs. lower) */
.................... 
.................... signed int stricmp(char *s1, char *s2)
.................... {
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&((char)*s1==(char)*s2+(char)32||(char)*s2==(char)*s1+(char)32));
....................     s1++, s2++)
....................     if (*s1 == '\0')
....................        return(0);
....................  return((*s1 < *s2) ? -1: 1);
.................... }
.................... 
.................... 
.................... /* standard template: char *strlwr(char *s).
....................    Replaces uppercase letters by lowercase;
....................    returns pointer to new string s */
.................... 
.................... char *strlwr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'A' && *p <='Z')
....................          *p += 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... /* standard template: char *strupr(char *s).
....................    Replaces lowercase letters by upercase;
....................    returns pointer to new string s */
.................... 
.................... char *strupr(char *s)
.................... {
....................    char *p;
.................... 
....................    for (p = s; *p != '\0'; p++)
....................       if (*p >= 'a' && *p <='z')
....................          *p -= 'a' - 'A';
....................    return(s);
.................... }
.................... 
.................... 
.................... /************************************************************/
.................... 
.................... 
.................... #endif
.................... 
.................... #ifndef getc
.................... #define getc getch
.................... #define getchar getch
.................... #define puts(s) {printf(s); putchar(13); putchar(10);}
.................... #define putc putchar
.................... #endif
.................... /* maps error number to an error message. Writes a sequence of characters to
.................... stderr stream thus: if s is not null then string pointed to by s follwed by
.................... a colon (:) and a space and the appropriate error message returned by strerror
.................... function with argument errno
.................... 
.................... Returns: no value
.................... */
.................... 
.................... #ifdef _ERRNO
.................... void perror(char *s)
.................... {
....................   if(s)
....................   fprintf(STDERR,"%s: ",s);
....................   fprintf(STDERR,"%s\r\n",strerror(errno));
.................... }
.................... #endif
.................... #endif
.................... 
.................... #use rs232(uart1, baud = 9600)                // Initialize UART module
.................... 
.................... float temperatura;
.................... char keypad;
.................... int i;
.................... char keys_pressed[5];
.................... 
.................... void checkTemp(int value){
....................     if(temperatura<20)  {
*
08CF:  MOVF   29,W
08D0:  MOVWF  43
08D1:  MOVF   28,W
08D2:  MOVWF  42
08D3:  MOVF   27,W
08D4:  MOVWF  41
08D5:  MOVF   26,W
08D6:  MOVWF  40
08D7:  CLRF   47
08D8:  CLRF   46
08D9:  MOVLW  20
08DA:  MOVWF  45
08DB:  MOVLW  83
08DC:  MOVWF  44
08DD:  BCF    0A.3
08DE:  CALL   3D9
08DF:  BSF    0A.3
08E0:  BTFSS  03.0
08E1:  GOTO   123
....................         //Abre
....................         output_low(PIN_D3);
08E2:  BSF    03.5
08E3:  BCF    08.3
08E4:  BCF    03.5
08E5:  BCF    08.3
....................         lcd_gotoxy(1,2);
08E6:  MOVLW  01
08E7:  MOVWF  4B
08E8:  MOVLW  02
08E9:  MOVWF  4C
08EA:  BCF    0A.3
08EB:  CALL   418
08EC:  BSF    0A.3
....................         set_pwm1_duty(150);
08ED:  MOVLW  96
08EE:  MOVWF  15
....................         printf(lcd_putc,"\fpuerta abierta");
08EF:  MOVLW  14
08F0:  BSF    03.6
08F1:  MOVWF  0D
08F2:  MOVLW  00
08F3:  MOVWF  0F
08F4:  BCF    0A.3
08F5:  BCF    03.6
08F6:  CALL   6DD
08F7:  BSF    0A.3
....................         delay_ms(10000);
08F8:  MOVLW  28
08F9:  MOVWF  3D
08FA:  MOVLW  FA
08FB:  MOVWF  4B
08FC:  BCF    0A.3
08FD:  CALL   0AE
08FE:  BSF    0A.3
08FF:  DECFSZ 3D,F
0900:  GOTO   0FA
....................         set_pwm1_duty(0);
0901:  CLRF   15
....................         
....................         //Cierra
....................         lcd_gotoxy (1,2);
0902:  MOVLW  01
0903:  MOVWF  4B
0904:  MOVLW  02
0905:  MOVWF  4C
0906:  BCF    0A.3
0907:  CALL   418
0908:  BSF    0A.3
....................         set_pwm2_duty(150);
0909:  MOVLW  96
090A:  MOVWF  1B
....................         printf(lcd_putc,"\fpuerta cerrada");
090B:  MOVLW  1C
090C:  BSF    03.6
090D:  MOVWF  0D
090E:  MOVLW  00
090F:  MOVWF  0F
0910:  BCF    0A.3
0911:  BCF    03.6
0912:  CALL   6DD
0913:  BSF    0A.3
....................         delay_ms(10000);
0914:  MOVLW  28
0915:  MOVWF  3D
0916:  MOVLW  FA
0917:  MOVWF  4B
0918:  BCF    0A.3
0919:  CALL   0AE
091A:  BSF    0A.3
091B:  DECFSZ 3D,F
091C:  GOTO   116
....................         output_high(PIN_D3);
091D:  BSF    03.5
091E:  BCF    08.3
091F:  BCF    03.5
0920:  BSF    08.3
....................         set_pwm2_duty(0);
0921:  CLRF   1B
....................     }
0922:  GOTO   1C3
....................     else if(temperatura>=20&&temperatura<=35)  {         
0923:  CLRF   43
0924:  CLRF   42
0925:  MOVLW  20
0926:  MOVWF  41
0927:  MOVLW  83
0928:  MOVWF  40
0929:  MOVF   29,W
092A:  MOVWF  47
092B:  MOVF   28,W
092C:  MOVWF  46
092D:  MOVF   27,W
092E:  MOVWF  45
092F:  MOVF   26,W
0930:  MOVWF  44
0931:  BCF    0A.3
0932:  CALL   3D9
0933:  BSF    0A.3
0934:  BTFSC  03.0
0935:  GOTO   138
0936:  BTFSS  03.2
0937:  GOTO   18E
0938:  MOVF   29,W
0939:  MOVWF  43
093A:  MOVF   28,W
093B:  MOVWF  42
093C:  MOVF   27,W
093D:  MOVWF  41
093E:  MOVF   26,W
093F:  MOVWF  40
0940:  CLRF   47
0941:  CLRF   46
0942:  MOVLW  0C
0943:  MOVWF  45
0944:  MOVLW  84
0945:  MOVWF  44
0946:  BCF    0A.3
0947:  CALL   3D9
0948:  BSF    0A.3
0949:  BTFSC  03.0
094A:  GOTO   14D
094B:  BTFSS  03.2
094C:  GOTO   18E
....................         //Abre
....................         output_low(PIN_D3);
094D:  BSF    03.5
094E:  BCF    08.3
094F:  BCF    03.5
0950:  BCF    08.3
....................         lcd_gotoxy(1,2);
0951:  MOVLW  01
0952:  MOVWF  4B
0953:  MOVLW  02
0954:  MOVWF  4C
0955:  BCF    0A.3
0956:  CALL   418
0957:  BSF    0A.3
....................         set_pwm1_duty(150);
0958:  MOVLW  96
0959:  MOVWF  15
....................         printf(lcd_putc,"\fpuerta abierta");
095A:  MOVLW  24
095B:  BSF    03.6
095C:  MOVWF  0D
095D:  MOVLW  00
095E:  MOVWF  0F
095F:  BCF    0A.3
0960:  BCF    03.6
0961:  CALL   6DD
0962:  BSF    0A.3
....................         delay_ms(5000);
0963:  MOVLW  14
0964:  MOVWF  3D
0965:  MOVLW  FA
0966:  MOVWF  4B
0967:  BCF    0A.3
0968:  CALL   0AE
0969:  BSF    0A.3
096A:  DECFSZ 3D,F
096B:  GOTO   165
....................         set_pwm1_duty(0);
096C:  CLRF   15
.................... 
....................         //Cierra
....................         lcd_gotoxy (1,2);
096D:  MOVLW  01
096E:  MOVWF  4B
096F:  MOVLW  02
0970:  MOVWF  4C
0971:  BCF    0A.3
0972:  CALL   418
0973:  BSF    0A.3
....................         set_pwm2_duty(150);
0974:  MOVLW  96
0975:  MOVWF  1B
....................         printf(lcd_putc,"\fpuerta cerrada");
0976:  MOVLW  2C
0977:  BSF    03.6
0978:  MOVWF  0D
0979:  MOVLW  00
097A:  MOVWF  0F
097B:  BCF    0A.3
097C:  BCF    03.6
097D:  CALL   6DD
097E:  BSF    0A.3
....................         delay_ms(5000);
097F:  MOVLW  14
0980:  MOVWF  3D
0981:  MOVLW  FA
0982:  MOVWF  4B
0983:  BCF    0A.3
0984:  CALL   0AE
0985:  BSF    0A.3
0986:  DECFSZ 3D,F
0987:  GOTO   181
....................         set_pwm2_duty(0);
0988:  CLRF   1B
....................         output_high(PIN_D3);
0989:  BSF    03.5
098A:  BCF    08.3
098B:  BCF    03.5
098C:  BSF    08.3
....................     }
098D:  GOTO   1C3
....................     else if(temperatura>35)  {
098E:  CLRF   43
098F:  CLRF   42
0990:  MOVLW  0C
0991:  MOVWF  41
0992:  MOVLW  84
0993:  MOVWF  40
0994:  MOVF   29,W
0995:  MOVWF  47
0996:  MOVF   28,W
0997:  MOVWF  46
0998:  MOVF   27,W
0999:  MOVWF  45
099A:  MOVF   26,W
099B:  MOVWF  44
099C:  BCF    0A.3
099D:  CALL   3D9
099E:  BSF    0A.3
099F:  BTFSS  03.0
09A0:  GOTO   1C3
....................         printf(lcd_putc,"\fTemp alta,");
09A1:  MOVLW  34
09A2:  BSF    03.6
09A3:  MOVWF  0D
09A4:  MOVLW  00
09A5:  MOVWF  0F
09A6:  BCF    0A.3
09A7:  BCF    03.6
09A8:  CALL   6DD
09A9:  BSF    0A.3
....................         lcd_gotoxy (1,2);
09AA:  MOVLW  01
09AB:  MOVWF  4B
09AC:  MOVLW  02
09AD:  MOVWF  4C
09AE:  BCF    0A.3
09AF:  CALL   418
09B0:  BSF    0A.3
....................         printf(lcd_putc,"intentar despues.");
09B1:  MOVLW  3A
09B2:  BSF    03.6
09B3:  MOVWF  0D
09B4:  MOVLW  00
09B5:  MOVWF  0F
09B6:  BCF    0A.3
09B7:  BCF    03.6
09B8:  CALL   6DD
09B9:  BSF    0A.3
....................         delay_ms(500);
09BA:  MOVLW  02
09BB:  MOVWF  3D
09BC:  MOVLW  FA
09BD:  MOVWF  4B
09BE:  BCF    0A.3
09BF:  CALL   0AE
09C0:  BSF    0A.3
09C1:  DECFSZ 3D,F
09C2:  GOTO   1BC
....................     }
....................     keys_pressed[0]='*';
09C3:  MOVLW  2A
09C4:  MOVWF  2C
....................     keys_pressed[1]='*';
09C5:  MOVWF  2D
....................     keys_pressed[2]='*';
09C6:  MOVWF  2E
....................     keys_pressed[3]='*';
09C7:  MOVWF  2F
....................     keys_pressed[4]='*';
09C8:  MOVWF  30
....................     
....................     lcd_gotoxy(1,1);           
09C9:  MOVLW  01
09CA:  MOVWF  4B
09CB:  MOVWF  4C
09CC:  BCF    0A.3
09CD:  CALL   418
09CE:  BSF    0A.3
....................     printf(lcd_putc,"\fTEMP: %f ",temperatura);
09CF:  MOVLW  43
09D0:  BSF    03.6
09D1:  MOVWF  0D
09D2:  MOVLW  00
09D3:  MOVWF  0F
09D4:  BCF    03.0
09D5:  MOVLW  07
09D6:  BCF    03.6
09D7:  MOVWF  3D
09D8:  BCF    0A.3
09D9:  CALL   456
09DA:  BSF    0A.3
09DB:  MOVLW  89
09DC:  MOVWF  04
09DD:  MOVF   29,W
09DE:  MOVWF  40
09DF:  MOVF   28,W
09E0:  MOVWF  3F
09E1:  MOVF   27,W
09E2:  MOVWF  3E
09E3:  MOVF   26,W
09E4:  MOVWF  3D
09E5:  MOVLW  02
09E6:  MOVWF  41
09E7:  BCF    0A.3
09E8:  CALL   590
09E9:  BSF    0A.3
09EA:  MOVLW  20
09EB:  MOVWF  4A
09EC:  BCF    0A.3
09ED:  CALL   42A
09EE:  BSF    0A.3
....................     lcd_gotoxy(12,1);
09EF:  MOVLW  0C
09F0:  MOVWF  4B
09F1:  MOVLW  01
09F2:  MOVWF  4C
09F3:  BCF    0A.3
09F4:  CALL   418
09F5:  BSF    0A.3
....................     printf (lcd_putc,"C");
09F6:  MOVLW  43
09F7:  MOVWF  4A
09F8:  BCF    0A.3
09F9:  CALL   42A
09FA:  BSF    0A.3
....................     
....................     putc(13);                                   // Go to first column
09FB:  MOVLW  0D
09FC:  BTFSS  0C.4
09FD:  GOTO   1FC
09FE:  MOVWF  19
....................     putc(10);                                   // Start a new lin
09FF:  MOVLW  0A
0A00:  BTFSS  0C.4
0A01:  GOTO   200
0A02:  MOVWF  19
....................     if(value==1){
0A03:  DECFSZ 3C,W
0A04:  GOTO   22B
....................         printf("Code:12345-Temp:%fC \n",temperatura );
0A05:  MOVLW  49
0A06:  BSF    03.6
0A07:  MOVWF  0D
0A08:  MOVLW  00
0A09:  MOVWF  0F
0A0A:  BCF    03.0
0A0B:  MOVLW  10
0A0C:  BCF    03.6
0A0D:  MOVWF  3D
0A0E:  BCF    0A.3
0A0F:  CALL   733
0A10:  BSF    0A.3
0A11:  MOVLW  89
0A12:  MOVWF  04
0A13:  MOVF   29,W
0A14:  MOVWF  40
0A15:  MOVF   28,W
0A16:  MOVWF  3F
0A17:  MOVF   27,W
0A18:  MOVWF  3E
0A19:  MOVF   26,W
0A1A:  MOVWF  3D
0A1B:  MOVLW  02
0A1C:  MOVWF  41
0A1D:  CALL   000
0A1E:  MOVLW  43
0A1F:  BTFSS  0C.4
0A20:  GOTO   21F
0A21:  MOVWF  19
0A22:  MOVLW  20
0A23:  BTFSS  0C.4
0A24:  GOTO   223
0A25:  MOVWF  19
0A26:  MOVLW  0A
0A27:  BTFSS  0C.4
0A28:  GOTO   227
0A29:  MOVWF  19
....................     }
0A2A:  GOTO   254
....................     else if(value==2){
0A2B:  MOVF   3C,W
0A2C:  SUBLW  02
0A2D:  BTFSS  03.2
0A2E:  GOTO   254
....................         printf("Code:67890-Temp:%fC \n",temperatura );
0A2F:  MOVLW  54
0A30:  BSF    03.6
0A31:  MOVWF  0D
0A32:  MOVLW  00
0A33:  MOVWF  0F
0A34:  BCF    03.0
0A35:  MOVLW  10
0A36:  BCF    03.6
0A37:  MOVWF  3D
0A38:  BCF    0A.3
0A39:  CALL   733
0A3A:  BSF    0A.3
0A3B:  MOVLW  89
0A3C:  MOVWF  04
0A3D:  MOVF   29,W
0A3E:  MOVWF  40
0A3F:  MOVF   28,W
0A40:  MOVWF  3F
0A41:  MOVF   27,W
0A42:  MOVWF  3E
0A43:  MOVF   26,W
0A44:  MOVWF  3D
0A45:  MOVLW  02
0A46:  MOVWF  41
0A47:  CALL   000
0A48:  MOVLW  43
0A49:  BTFSS  0C.4
0A4A:  GOTO   249
0A4B:  MOVWF  19
0A4C:  MOVLW  20
0A4D:  BTFSS  0C.4
0A4E:  GOTO   24D
0A4F:  MOVWF  19
0A50:  MOVLW  0A
0A51:  BTFSS  0C.4
0A52:  GOTO   251
0A53:  MOVWF  19
....................     }
0A54:  RETURN
....................     
.................... }
.................... 
.................... void main() {
0A55:  MOVF   03,W
0A56:  ANDLW  1F
0A57:  MOVWF  03
0A58:  MOVLW  19
0A59:  BSF    03.5
0A5A:  MOVWF  19
0A5B:  MOVLW  A6
0A5C:  MOVWF  18
0A5D:  MOVLW  90
0A5E:  BCF    03.5
0A5F:  MOVWF  18
0A60:  CLRF   32
0A61:  CLRF   31
0A62:  MOVLW  FF
0A63:  MOVWF  33
0A64:  BSF    03.5
0A65:  BSF    1F.0
0A66:  BSF    1F.1
0A67:  BSF    1F.2
0A68:  BCF    1F.3
0A69:  BCF    03.7
*
0A71:  CLRF   34
0A72:  MOVLW  01
0A73:  MOVWF  35
0A74:  CLRF   36
0A75:  CLRF   37
....................     
....................     int checkPassword=0;
....................     int valid=1;
....................     int maintinaing=0;
....................     int buttonState=0;
....................     keys_pressed[0]='*';
0A76:  MOVLW  2A
0A77:  MOVWF  2C
....................     keys_pressed[1]='*';
0A78:  MOVWF  2D
....................     keys_pressed[2]='*';
0A79:  MOVWF  2E
....................     keys_pressed[3]='*';
0A7A:  MOVWF  2F
....................     keys_pressed[4]='*';
0A7B:  MOVWF  30
....................     float previousTemp=0;
0A7C:  CLRF   3B
0A7D:  CLRF   3A
0A7E:  CLRF   39
0A7F:  CLRF   38
....................     
....................     setup_adc_ports(ALL_ANALOG); 
0A80:  BSF    03.5
0A81:  BCF    1F.0
0A82:  BCF    1F.1
0A83:  BCF    1F.2
0A84:  BCF    1F.3
....................     setup_adc(ADC_CLOCK_INTERNAL);
0A85:  BCF    03.5
0A86:  BSF    1F.6
0A87:  BSF    1F.7
0A88:  BSF    03.5
0A89:  BSF    1F.7
0A8A:  BCF    03.5
0A8B:  BSF    1F.0
....................     setup_ccp1(0x0C);
0A8C:  BCF    33.2
0A8D:  MOVF   33,W
0A8E:  BSF    03.5
0A8F:  MOVWF  07
0A90:  BCF    03.5
0A91:  BCF    07.2
0A92:  MOVLW  0C
0A93:  MOVWF  17
....................     setup_ccp2(0x0C);
0A94:  BCF    33.1
0A95:  MOVF   33,W
0A96:  BSF    03.5
0A97:  MOVWF  07
0A98:  BCF    03.5
0A99:  BCF    07.1
0A9A:  MOVLW  0C
0A9B:  MOVWF  1D
....................     //setup_timer_2(T2_DIV_BY_16,255,2); //For 8MHz
....................     setup_timer_2(T2_DIV_BY_16,255,1); //For 4MHz
0A9C:  MOVLW  00
0A9D:  MOVWF  78
0A9E:  IORLW  06
0A9F:  MOVWF  12
0AA0:  MOVLW  FF
0AA1:  BSF    03.5
0AA2:  MOVWF  12
....................     output_high(PIN_D3);
0AA3:  BCF    08.3
0AA4:  BCF    03.5
0AA5:  BSF    08.3
.................... 
....................     kbd_init();
0AA6:  BCF    0A.3
0AA7:  GOTO   0AB
0AA8:  BSF    0A.3
....................     lcd_init();
0AA9:  BCF    0A.3
0AAA:  GOTO   115
0AAB:  BSF    0A.3
.................... 
....................     port_b_pullups(TRUE);   //habilitan las resistencias pull up para evitar resistencias en el teclado
0AAC:  BSF    03.5
0AAD:  BCF    01.7
....................     i=0;
0AAE:  BCF    03.5
0AAF:  CLRF   2B
....................     delay_ms(2000);
0AB0:  MOVLW  08
0AB1:  MOVWF  3C
0AB2:  MOVLW  FA
0AB3:  MOVWF  4B
0AB4:  BCF    0A.3
0AB5:  CALL   0AE
0AB6:  BSF    0A.3
0AB7:  DECFSZ 3C,F
0AB8:  GOTO   2B2
....................     printf("Examen Pablo Garcia Brenes y Marco Fernandez Granados.\n");
0AB9:  MOVLW  5F
0ABA:  BSF    03.6
0ABB:  MOVWF  0D
0ABC:  MOVLW  00
0ABD:  MOVWF  0F
0ABE:  BCF    0A.3
0ABF:  BCF    03.6
0AC0:  GOTO   153
0AC1:  BSF    0A.3
....................     
....................     
....................     while (TRUE)   {
....................         //Muestra Temperatura
....................         temperatura=(float)read_adc()/2;
0AC2:  BSF    1F.2
0AC3:  BTFSC  1F.2
0AC4:  GOTO   2C3
0AC5:  MOVF   1E,W
0AC6:  MOVWF  79
0AC7:  BSF    03.5
0AC8:  MOVF   1E,W
0AC9:  MOVWF  78
0ACA:  MOVF   79,W
0ACB:  MOVWF  7A
0ACC:  MOVF   1E,W
0ACD:  BCF    03.5
0ACE:  MOVWF  3C
0ACF:  MOVF   79,W
0AD0:  MOVWF  3D
0AD1:  BCF    0A.3
0AD2:  GOTO   1AD
0AD3:  BSF    0A.3
0AD4:  MOVF   7A,W
0AD5:  MOVWF  3F
0AD6:  MOVF   79,W
0AD7:  MOVWF  3E
0AD8:  MOVF   78,W
0AD9:  MOVWF  3D
0ADA:  MOVF   77,W
0ADB:  MOVWF  3C
0ADC:  MOVF   7A,W
0ADD:  MOVWF  43
0ADE:  MOVF   79,W
0ADF:  MOVWF  42
0AE0:  MOVF   78,W
0AE1:  MOVWF  41
0AE2:  MOVF   77,W
0AE3:  MOVWF  40
0AE4:  CLRF   47
0AE5:  CLRF   46
0AE6:  CLRF   45
0AE7:  MOVLW  80
0AE8:  MOVWF  44
0AE9:  BCF    0A.3
0AEA:  GOTO   1CC
0AEB:  BSF    0A.3
0AEC:  MOVF   7A,W
0AED:  MOVWF  29
0AEE:  MOVF   79,W
0AEF:  MOVWF  28
0AF0:  MOVF   78,W
0AF1:  MOVWF  27
0AF2:  MOVF   77,W
0AF3:  MOVWF  26
....................         temperatura=temperatura-1;
0AF4:  BSF    03.1
0AF5:  MOVF   29,W
0AF6:  MOVWF  3F
0AF7:  MOVF   28,W
0AF8:  MOVWF  3E
0AF9:  MOVF   27,W
0AFA:  MOVWF  3D
0AFB:  MOVF   26,W
0AFC:  MOVWF  3C
0AFD:  CLRF   43
0AFE:  CLRF   42
0AFF:  CLRF   41
0B00:  MOVLW  7F
0B01:  MOVWF  40
0B02:  BCF    0A.3
0B03:  CALL   298
0B04:  BSF    0A.3
0B05:  MOVF   7A,W
0B06:  MOVWF  29
0B07:  MOVF   79,W
0B08:  MOVWF  28
0B09:  MOVF   78,W
0B0A:  MOVWF  27
0B0B:  MOVF   77,W
0B0C:  MOVWF  26
....................         buttonState=input_state(PIN_C5);
0B0D:  CLRF   37
0B0E:  BTFSC  07.5
0B0F:  INCF   37,F
....................         if(buttonState==0){
0B10:  MOVF   37,F
0B11:  BTFSS  03.2
0B12:  GOTO   31C
....................             if(maintinaing==0){
0B13:  MOVF   36,F
0B14:  BTFSS  03.2
0B15:  GOTO   319
....................                 maintinaing=1;
0B16:  MOVLW  01
0B17:  MOVWF  36
....................             }
0B18:  GOTO   31C
....................             else if(maintinaing==1){
0B19:  DECFSZ 36,W
0B1A:  GOTO   31C
....................                 maintinaing=0;
0B1B:  CLRF   36
....................             }
....................         }
....................         if(temperatura>previousTemp && temperatura-previousTemp>1){
0B1C:  MOVF   3B,W
0B1D:  MOVWF  43
0B1E:  MOVF   3A,W
0B1F:  MOVWF  42
0B20:  MOVF   39,W
0B21:  MOVWF  41
0B22:  MOVF   38,W
0B23:  MOVWF  40
0B24:  MOVF   29,W
0B25:  MOVWF  47
0B26:  MOVF   28,W
0B27:  MOVWF  46
0B28:  MOVF   27,W
0B29:  MOVWF  45
0B2A:  MOVF   26,W
0B2B:  MOVWF  44
0B2C:  BCF    0A.3
0B2D:  CALL   3D9
0B2E:  BSF    0A.3
0B2F:  BTFSS  03.0
0B30:  GOTO   39A
0B31:  BSF    03.1
0B32:  MOVF   29,W
0B33:  MOVWF  3F
0B34:  MOVF   28,W
0B35:  MOVWF  3E
0B36:  MOVF   27,W
0B37:  MOVWF  3D
0B38:  MOVF   26,W
0B39:  MOVWF  3C
0B3A:  MOVF   3B,W
0B3B:  MOVWF  43
0B3C:  MOVF   3A,W
0B3D:  MOVWF  42
0B3E:  MOVF   39,W
0B3F:  MOVWF  41
0B40:  MOVF   38,W
0B41:  MOVWF  40
0B42:  BCF    0A.3
0B43:  CALL   298
0B44:  BSF    0A.3
0B45:  MOVF   7A,W
0B46:  MOVWF  3F
0B47:  MOVF   79,W
0B48:  MOVWF  3E
0B49:  MOVF   78,W
0B4A:  MOVWF  3D
0B4B:  MOVF   77,W
0B4C:  MOVWF  3C
0B4D:  CLRF   43
0B4E:  CLRF   42
0B4F:  CLRF   41
0B50:  MOVLW  7F
0B51:  MOVWF  40
0B52:  MOVF   3F,W
0B53:  MOVWF  47
0B54:  MOVF   3E,W
0B55:  MOVWF  46
0B56:  MOVF   3D,W
0B57:  MOVWF  45
0B58:  MOVF   3C,W
0B59:  MOVWF  44
0B5A:  BCF    0A.3
0B5B:  CALL   3D9
0B5C:  BSF    0A.3
0B5D:  BTFSS  03.0
0B5E:  GOTO   39A
....................             lcd_gotoxy(1,1);           
0B5F:  MOVLW  01
0B60:  MOVWF  4B
0B61:  MOVWF  4C
0B62:  BCF    0A.3
0B63:  CALL   418
0B64:  BSF    0A.3
....................             printf(lcd_putc,"\fTEMP: %f ",temperatura);
0B65:  MOVLW  7B
0B66:  BSF    03.6
0B67:  MOVWF  0D
0B68:  MOVLW  00
0B69:  MOVWF  0F
0B6A:  BCF    03.0
0B6B:  MOVLW  07
0B6C:  BCF    03.6
0B6D:  MOVWF  3D
0B6E:  BCF    0A.3
0B6F:  CALL   456
0B70:  BSF    0A.3
0B71:  MOVLW  89
0B72:  MOVWF  04
0B73:  MOVF   29,W
0B74:  MOVWF  40
0B75:  MOVF   28,W
0B76:  MOVWF  3F
0B77:  MOVF   27,W
0B78:  MOVWF  3E
0B79:  MOVF   26,W
0B7A:  MOVWF  3D
0B7B:  MOVLW  02
0B7C:  MOVWF  41
0B7D:  BCF    0A.3
0B7E:  CALL   590
0B7F:  BSF    0A.3
0B80:  MOVLW  20
0B81:  MOVWF  4A
0B82:  BCF    0A.3
0B83:  CALL   42A
0B84:  BSF    0A.3
....................             lcd_gotoxy(12,1);
0B85:  MOVLW  0C
0B86:  MOVWF  4B
0B87:  MOVLW  01
0B88:  MOVWF  4C
0B89:  BCF    0A.3
0B8A:  CALL   418
0B8B:  BSF    0A.3
....................             printf (lcd_putc,"C");
0B8C:  MOVLW  43
0B8D:  MOVWF  4A
0B8E:  BCF    0A.3
0B8F:  CALL   42A
0B90:  BSF    0A.3
....................             previousTemp=temperatura;
0B91:  MOVF   29,W
0B92:  MOVWF  3B
0B93:  MOVF   28,W
0B94:  MOVWF  3A
0B95:  MOVF   27,W
0B96:  MOVWF  39
0B97:  MOVF   26,W
0B98:  MOVWF  38
....................         }
0B99:  GOTO   403
....................         else if( temperatura-previousTemp<-1){
0B9A:  BSF    03.1
0B9B:  MOVF   29,W
0B9C:  MOVWF  3F
0B9D:  MOVF   28,W
0B9E:  MOVWF  3E
0B9F:  MOVF   27,W
0BA0:  MOVWF  3D
0BA1:  MOVF   26,W
0BA2:  MOVWF  3C
0BA3:  MOVF   3B,W
0BA4:  MOVWF  43
0BA5:  MOVF   3A,W
0BA6:  MOVWF  42
0BA7:  MOVF   39,W
0BA8:  MOVWF  41
0BA9:  MOVF   38,W
0BAA:  MOVWF  40
0BAB:  BCF    0A.3
0BAC:  CALL   298
0BAD:  BSF    0A.3
0BAE:  MOVF   7A,W
0BAF:  MOVWF  3F
0BB0:  MOVF   79,W
0BB1:  MOVWF  3E
0BB2:  MOVF   78,W
0BB3:  MOVWF  3D
0BB4:  MOVF   77,W
0BB5:  MOVWF  3C
0BB6:  MOVF   3F,W
0BB7:  MOVWF  43
0BB8:  MOVF   3E,W
0BB9:  MOVWF  42
0BBA:  MOVF   3D,W
0BBB:  MOVWF  41
0BBC:  MOVF   3C,W
0BBD:  MOVWF  40
0BBE:  CLRF   47
0BBF:  CLRF   46
0BC0:  MOVLW  80
0BC1:  MOVWF  45
0BC2:  MOVLW  7F
0BC3:  MOVWF  44
0BC4:  BCF    0A.3
0BC5:  CALL   3D9
0BC6:  BSF    0A.3
0BC7:  BTFSS  03.0
0BC8:  GOTO   403
....................             lcd_gotoxy(1,1);           
0BC9:  MOVLW  01
0BCA:  MOVWF  4B
0BCB:  MOVWF  4C
0BCC:  BCF    0A.3
0BCD:  CALL   418
0BCE:  BSF    0A.3
....................             printf(lcd_putc,"\fTEMP: %f ",temperatura);
0BCF:  MOVLW  81
0BD0:  BSF    03.6
0BD1:  MOVWF  0D
0BD2:  MOVLW  00
0BD3:  MOVWF  0F
0BD4:  BCF    03.0
0BD5:  MOVLW  07
0BD6:  BCF    03.6
0BD7:  MOVWF  3D
0BD8:  BCF    0A.3
0BD9:  CALL   456
0BDA:  BSF    0A.3
0BDB:  MOVLW  89
0BDC:  MOVWF  04
0BDD:  MOVF   29,W
0BDE:  MOVWF  40
0BDF:  MOVF   28,W
0BE0:  MOVWF  3F
0BE1:  MOVF   27,W
0BE2:  MOVWF  3E
0BE3:  MOVF   26,W
0BE4:  MOVWF  3D
0BE5:  MOVLW  02
0BE6:  MOVWF  41
0BE7:  BCF    0A.3
0BE8:  CALL   590
0BE9:  BSF    0A.3
0BEA:  MOVLW  20
0BEB:  MOVWF  4A
0BEC:  BCF    0A.3
0BED:  CALL   42A
0BEE:  BSF    0A.3
....................             lcd_gotoxy(12,1);
0BEF:  MOVLW  0C
0BF0:  MOVWF  4B
0BF1:  MOVLW  01
0BF2:  MOVWF  4C
0BF3:  BCF    0A.3
0BF4:  CALL   418
0BF5:  BSF    0A.3
....................             printf (lcd_putc,"C");
0BF6:  MOVLW  43
0BF7:  MOVWF  4A
0BF8:  BCF    0A.3
0BF9:  CALL   42A
0BFA:  BSF    0A.3
....................             previousTemp=temperatura;
0BFB:  MOVF   29,W
0BFC:  MOVWF  3B
0BFD:  MOVF   28,W
0BFE:  MOVWF  3A
0BFF:  MOVF   27,W
0C00:  MOVWF  39
0C01:  MOVF   26,W
0C02:  MOVWF  38
....................         }
.................... 
....................         if(maintinaing==0){
0C03:  MOVF   36,F
0C04:  BTFSS  03.2
0C05:  GOTO   4DC
....................             output_high(PIN_D3);
0C06:  BSF    03.5
0C07:  BCF    08.3
0C08:  BCF    03.5
0C09:  BSF    08.3
....................             //lee teclado
....................             keypad=kbd_getc();           
0C0A:  BCF    0A.3
0C0B:  GOTO   653
0C0C:  BSF    0A.3
0C0D:  MOVF   78,W
0C0E:  MOVWF  2A
....................             if(keypad!=0){
0C0F:  MOVF   2A,F
0C10:  BTFSC  03.2
0C11:  GOTO   437
....................                 printf(lcd_putc,"\f tecla No= %c",keypad);
0C12:  MOVLW  87
0C13:  BSF    03.6
0C14:  MOVWF  0D
0C15:  MOVLW  00
0C16:  MOVWF  0F
0C17:  BCF    03.0
0C18:  MOVLW  0C
0C19:  BCF    03.6
0C1A:  MOVWF  3D
0C1B:  BCF    0A.3
0C1C:  CALL   456
0C1D:  BSF    0A.3
0C1E:  MOVF   2A,W
0C1F:  MOVWF  4A
0C20:  BCF    0A.3
0C21:  CALL   42A
0C22:  BSF    0A.3
....................                 if(keypad=='#'){
0C23:  MOVF   2A,W
0C24:  SUBLW  23
0C25:  BTFSS  03.2
0C26:  GOTO   42A
....................                     checkPassword=1;
0C27:  MOVLW  01
0C28:  MOVWF  34
....................                 }
0C29:  GOTO   437
....................                 else if(i>4){
0C2A:  MOVF   2B,W
0C2B:  SUBLW  04
0C2C:  BTFSC  03.0
0C2D:  GOTO   430
....................                     valid=0;
0C2E:  CLRF   35
....................                 }
0C2F:  GOTO   437
....................                 else{
....................                     keys_pressed[i]=keypad;
0C30:  MOVLW  2C
0C31:  ADDWF  2B,W
0C32:  MOVWF  04
0C33:  BCF    03.7
0C34:  MOVF   2A,W
0C35:  MOVWF  00
....................                     i++;   
0C36:  INCF   2B,F
....................                 }
....................             }
....................             //Cuando digita contrasena
....................             if(checkPassword==1){
0C37:  DECFSZ 34,W
0C38:  GOTO   4DB
....................                 if( keys_pressed[0]=='1' && 
....................                     keys_pressed[1]=='2' && 
....................                     keys_pressed[2]=='3' &&
....................                     keys_pressed[3]=='4' &&
....................                     keys_pressed[4]=='5' && valid==1){
0C39:  MOVF   2C,W
0C3A:  SUBLW  31
0C3B:  BTFSS  03.2
0C3C:  GOTO   466
0C3D:  MOVF   2D,W
0C3E:  SUBLW  32
0C3F:  BTFSS  03.2
0C40:  GOTO   466
0C41:  MOVF   2E,W
0C42:  SUBLW  33
0C43:  BTFSS  03.2
0C44:  GOTO   466
0C45:  MOVF   2F,W
0C46:  SUBLW  34
0C47:  BTFSS  03.2
0C48:  GOTO   466
0C49:  MOVF   30,W
0C4A:  SUBLW  35
0C4B:  BTFSS  03.2
0C4C:  GOTO   466
0C4D:  DECFSZ 35,W
0C4E:  GOTO   466
....................                     i=0;
0C4F:  CLRF   2B
....................                     printf(lcd_putc,"\fPIN Correcto");
0C50:  MOVLW  8F
0C51:  BSF    03.6
0C52:  MOVWF  0D
0C53:  MOVLW  00
0C54:  MOVWF  0F
0C55:  BCF    0A.3
0C56:  BCF    03.6
0C57:  CALL   6DD
0C58:  BSF    0A.3
....................                     delay_ms(2000);
0C59:  MOVLW  08
0C5A:  MOVWF  3C
0C5B:  MOVLW  FA
0C5C:  MOVWF  4B
0C5D:  BCF    0A.3
0C5E:  CALL   0AE
0C5F:  BSF    0A.3
0C60:  DECFSZ 3C,F
0C61:  GOTO   45B
....................                     checkTemp(1);
0C62:  MOVLW  01
0C63:  MOVWF  3C
0C64:  CALL   0CF
....................                 }
0C65:  GOTO   4D8
....................                 else if(keys_pressed[0]=='6' && 
....................                         keys_pressed[1]=='7' && 
....................                         keys_pressed[2]=='8' &&
....................                         keys_pressed[3]=='9' &&
....................                         keys_pressed[4]=='0' && valid==1){
0C66:  MOVF   2C,W
0C67:  SUBLW  36
0C68:  BTFSS  03.2
0C69:  GOTO   493
0C6A:  MOVF   2D,W
0C6B:  SUBLW  37
0C6C:  BTFSS  03.2
0C6D:  GOTO   493
0C6E:  MOVF   2E,W
0C6F:  SUBLW  38
0C70:  BTFSS  03.2
0C71:  GOTO   493
0C72:  MOVF   2F,W
0C73:  SUBLW  39
0C74:  BTFSS  03.2
0C75:  GOTO   493
0C76:  MOVF   30,W
0C77:  SUBLW  30
0C78:  BTFSS  03.2
0C79:  GOTO   493
0C7A:  DECFSZ 35,W
0C7B:  GOTO   493
....................                     i=0;
0C7C:  CLRF   2B
....................                     printf(lcd_putc,"\fPIN Correcto");
0C7D:  MOVLW  96
0C7E:  BSF    03.6
0C7F:  MOVWF  0D
0C80:  MOVLW  00
0C81:  MOVWF  0F
0C82:  BCF    0A.3
0C83:  BCF    03.6
0C84:  CALL   6DD
0C85:  BSF    0A.3
....................                     delay_ms(2000);
0C86:  MOVLW  08
0C87:  MOVWF  3C
0C88:  MOVLW  FA
0C89:  MOVWF  4B
0C8A:  BCF    0A.3
0C8B:  CALL   0AE
0C8C:  BSF    0A.3
0C8D:  DECFSZ 3C,F
0C8E:  GOTO   488
....................                     checkTemp(2);
0C8F:  MOVLW  02
0C90:  MOVWF  3C
0C91:  CALL   0CF
....................                 }
0C92:  GOTO   4D8
....................                 else {
....................                     printf(lcd_putc,"\fPIN Incorrecto");
0C93:  MOVLW  9D
0C94:  BSF    03.6
0C95:  MOVWF  0D
0C96:  MOVLW  00
0C97:  MOVWF  0F
0C98:  BCF    0A.3
0C99:  BCF    03.6
0C9A:  CALL   6DD
0C9B:  BSF    0A.3
....................                     i=0;
0C9C:  CLRF   2B
....................                     delay_ms(2000);
0C9D:  MOVLW  08
0C9E:  MOVWF  3C
0C9F:  MOVLW  FA
0CA0:  MOVWF  4B
0CA1:  BCF    0A.3
0CA2:  CALL   0AE
0CA3:  BSF    0A.3
0CA4:  DECFSZ 3C,F
0CA5:  GOTO   49F
....................                     lcd_gotoxy(1,1);           
0CA6:  MOVLW  01
0CA7:  MOVWF  4B
0CA8:  MOVWF  4C
0CA9:  BCF    0A.3
0CAA:  CALL   418
0CAB:  BSF    0A.3
....................                     printf(lcd_putc,"\fTEMP: %f ",temperatura);
0CAC:  MOVLW  A5
0CAD:  BSF    03.6
0CAE:  MOVWF  0D
0CAF:  MOVLW  00
0CB0:  MOVWF  0F
0CB1:  BCF    03.0
0CB2:  MOVLW  07
0CB3:  BCF    03.6
0CB4:  MOVWF  3D
0CB5:  BCF    0A.3
0CB6:  CALL   456
0CB7:  BSF    0A.3
0CB8:  MOVLW  89
0CB9:  MOVWF  04
0CBA:  MOVF   29,W
0CBB:  MOVWF  40
0CBC:  MOVF   28,W
0CBD:  MOVWF  3F
0CBE:  MOVF   27,W
0CBF:  MOVWF  3E
0CC0:  MOVF   26,W
0CC1:  MOVWF  3D
0CC2:  MOVLW  02
0CC3:  MOVWF  41
0CC4:  BCF    0A.3
0CC5:  CALL   590
0CC6:  BSF    0A.3
0CC7:  MOVLW  20
0CC8:  MOVWF  4A
0CC9:  BCF    0A.3
0CCA:  CALL   42A
0CCB:  BSF    0A.3
....................                     lcd_gotoxy(12,1);
0CCC:  MOVLW  0C
0CCD:  MOVWF  4B
0CCE:  MOVLW  01
0CCF:  MOVWF  4C
0CD0:  BCF    0A.3
0CD1:  CALL   418
0CD2:  BSF    0A.3
....................                     printf (lcd_putc,"C");
0CD3:  MOVLW  43
0CD4:  MOVWF  4A
0CD5:  BCF    0A.3
0CD6:  CALL   42A
0CD7:  BSF    0A.3
....................                 }
....................                 checkPassword=0;
0CD8:  CLRF   34
....................                 valid=1;
0CD9:  MOVLW  01
0CDA:  MOVWF  35
....................             }
....................         }
0CDB:  GOTO   4E2
....................         else if(maintinaing==1){
0CDC:  DECFSZ 36,W
0CDD:  GOTO   4E2
....................             output_low(PIN_D3);
0CDE:  BSF    03.5
0CDF:  BCF    08.3
0CE0:  BCF    03.5
0CE1:  BCF    08.3
....................         }
0CE2:  GOTO   2C2
....................         
....................     }
.................... }
0CE3:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
