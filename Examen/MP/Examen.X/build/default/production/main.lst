CCS PCM C Compiler, Version 5.088d, 1               10-Nov-19 21:53
Compiler operating in Evaluation Mode
To obtain a fully enabled compiler visit www.ccsinfo.com/products

               Filename:   C:\Users\pablo\Documents\1-TEC\Arqui1\Examen\MP\Examen.X\build\default\production\main.lst

               ROM used:   1677 words (20%)
                           Largest free fragment is 2048
               RAM used:   30 (8%) at main() level
                           52 (14%) worst case
               Stack used: 6 locations
               Stack size: 8

*
0000:  MOVLW  05
0001:  MOVWF  0A
0002:  GOTO   5A9
0003:  NOP
.................... 
.................... #include <16f877.h>                //llamamos la libreria del micro
.................... //////////// Standard Header file for the PIC16F877 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC16F877
0004:  BCF    0A.0
0005:  BCF    0A.1
0006:  BCF    0A.2
0007:  ADDWF  02,F
0008:  RETLW  31
0009:  RETLW  32
000A:  RETLW  33
000B:  RETLW  34
000C:  RETLW  35
000D:  RETLW  36
000E:  RETLW  37
000F:  RETLW  38
0010:  RETLW  39
0011:  RETLW  2A
0012:  RETLW  30
0013:  RETLW  23
0014:  DATA 0C,38
0015:  DATA F5,32
0016:  DATA 72,3A
0017:  DATA 61,10
0018:  DATA 61,31
0019:  DATA E9,32
001A:  DATA 72,3A
001B:  DATA 61,00
001C:  DATA 0C,38
001D:  DATA F5,32
001E:  DATA 72,3A
001F:  DATA 61,10
0020:  DATA E3,32
0021:  DATA 72,39
0022:  DATA 61,32
0023:  DATA 61,00
0024:  DATA 0C,38
0025:  DATA F5,32
0026:  DATA 72,3A
0027:  DATA 61,10
0028:  DATA 61,31
0029:  DATA E9,32
002A:  DATA 72,3A
002B:  DATA 61,00
002C:  DATA 0C,38
002D:  DATA F5,32
002E:  DATA 72,3A
002F:  DATA 61,10
0030:  DATA E3,32
0031:  DATA 72,39
0032:  DATA 61,32
0033:  DATA 61,00
0034:  DATA D4,22
0035:  DATA 4D,28
0036:  DATA 3A,10
0037:  DATA 00,00
0038:  DATA 0C,28
0039:  DATA 49,27
003A:  DATA A0,24
003B:  DATA EE,31
003C:  DATA 6F,39
003D:  DATA F2,32
003E:  DATA 63,3A
003F:  DATA 6F,00
*
0124:  MOVF   0B,W
0125:  MOVWF  35
0126:  BCF    0B.7
0127:  BSF    03.5
0128:  BSF    03.6
0129:  BSF    0C.7
012A:  BSF    0C.0
012B:  NOP
012C:  NOP
012D:  BCF    03.5
012E:  BCF    03.6
012F:  BTFSC  35.7
0130:  BSF    0B.7
0131:  BSF    03.6
0132:  MOVF   0C,W
0133:  ANDLW  7F
0134:  BTFSC  03.2
0135:  GOTO   178
0136:  BCF    03.6
0137:  MOVWF  35
0138:  BSF    03.6
0139:  MOVF   0D,W
013A:  BCF    03.6
013B:  MOVWF  36
013C:  BSF    03.6
013D:  MOVF   0F,W
013E:  BCF    03.6
013F:  MOVWF  37
0140:  MOVF   35,W
0141:  MOVWF  42
0142:  CALL   0F8
0143:  MOVF   36,W
0144:  BSF    03.6
0145:  MOVWF  0D
0146:  BCF    03.6
0147:  MOVF   37,W
0148:  BSF    03.6
0149:  MOVWF  0F
014A:  BCF    03.6
014B:  MOVF   0B,W
014C:  MOVWF  38
014D:  BCF    0B.7
014E:  BSF    03.5
014F:  BSF    03.6
0150:  BSF    0C.7
0151:  BSF    0C.0
0152:  NOP
0153:  NOP
0154:  BCF    03.5
0155:  BCF    03.6
0156:  BTFSC  38.7
0157:  BSF    0B.7
0158:  BSF    03.6
0159:  RLF    0C,W
015A:  RLF    0E,W
015B:  ANDLW  7F
015C:  BTFSC  03.2
015D:  GOTO   178
015E:  BCF    03.6
015F:  MOVWF  35
0160:  BSF    03.6
0161:  MOVF   0D,W
0162:  BCF    03.6
0163:  MOVWF  36
0164:  BSF    03.6
0165:  MOVF   0F,W
0166:  BCF    03.6
0167:  MOVWF  37
0168:  MOVF   35,W
0169:  MOVWF  42
016A:  CALL   0F8
016B:  MOVF   36,W
016C:  BSF    03.6
016D:  MOVWF  0D
016E:  BCF    03.6
016F:  MOVF   37,W
0170:  BSF    03.6
0171:  MOVWF  0F
0172:  INCF   0D,F
0173:  BTFSC  03.2
0174:  INCF   0F,F
0175:  BCF    03.6
0176:  GOTO   124
0177:  BSF    03.6
0178:  BCF    03.6
0179:  RETURN
017A:  MOVLW  8E
017B:  MOVWF  77
017C:  MOVF   36,W
017D:  MOVWF  78
017E:  MOVF   35,W
017F:  MOVWF  79
0180:  CLRF   7A
0181:  MOVF   78,F
0182:  BTFSS  03.2
0183:  GOTO   18E
0184:  MOVF   79,W
0185:  MOVWF  78
0186:  CLRF   79
0187:  MOVLW  08
0188:  SUBWF  77,F
0189:  MOVF   78,F
018A:  BTFSS  03.2
018B:  GOTO   18E
018C:  CLRF   77
018D:  GOTO   196
018E:  BCF    03.0
018F:  BTFSC  78.7
0190:  GOTO   195
0191:  RLF    79,F
0192:  RLF    78,F
0193:  DECF   77,F
0194:  GOTO   18E
0195:  BCF    78.7
0196:  BCF    0A.3
0197:  BCF    0A.4
0198:  GOTO   604 (RETURN)
0199:  MOVF   39,W
019A:  BTFSC  03.2
019B:  GOTO   25E
019C:  MOVWF  45
019D:  MOVF   3D,W
019E:  BTFSC  03.2
019F:  GOTO   25E
01A0:  SUBWF  45,F
01A1:  BTFSS  03.0
01A2:  GOTO   1A8
01A3:  MOVLW  7F
01A4:  ADDWF  45,F
01A5:  BTFSC  03.0
01A6:  GOTO   25E
01A7:  GOTO   1AE
01A8:  MOVLW  81
01A9:  SUBWF  45,F
01AA:  BTFSS  03.0
01AB:  GOTO   25E
01AC:  BTFSC  03.2
01AD:  GOTO   25E
01AE:  MOVF   45,W
01AF:  MOVWF  77
01B0:  CLRF   78
01B1:  CLRF   79
01B2:  CLRF   7A
01B3:  CLRF   44
01B4:  MOVF   3A,W
01B5:  MOVWF  43
01B6:  BSF    43.7
01B7:  MOVF   3B,W
01B8:  MOVWF  42
01B9:  MOVF   3C,W
01BA:  MOVWF  41
01BB:  MOVLW  19
01BC:  MOVWF  45
01BD:  MOVF   40,W
01BE:  SUBWF  41,F
01BF:  BTFSC  03.0
01C0:  GOTO   1D1
01C1:  MOVLW  01
01C2:  SUBWF  42,F
01C3:  BTFSC  03.0
01C4:  GOTO   1D1
01C5:  SUBWF  43,F
01C6:  BTFSC  03.0
01C7:  GOTO   1D1
01C8:  SUBWF  44,F
01C9:  BTFSC  03.0
01CA:  GOTO   1D1
01CB:  INCF   44,F
01CC:  INCF   43,F
01CD:  INCF   42,F
01CE:  MOVF   40,W
01CF:  ADDWF  41,F
01D0:  GOTO   203
01D1:  MOVF   3F,W
01D2:  SUBWF  42,F
01D3:  BTFSC  03.0
01D4:  GOTO   1EC
01D5:  MOVLW  01
01D6:  SUBWF  43,F
01D7:  BTFSC  03.0
01D8:  GOTO   1EC
01D9:  SUBWF  44,F
01DA:  BTFSC  03.0
01DB:  GOTO   1EC
01DC:  INCF   44,F
01DD:  INCF   43,F
01DE:  MOVF   3F,W
01DF:  ADDWF  42,F
01E0:  MOVF   40,W
01E1:  ADDWF  41,F
01E2:  BTFSS  03.0
01E3:  GOTO   203
01E4:  INCF   42,F
01E5:  BTFSS  03.2
01E6:  GOTO   203
01E7:  INCF   43,F
01E8:  BTFSS  03.2
01E9:  GOTO   203
01EA:  INCF   44,F
01EB:  GOTO   203
01EC:  MOVF   3E,W
01ED:  IORLW  80
01EE:  SUBWF  43,F
01EF:  BTFSC  03.0
01F0:  GOTO   202
01F1:  MOVLW  01
01F2:  SUBWF  44,F
01F3:  BTFSC  03.0
01F4:  GOTO   202
01F5:  INCF   44,F
01F6:  MOVF   3E,W
01F7:  IORLW  80
01F8:  ADDWF  43,F
01F9:  MOVF   3F,W
01FA:  ADDWF  42,F
01FB:  BTFSS  03.0
01FC:  GOTO   1E0
01FD:  INCF   43,F
01FE:  BTFSS  03.2
01FF:  GOTO   1E0
0200:  INCF   44,F
0201:  GOTO   1E0
0202:  BSF    7A.0
0203:  DECFSZ 45,F
0204:  GOTO   206
0205:  GOTO   211
0206:  BCF    03.0
0207:  RLF    41,F
0208:  RLF    42,F
0209:  RLF    43,F
020A:  RLF    44,F
020B:  BCF    03.0
020C:  RLF    7A,F
020D:  RLF    79,F
020E:  RLF    78,F
020F:  RLF    46,F
0210:  GOTO   1BD
0211:  BTFSS  46.0
0212:  GOTO   219
0213:  BCF    03.0
0214:  RRF    78,F
0215:  RRF    79,F
0216:  RRF    7A,F
0217:  RRF    46,F
0218:  GOTO   21C
0219:  DECF   77,F
021A:  BTFSC  03.2
021B:  GOTO   25E
021C:  BTFSC  46.7
021D:  GOTO   245
021E:  BCF    03.0
021F:  RLF    41,F
0220:  RLF    42,F
0221:  RLF    43,F
0222:  RLF    44,F
0223:  MOVF   40,W
0224:  SUBWF  41,F
0225:  BTFSC  03.0
0226:  GOTO   231
0227:  MOVLW  01
0228:  SUBWF  42,F
0229:  BTFSC  03.0
022A:  GOTO   231
022B:  SUBWF  43,F
022C:  BTFSC  03.0
022D:  GOTO   231
022E:  SUBWF  44,F
022F:  BTFSS  03.0
0230:  GOTO   254
0231:  MOVF   3F,W
0232:  SUBWF  42,F
0233:  BTFSC  03.0
0234:  GOTO   23C
0235:  MOVLW  01
0236:  SUBWF  43,F
0237:  BTFSC  03.0
0238:  GOTO   23C
0239:  SUBWF  44,F
023A:  BTFSS  03.0
023B:  GOTO   254
023C:  MOVF   3E,W
023D:  IORLW  80
023E:  SUBWF  43,F
023F:  BTFSC  03.0
0240:  GOTO   245
0241:  MOVLW  01
0242:  SUBWF  44,F
0243:  BTFSS  03.0
0244:  GOTO   254
0245:  INCF   7A,F
0246:  BTFSS  03.2
0247:  GOTO   254
0248:  INCF   79,F
0249:  BTFSS  03.2
024A:  GOTO   254
024B:  INCF   78,F
024C:  BTFSS  03.2
024D:  GOTO   254
024E:  INCF   77,F
024F:  BTFSC  03.2
0250:  GOTO   25E
0251:  RRF    78,F
0252:  RRF    79,F
0253:  RRF    7A,F
0254:  MOVF   3A,W
0255:  MOVWF  45
0256:  MOVF   3E,W
0257:  XORWF  45,F
0258:  BTFSS  45.7
0259:  GOTO   25C
025A:  BSF    78.7
025B:  GOTO   262
025C:  BCF    78.7
025D:  GOTO   262
025E:  CLRF   77
025F:  CLRF   78
0260:  CLRF   79
0261:  CLRF   7A
0262:  BCF    0A.3
0263:  BCF    0A.4
0264:  GOTO   61A (RETURN)
0265:  BTFSC  03.1
0266:  GOTO   26A
0267:  MOVLW  4A
0268:  MOVWF  04
0269:  BCF    03.7
026A:  CLRF   77
026B:  CLRF   78
026C:  CLRF   79
026D:  CLRF   7A
026E:  CLRF   4A
026F:  CLRF   4B
0270:  CLRF   4C
0271:  CLRF   4D
0272:  MOVF   49,W
0273:  IORWF  48,W
0274:  IORWF  47,W
0275:  IORWF  46,W
0276:  BTFSC  03.2
0277:  GOTO   2A8
0278:  MOVLW  20
0279:  MOVWF  4E
027A:  BCF    03.0
027B:  RLF    42,F
027C:  RLF    43,F
027D:  RLF    44,F
027E:  RLF    45,F
027F:  RLF    4A,F
0280:  RLF    4B,F
0281:  RLF    4C,F
0282:  RLF    4D,F
0283:  MOVF   49,W
0284:  SUBWF  4D,W
0285:  BTFSS  03.2
0286:  GOTO   291
0287:  MOVF   48,W
0288:  SUBWF  4C,W
0289:  BTFSS  03.2
028A:  GOTO   291
028B:  MOVF   47,W
028C:  SUBWF  4B,W
028D:  BTFSS  03.2
028E:  GOTO   291
028F:  MOVF   46,W
0290:  SUBWF  4A,W
0291:  BTFSS  03.0
0292:  GOTO   2A2
0293:  MOVF   46,W
0294:  SUBWF  4A,F
0295:  MOVF   47,W
0296:  BTFSS  03.0
0297:  INCFSZ 47,W
0298:  SUBWF  4B,F
0299:  MOVF   48,W
029A:  BTFSS  03.0
029B:  INCFSZ 48,W
029C:  SUBWF  4C,F
029D:  MOVF   49,W
029E:  BTFSS  03.0
029F:  INCFSZ 49,W
02A0:  SUBWF  4D,F
02A1:  BSF    03.0
02A2:  RLF    77,F
02A3:  RLF    78,F
02A4:  RLF    79,F
02A5:  RLF    7A,F
02A6:  DECFSZ 4E,F
02A7:  GOTO   27A
02A8:  MOVF   4A,W
02A9:  MOVWF  00
02AA:  INCF   04,F
02AB:  MOVF   4B,W
02AC:  MOVWF  00
02AD:  INCF   04,F
02AE:  MOVF   4C,W
02AF:  MOVWF  00
02B0:  INCF   04,F
02B1:  MOVF   4D,W
02B2:  MOVWF  00
02B3:  RETURN
02B4:  MOVF   04,W
02B5:  MOVWF  3A
02B6:  MOVF   39,W
02B7:  MOVWF  3C
02B8:  BTFSC  03.2
02B9:  GOTO   346
02BA:  MOVF   38,W
02BB:  MOVWF  45
02BC:  MOVF   37,W
02BD:  MOVWF  44
02BE:  MOVF   36,W
02BF:  MOVWF  43
02C0:  MOVF   35,W
02C1:  MOVWF  42
02C2:  CLRF   49
02C3:  CLRF   48
02C4:  MOVLW  20
02C5:  MOVWF  47
02C6:  MOVLW  82
02C7:  MOVWF  46
02C8:  MOVF   42,W
02C9:  BTFSC  03.2
02CA:  GOTO   338
02CB:  MOVWF  4A
02CC:  MOVF   46,W
02CD:  BTFSC  03.2
02CE:  GOTO   338
02CF:  ADDWF  4A,F
02D0:  BTFSC  03.0
02D1:  GOTO   2D9
02D2:  MOVLW  7F
02D3:  SUBWF  4A,F
02D4:  BTFSS  03.0
02D5:  GOTO   338
02D6:  BTFSC  03.2
02D7:  GOTO   338
02D8:  GOTO   2DD
02D9:  MOVLW  81
02DA:  ADDWF  4A,F
02DB:  BTFSC  03.0
02DC:  GOTO   338
02DD:  MOVF   4A,W
02DE:  MOVWF  77
02DF:  CLRF   78
02E0:  CLRF   79
02E1:  CLRF   7A
02E2:  MOVF   43,W
02E3:  MOVWF  4E
02E4:  BSF    4E.7
02E5:  MOVF   44,W
02E6:  MOVWF  4D
02E7:  MOVF   45,W
02E8:  MOVWF  4C
02E9:  MOVLW  18
02EA:  MOVWF  4A
02EB:  CLRF   4B
02EC:  BTFSS  4C.0
02ED:  GOTO   306
02EE:  MOVF   49,W
02EF:  ADDWF  7A,F
02F0:  BTFSS  03.0
02F1:  GOTO   2F8
02F2:  INCF   79,F
02F3:  BTFSS  03.2
02F4:  GOTO   2F8
02F5:  INCF   78,F
02F6:  BTFSC  03.2
02F7:  BSF    4B.7
02F8:  MOVF   48,W
02F9:  ADDWF  79,F
02FA:  BTFSS  03.0
02FB:  GOTO   2FF
02FC:  INCF   78,F
02FD:  BTFSC  03.2
02FE:  BSF    4B.7
02FF:  MOVF   47,W
0300:  MOVWF  44
0301:  BSF    44.7
0302:  MOVF   44,W
0303:  ADDWF  78,F
0304:  BTFSC  03.0
0305:  BSF    4B.7
0306:  RLF    4B,F
0307:  RRF    78,F
0308:  RRF    79,F
0309:  RRF    7A,F
030A:  RRF    4E,F
030B:  RRF    4D,F
030C:  RRF    4C,F
030D:  BCF    03.0
030E:  DECFSZ 4A,F
030F:  GOTO   2EB
0310:  MOVLW  01
0311:  ADDWF  77,F
0312:  BTFSC  03.0
0313:  GOTO   338
0314:  BTFSC  78.7
0315:  GOTO   31D
0316:  RLF    4E,F
0317:  RLF    7A,F
0318:  RLF    79,F
0319:  RLF    78,F
031A:  DECF   77,F
031B:  BTFSC  03.2
031C:  GOTO   338
031D:  BTFSS  4E.7
031E:  GOTO   32E
031F:  INCF   7A,F
0320:  BTFSS  03.2
0321:  GOTO   32E
0322:  INCF   79,F
0323:  BTFSS  03.2
0324:  GOTO   32E
0325:  INCF   78,F
0326:  BTFSS  03.2
0327:  GOTO   32E
0328:  RRF    78,F
0329:  RRF    79,F
032A:  RRF    7A,F
032B:  INCF   77,F
032C:  BTFSC  03.2
032D:  GOTO   338
032E:  MOVF   43,W
032F:  MOVWF  4B
0330:  MOVF   47,W
0331:  XORWF  4B,F
0332:  BTFSS  4B.7
0333:  GOTO   336
0334:  BSF    78.7
0335:  GOTO   33C
0336:  BCF    78.7
0337:  GOTO   33C
0338:  CLRF   77
0339:  CLRF   78
033A:  CLRF   79
033B:  CLRF   7A
033C:  MOVF   7A,W
033D:  MOVWF  38
033E:  MOVF   79,W
033F:  MOVWF  37
0340:  MOVF   78,W
0341:  MOVWF  36
0342:  MOVF   77,W
0343:  MOVWF  35
0344:  DECFSZ 3C,F
0345:  GOTO   2BA
0346:  MOVF   38,W
0347:  MOVWF  45
0348:  MOVF   37,W
0349:  MOVWF  44
034A:  MOVF   36,W
034B:  MOVWF  43
034C:  MOVF   35,W
034D:  MOVWF  42
034E:  MOVF   42,W
034F:  SUBLW  B6
0350:  MOVWF  42
0351:  CLRF   7A
0352:  MOVF   43,W
0353:  MOVWF  46
0354:  BSF    43.7
0355:  BCF    03.0
0356:  RRF    43,F
0357:  RRF    44,F
0358:  RRF    45,F
0359:  RRF    7A,F
035A:  RRF    79,F
035B:  RRF    78,F
035C:  RRF    77,F
035D:  DECFSZ 42,F
035E:  GOTO   355
035F:  BTFSS  46.7
0360:  GOTO   36C
0361:  COMF   77,F
0362:  COMF   78,F
0363:  COMF   79,F
0364:  COMF   7A,F
0365:  INCF   77,F
0366:  BTFSC  03.2
0367:  INCF   78,F
0368:  BTFSC  03.2
0369:  INCF   79,F
036A:  BTFSC  03.2
036B:  INCF   7A,F
036C:  MOVF   7A,W
036D:  MOVWF  38
036E:  MOVF   79,W
036F:  MOVWF  37
0370:  MOVF   78,W
0371:  MOVWF  36
0372:  MOVF   77,W
0373:  MOVWF  35
0374:  BTFSS  38.7
0375:  GOTO   383
0376:  DECF   3A,F
0377:  BSF    3A.5
0378:  COMF   35,F
0379:  COMF   36,F
037A:  COMF   37,F
037B:  COMF   38,F
037C:  INCF   35,F
037D:  BTFSC  03.2
037E:  INCF   36,F
037F:  BTFSC  03.2
0380:  INCF   37,F
0381:  BTFSC  03.2
0382:  INCF   38,F
0383:  MOVLW  3B
0384:  MOVWF  41
0385:  MOVLW  9A
0386:  MOVWF  40
0387:  MOVLW  CA
0388:  MOVWF  3F
0389:  CLRF   3E
038A:  MOVLW  0A
038B:  MOVWF  3C
038C:  MOVF   39,W
038D:  BTFSC  03.2
038E:  INCF   3A,F
038F:  BSF    03.1
0390:  MOVLW  35
0391:  MOVWF  04
0392:  BCF    03.7
0393:  MOVF   38,W
0394:  MOVWF  45
0395:  MOVF   37,W
0396:  MOVWF  44
0397:  MOVF   36,W
0398:  MOVWF  43
0399:  MOVF   35,W
039A:  MOVWF  42
039B:  MOVF   41,W
039C:  MOVWF  49
039D:  MOVF   40,W
039E:  MOVWF  48
039F:  MOVF   3F,W
03A0:  MOVWF  47
03A1:  MOVF   3E,W
03A2:  MOVWF  46
03A3:  CALL   265
03A4:  MOVF   78,W
03A5:  MOVF   77,F
03A6:  BTFSS  03.2
03A7:  GOTO   3BB
03A8:  INCF   39,W
03A9:  SUBWF  3C,W
03AA:  BTFSC  03.2
03AB:  GOTO   3BB
03AC:  MOVF   3A,W
03AD:  BTFSC  03.2
03AE:  GOTO   3BD
03AF:  ANDLW  0F
03B0:  SUBWF  3C,W
03B1:  BTFSC  03.2
03B2:  GOTO   3B5
03B3:  BTFSC  03.0
03B4:  GOTO   3ED
03B5:  BTFSC  3A.7
03B6:  GOTO   3ED
03B7:  BTFSC  3A.6
03B8:  GOTO   3BD
03B9:  MOVLW  20
03BA:  GOTO   3E9
03BB:  MOVLW  20
03BC:  ANDWF  3A,F
03BD:  BTFSS  3A.5
03BE:  GOTO   3CB
03BF:  BCF    3A.5
03C0:  MOVF   39,W
03C1:  BTFSS  03.2
03C2:  DECF   3A,F
03C3:  MOVF   77,W
03C4:  MOVWF  3A
03C5:  MOVLW  2D
03C6:  MOVWF  42
03C7:  CALL   0F8
03C8:  MOVF   3A,W
03C9:  MOVWF  77
03CA:  CLRF   3A
03CB:  MOVF   39,W
03CC:  SUBWF  3C,W
03CD:  BTFSS  03.2
03CE:  GOTO   3D9
03CF:  MOVF   77,W
03D0:  MOVWF  3A
03D1:  MOVLW  2E
03D2:  MOVWF  42
03D3:  CALL   0F8
03D4:  MOVF   3A,W
03D5:  MOVWF  77
03D6:  MOVLW  20
03D7:  ANDWF  3A,F
03D8:  MOVLW  00
03D9:  MOVLW  30
03DA:  BTFSS  3A.5
03DB:  GOTO   3E9
03DC:  BCF    3A.5
03DD:  MOVF   39,W
03DE:  BTFSS  03.2
03DF:  DECF   3A,F
03E0:  MOVF   77,W
03E1:  MOVWF  3A
03E2:  MOVLW  2D
03E3:  MOVWF  42
03E4:  CALL   0F8
03E5:  MOVF   3A,W
03E6:  MOVWF  77
03E7:  CLRF   3A
03E8:  MOVLW  30
03E9:  ADDWF  77,F
03EA:  MOVF   77,W
03EB:  MOVWF  42
03EC:  CALL   0F8
03ED:  BCF    03.1
03EE:  MOVF   41,W
03EF:  MOVWF  45
03F0:  MOVF   40,W
03F1:  MOVWF  44
03F2:  MOVF   3F,W
03F3:  MOVWF  43
03F4:  MOVF   3E,W
03F5:  MOVWF  42
03F6:  CLRF   49
03F7:  CLRF   48
03F8:  CLRF   47
03F9:  MOVLW  0A
03FA:  MOVWF  46
03FB:  CALL   265
03FC:  MOVF   7A,W
03FD:  MOVWF  41
03FE:  MOVF   79,W
03FF:  MOVWF  40
0400:  MOVF   78,W
0401:  MOVWF  3F
0402:  MOVF   77,W
0403:  MOVWF  3E
0404:  DECFSZ 3C,F
0405:  GOTO   38F
0406:  BCF    0A.3
0407:  BCF    0A.4
0408:  GOTO   634 (RETURN)
*
0459:  CLRF   77
045A:  CLRF   78
045B:  MOVF   37,W
045C:  BCF    03.0
045D:  BTFSC  38.0
045E:  ADDWF  77,F
045F:  RRF    77,F
0460:  RRF    78,F
0461:  BTFSC  38.1
0462:  ADDWF  77,F
0463:  RRF    77,F
0464:  RRF    78,F
0465:  BTFSC  38.2
0466:  ADDWF  77,F
0467:  RRF    77,F
0468:  RRF    78,F
0469:  BTFSC  38.3
046A:  ADDWF  77,F
046B:  RRF    77,F
046C:  RRF    78,F
046D:  BTFSC  38.4
046E:  ADDWF  77,F
046F:  RRF    77,F
0470:  RRF    78,F
0471:  BTFSC  38.5
0472:  ADDWF  77,F
0473:  RRF    77,F
0474:  RRF    78,F
0475:  BTFSC  38.6
0476:  ADDWF  77,F
0477:  RRF    77,F
0478:  RRF    78,F
0479:  BTFSC  38.7
047A:  ADDWF  77,F
047B:  RRF    77,F
047C:  RRF    78,F
*
0493:  MOVF   36,W
0494:  MOVWF  3D
0495:  MOVF   3A,W
0496:  XORWF  3D,F
0497:  BTFSS  3D.7
0498:  GOTO   49E
0499:  BCF    03.2
049A:  BCF    03.0
049B:  BTFSC  36.7
049C:  BSF    03.0
049D:  GOTO   4D1
049E:  MOVF   36,W
049F:  MOVWF  3D
04A0:  MOVF   39,W
04A1:  MOVWF  3E
04A2:  MOVF   35,W
04A3:  SUBWF  3E,F
04A4:  BTFSC  03.2
04A5:  GOTO   4AC
04A6:  BTFSS  3D.7
04A7:  GOTO   4D1
04A8:  MOVF   03,W
04A9:  XORLW  01
04AA:  MOVWF  03
04AB:  GOTO   4D1
04AC:  MOVF   3A,W
04AD:  MOVWF  3E
04AE:  MOVF   36,W
04AF:  SUBWF  3E,F
04B0:  BTFSC  03.2
04B1:  GOTO   4B8
04B2:  BTFSS  3D.7
04B3:  GOTO   4D1
04B4:  MOVF   03,W
04B5:  XORLW  01
04B6:  MOVWF  03
04B7:  GOTO   4D1
04B8:  MOVF   3B,W
04B9:  MOVWF  3E
04BA:  MOVF   37,W
04BB:  SUBWF  3E,F
04BC:  BTFSC  03.2
04BD:  GOTO   4C4
04BE:  BTFSS  3D.7
04BF:  GOTO   4D1
04C0:  MOVF   03,W
04C1:  XORLW  01
04C2:  MOVWF  03
04C3:  GOTO   4D1
04C4:  MOVF   3C,W
04C5:  MOVWF  3E
04C6:  MOVF   38,W
04C7:  SUBWF  3E,F
04C8:  BTFSC  03.2
04C9:  GOTO   4D0
04CA:  BTFSS  3D.7
04CB:  GOTO   4D1
04CC:  MOVF   03,W
04CD:  XORLW  01
04CE:  MOVWF  03
04CF:  GOTO   4D1
04D0:  BCF    03.0
04D1:  RETURN
.................... 
.................... #list
.................... 
.................... #device *=16                        //definimos el dispositivo de medicion
.................... #device adc=10                      //llamamos  el adcon1       registros adresh y adresl          
.................... #use delay(clock = 4M)              //definimos la velocidad con la que vamos a trabajar
*
0043:  MOVLW  43
0044:  MOVWF  04
0045:  BCF    03.7
0046:  MOVF   00,W
0047:  BTFSC  03.2
0048:  GOTO   057
0049:  MOVLW  01
004A:  MOVWF  78
004B:  CLRF   77
004C:  DECFSZ 77,F
004D:  GOTO   04C
004E:  DECFSZ 78,F
004F:  GOTO   04B
0050:  MOVLW  4A
0051:  MOVWF  77
0052:  DECFSZ 77,F
0053:  GOTO   052
0054:  GOTO   055
0055:  DECFSZ 00,F
0056:  GOTO   049
0057:  RETURN
.................... #include <lcd.c>                    //incluimos la libreria lcd para visualizar
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////                             LCD.C                                     ////
.................... ////                 Driver for common LCD modules                         ////
.................... ////                                                                       ////
.................... ////  lcd_init()   Must be called before any other function.               ////
.................... ////                                                                       ////
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         ////
.................... ////                 \a  Set cursor position to upper left                 ////
.................... ////                 \f  Clear display, set cursor to upper left           ////
.................... ////                 \n  Go to start of second line                        ////
.................... ////                 \b  Move back one position                            ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     ////
.................... ////              will erase all remanining characters on the current      ////
.................... ////              line, and move the cursor to the beginning of the next   ////
.................... ////              line.                                                    ////
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     ////
.................... ////              will move the cursor to the start of the current         ////
.................... ////              line.                                                    ////
.................... ////                                                                       ////
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        ////
.................... ////                                                                       ////
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             ////
.................... ////                                                                       ////
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         ////
.................... ////              (on=FALSE).                                              ////
.................... ////                                                                       ////
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   ////
.................... ////                                                                       ////
.................... ////                                                                       ////
.................... ////  CONFIGURATION                                                        ////
.................... ////  The LCD can be configured in one of two ways: a.) port access or     ////
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     ////
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     ////
.................... ////  connected to sequential pins on the GPIO.  Pin access                ////
.................... ////  has no requirements, all 7 bits of the control interface can         ////
.................... ////  can be connected to any GPIO using several ports.                    ////
.................... ////                                                                       ////
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     ////
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    ////
.................... ////  of this file to configure the pin order.  If you are using a         ////
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  ////
.................... ////  be defined.                                                          ////
.................... ////                                                                       ////
.................... ////  Example of port access:                                              ////
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         ////
.................... ////                                                                       ////
.................... ////  To use pin access, the following pins must be defined:               ////
.................... ////     LCD_ENABLE_PIN                                                    ////
.................... ////     LCD_RS_PIN                                                        ////
.................... ////     LCD_RW_PIN                                                        ////
.................... ////     LCD_DATA4                                                         ////
.................... ////     LCD_DATA5                                                         ////
.................... ////     LCD_DATA6                                                         ////
.................... ////     LCD_DATA7                                                         ////
.................... ////                                                                       ////
.................... ////  Example of pin access:                                               ////
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    ////
.................... ////     #define LCD_RS_PIN      PIN_E1                                    ////
.................... ////     #define LCD_RW_PIN      PIN_E2                                    ////
.................... ////     #define LCD_DATA4       PIN_D4                                    ////
.................... ////     #define LCD_DATA5       PIN_D5                                    ////
.................... ////     #define LCD_DATA6       PIN_D6                                    ////
.................... ////     #define LCD_DATA7       PIN_D7                                    ////
.................... ////                                                                       ////
.................... ///////////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... #ifndef __LCD_C__
.................... #define __LCD_C__
.................... 
.................... // define the pinout.
.................... // only required if port access is being used.
.................... typedef struct  
.................... {                            // This structure is overlayed
....................    int1 enable;           // on to an I/O port to gain
....................    int1 rs;               // access to the LCD pins.
....................    int1 rw;               // The bits are allocated from
....................    int1 unused;           // low order up.  ENABLE will
....................    unsigned int     data : 4;         // be LSB pin of that port.
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT.
....................    unsigned int    reserved: 8;
....................   #endif
.................... } LCD_PIN_MAP;
.................... 
.................... // this is to improve compatability with previous LCD drivers that accepted
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B.
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE))
....................  #define LCD_DATA_PORT getenv("SFR:PORTB")
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    // these definitions only need to be modified for baseline PICs.
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions.
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0};
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF};
.................... #endif
.................... 
.................... ////////////////////// END CONFIGURATION ///////////////////////////////////
.................... 
.................... #ifndef LCD_ENABLE_PIN
....................    #define lcd_output_enable(x) lcdlat.enable=x
....................    #define lcd_enable_tris()   lcdtris.enable=0
.................... #else
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x)
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RS_PIN
....................    #define lcd_output_rs(x) lcdlat.rs=x
....................    #define lcd_rs_tris()   lcdtris.rs=0
.................... #else
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x)
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN)
.................... #endif
.................... 
.................... #ifndef LCD_RW_PIN
....................    #define lcd_output_rw(x) lcdlat.rw=x
....................    #define lcd_rw_tris()   lcdtris.rw=0
.................... #else
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x)
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN)
.................... #endif
.................... 
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4,
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver
.................... // compatible with any code written for the original library
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7))
....................    #define  LCD_DATA4    LCD_DATA0
....................    #define  LCD_DATA5    LCD_DATA1
....................    #define  LCD_DATA6    LCD_DATA2
....................    #define  LCD_DATA7    LCD_DATA3
.................... #endif
.................... 
.................... #ifndef LCD_DATA4
.................... #ifndef LCD_DATA_PORT
....................    #if defined(__PCB__)
....................       #define LCD_DATA_PORT      0x06     //portb
....................       #define set_tris_lcd(x)   set_tris_b(x)
....................    #else
....................      #if defined(PIN_D0)
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd
....................      #else
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb
....................      #endif
....................    #endif   
.................... #endif
.................... 
.................... #if defined(__PCB__)
....................    LCD_PIN_MAP lcd, lcdlat;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
.................... #elif defined(__PCM__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT
....................    #byte lcdtris = LCD_DATA_PORT+0x80
.................... #elif defined(__PCH__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #byte lcd = LCD_DATA_PORT
....................    #byte lcdlat = LCD_DATA_PORT+9
....................    #byte lcdtris = LCD_DATA_PORT+0x12
.................... #elif defined(__PCD__)
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris;
....................    #word lcd = LCD_DATA_PORT
....................    #word lcdlat = LCD_DATA_PORT+2
....................    #word lcdtris = LCD_DATA_PORT-0x02
.................... #endif
.................... #endif   //LCD_DATA4 not defined
.................... 
.................... #ifndef LCD_TYPE
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines
.................... #endif
.................... 
.................... #ifndef LCD_LINE_TWO
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line
.................... #endif
.................... 
.................... #ifndef LCD_LINE_LENGTH
....................    #define LCD_LINE_LENGTH 20
.................... #endif
.................... 
.................... unsigned int8 lcd_read_nibble(void);
.................... 
.................... unsigned int8 lcd_read_byte(void)
.................... {
....................    unsigned int8 low,high;
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_INPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_float(LCD_DATA4);
....................    output_float(LCD_DATA5);
....................    output_float(LCD_DATA6);
....................    output_float(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0xF;
*
0070:  MOVLW  0F
0071:  BSF    03.5
0072:  ANDWF  08,W
0073:  IORLW  F0
0074:  MOVWF  08
....................   #endif
....................  #endif
....................         
....................    lcd_output_rw(1);
0075:  BCF    03.5
0076:  BSF    08.2
....................    delay_cycles(1);
0077:  NOP
....................    lcd_output_enable(1);
0078:  BSF    08.0
....................    delay_cycles(1);
0079:  NOP
....................    high = lcd_read_nibble();
007A:  CALL   064
007B:  MOVF   78,W
007C:  MOVWF  4A
....................       
....................    lcd_output_enable(0);
007D:  BCF    08.0
....................    delay_cycles(1);
007E:  NOP
....................    lcd_output_enable(1);
007F:  BSF    08.0
....................    delay_us(1);
0080:  NOP
....................    low = lcd_read_nibble();
0081:  CALL   064
0082:  MOVF   78,W
0083:  MOVWF  49
....................       
....................    lcd_output_enable(0);
0084:  BCF    08.0
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
0085:  MOVLW  0F
0086:  BSF    03.5
0087:  ANDWF  08,W
0088:  MOVWF  08
....................   #endif
....................  #endif
.................... 
....................    return( (high<<4) | low);
0089:  BCF    03.5
008A:  SWAPF  4A,W
008B:  MOVWF  77
008C:  MOVLW  F0
008D:  ANDWF  77,F
008E:  MOVF   77,W
008F:  IORWF  49,W
0090:  MOVWF  78
.................... }
.................... 
.................... unsigned int8 lcd_read_nibble(void)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    unsigned int8 n = 0x00;
.................... 
....................    /* Read the data port */
....................    n |= input(LCD_DATA4);
....................    n |= input(LCD_DATA5) << 1;
....................    n |= input(LCD_DATA6) << 2;
....................    n |= input(LCD_DATA7) << 3;
....................    
....................    return(n);
....................   #else
....................    return(lcd.data);
*
0064:  MOVF   08,W
0065:  MOVWF  77
0066:  SWAPF  08,W
0067:  ANDLW  0F
0068:  MOVWF  78
....................   #endif
0069:  RETURN
.................... }
.................... 
.................... void lcd_send_nibble(unsigned int8 n)
.................... {
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    /* Write to the data port */
....................    output_bit(LCD_DATA4, bit_test(n, 0));
....................    output_bit(LCD_DATA5, bit_test(n, 1));
....................    output_bit(LCD_DATA6, bit_test(n, 2));
....................    output_bit(LCD_DATA7, bit_test(n, 3));
....................   #else      
....................    lcdlat.data = n;
*
0058:  SWAPF  4A,W
0059:  ANDLW  F0
005A:  MOVWF  77
005B:  MOVLW  0F
005C:  ANDWF  08,W
005D:  IORWF  77,W
005E:  MOVWF  08
....................   #endif
....................       
....................    delay_cycles(1);
005F:  NOP
....................    lcd_output_enable(1);
0060:  BSF    08.0
....................    delay_us(2);
0061:  GOTO   062
....................    lcd_output_enable(0);
0062:  BCF    08.0
0063:  RETURN
.................... }
.................... 
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n)
.................... {
....................   #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................   #else
....................    lcd_enable_tris();
*
006A:  BSF    03.5
006B:  BCF    08.0
....................    lcd_rs_tris();
006C:  BCF    08.1
....................    lcd_rw_tris();
006D:  BCF    08.2
....................   #endif
.................... 
....................    lcd_output_rs(0);
006E:  BCF    03.5
006F:  BCF    08.1
....................    while ( bit_test(lcd_read_byte(),7) ) ;
*
0091:  MOVF   78,W
0092:  MOVWF  49
0093:  BTFSC  49.7
0094:  GOTO   070
....................    lcd_output_rs(address);
0095:  BTFSS  47.0
0096:  BCF    08.1
0097:  BTFSC  47.0
0098:  BSF    08.1
....................    delay_cycles(1);
0099:  NOP
....................    lcd_output_rw(0);
009A:  BCF    08.2
....................    delay_cycles(1);
009B:  NOP
....................    lcd_output_enable(0);
009C:  BCF    08.0
....................    lcd_send_nibble(n >> 4);
009D:  SWAPF  48,W
009E:  MOVWF  49
009F:  MOVLW  0F
00A0:  ANDWF  49,F
00A1:  MOVF   49,W
00A2:  MOVWF  4A
00A3:  CALL   058
....................    lcd_send_nibble(n & 0xf);
00A4:  MOVF   48,W
00A5:  ANDLW  0F
00A6:  MOVWF  49
00A7:  MOVWF  4A
00A8:  CALL   058
00A9:  RETURN
.................... }
.................... 
.................... #if defined(LCD_EXTENDED_NEWLINE)
.................... unsigned int8 g_LcdX, g_LcdY;
.................... #endif
.................... 
.................... void lcd_init(void) 
.................... {
....................    unsigned int8 i;
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6};
00AA:  MOVLW  28
00AB:  MOVWF  36
00AC:  MOVLW  0C
00AD:  MOVWF  37
00AE:  MOVLW  01
00AF:  MOVWF  38
00B0:  MOVLW  06
00B1:  MOVWF  39
....................                              // These bytes need to be sent to the LCD
....................                              // to start it up.
....................    
.................... 
....................    lcd_output_enable(0);
00B2:  BCF    08.0
....................    lcd_output_rs(0);
00B3:  BCF    08.1
....................    lcd_output_rw(0);
00B4:  BCF    08.2
.................... 
....................  #if defined(__PCB__)
....................    set_tris_lcd(LCD_OUTPUT_MAP);
....................  #else
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7))
....................    output_drive(LCD_DATA4);
....................    output_drive(LCD_DATA5);
....................    output_drive(LCD_DATA6);
....................    output_drive(LCD_DATA7);
....................   #else
....................    lcdtris.data = 0x0;
00B5:  MOVLW  0F
00B6:  BSF    03.5
00B7:  ANDWF  08,W
00B8:  MOVWF  08
....................   #endif
....................    lcd_enable_tris();
00B9:  BCF    08.0
....................    lcd_rs_tris();
00BA:  BCF    08.1
....................    lcd_rw_tris();
00BB:  BCF    08.2
....................  #endif
....................     
....................    delay_ms(15);
00BC:  MOVLW  0F
00BD:  BCF    03.5
00BE:  MOVWF  43
00BF:  CALL   043
....................    for(i=1;i<=3;++i)
00C0:  MOVLW  01
00C1:  MOVWF  35
00C2:  MOVF   35,W
00C3:  SUBLW  03
00C4:  BTFSS  03.0
00C5:  GOTO   0CE
....................    {
....................        lcd_send_nibble(3);
00C6:  MOVLW  03
00C7:  MOVWF  4A
00C8:  CALL   058
....................        delay_ms(5);
00C9:  MOVLW  05
00CA:  MOVWF  43
00CB:  CALL   043
00CC:  INCF   35,F
00CD:  GOTO   0C2
....................    }
....................    
....................    lcd_send_nibble(2);
00CE:  MOVLW  02
00CF:  MOVWF  4A
00D0:  CALL   058
....................    delay_ms(5);
00D1:  MOVLW  05
00D2:  MOVWF  43
00D3:  CALL   043
....................    for(i=0;i<=3;++i)
00D4:  CLRF   35
00D5:  MOVF   35,W
00D6:  SUBLW  03
00D7:  BTFSS  03.0
00D8:  GOTO   0E5
....................       lcd_send_byte(0,LCD_INIT_STRING[i]);
00D9:  MOVLW  36
00DA:  ADDWF  35,W
00DB:  MOVWF  04
00DC:  BCF    03.7
00DD:  MOVF   00,W
00DE:  MOVWF  3A
00DF:  CLRF   47
00E0:  MOVF   3A,W
00E1:  MOVWF  48
00E2:  CALL   06A
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
00E3:  INCF   35,F
00E4:  GOTO   0D5
00E5:  RETURN
....................    g_LcdX = 0;
....................    g_LcdY = 0;
....................   #endif
.................... }
.................... 
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y)
.................... {
....................    unsigned int8 address;
....................    
....................    if(y!=1)
00E6:  DECFSZ 44,W
00E7:  GOTO   0E9
00E8:  GOTO   0EC
....................       address=LCD_LINE_TWO;
00E9:  MOVLW  40
00EA:  MOVWF  45
00EB:  GOTO   0ED
....................    else
....................       address=0;
00EC:  CLRF   45
....................      
....................    address+=x-1;
00ED:  MOVLW  01
00EE:  SUBWF  43,W
00EF:  ADDWF  45,F
....................    lcd_send_byte(0,0x80|address);
00F0:  MOVF   45,W
00F1:  IORLW  80
00F2:  MOVWF  46
00F3:  CLRF   47
00F4:  MOVF   46,W
00F5:  MOVWF  48
00F6:  CALL   06A
.................... 
....................   #if defined(LCD_EXTENDED_NEWLINE)
00F7:  RETURN
....................    g_LcdX = x - 1;
....................    g_LcdY = y - 1;
....................   #endif
.................... }
.................... 
.................... void lcd_putc(char c)
.................... {
....................    switch (c)
00F8:  MOVF   42,W
00F9:  XORLW  07
00FA:  BTFSC  03.2
00FB:  GOTO   106
00FC:  XORLW  0B
00FD:  BTFSC  03.2
00FE:  GOTO   10B
00FF:  XORLW  06
0100:  BTFSC  03.2
0101:  GOTO   113
0102:  XORLW  02
0103:  BTFSC  03.2
0104:  GOTO   119
0105:  GOTO   11E
....................    {
....................       case '\a'   :  lcd_gotoxy(1,1);     break;
0106:  MOVLW  01
0107:  MOVWF  43
0108:  MOVWF  44
0109:  CALL   0E6
010A:  GOTO   123
.................... 
....................       case '\f'   :  lcd_send_byte(0,1);
010B:  CLRF   47
010C:  MOVLW  01
010D:  MOVWF  48
010E:  CALL   06A
....................                      delay_ms(2);
010F:  MOVLW  02
0110:  MOVWF  43
0111:  CALL   043
....................                     #if defined(LCD_EXTENDED_NEWLINE)
....................                      g_LcdX = 0;
....................                      g_LcdY = 0;
....................                     #endif
....................                      break;
0112:  GOTO   123
.................... 
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break;
....................       case '\n'   :
....................          while (g_LcdX++ < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, ' ');
....................          }
....................          lcd_gotoxy(1, g_LcdY+2);
....................          break;
....................      #else
....................       case '\n'   : lcd_gotoxy(1,2);        break;
0113:  MOVLW  01
0114:  MOVWF  43
0115:  MOVLW  02
0116:  MOVWF  44
0117:  CALL   0E6
0118:  GOTO   123
....................      #endif
....................      
....................       case '\b'   : lcd_send_byte(0,0x10);  break;
0119:  CLRF   47
011A:  MOVLW  10
011B:  MOVWF  48
011C:  CALL   06A
011D:  GOTO   123
....................      
....................      #if defined(LCD_EXTENDED_NEWLINE)
....................       default     : 
....................          if (g_LcdX < LCD_LINE_LENGTH)
....................          {
....................             lcd_send_byte(1, c);
....................             g_LcdX++;
....................          }
....................          break;
....................      #else
....................       default     : lcd_send_byte(1,c);     break;
011E:  MOVLW  01
011F:  MOVWF  47
0120:  MOVF   42,W
0121:  MOVWF  48
0122:  CALL   06A
....................      #endif
....................    }
0123:  RETURN
.................... }
....................  
.................... char lcd_getc(unsigned int8 x, unsigned int8 y)
.................... {
....................    char value;
.................... 
....................    lcd_gotoxy(x,y);
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low
....................    lcd_output_rs(1);
....................    value = lcd_read_byte();
....................    lcd_output_rs(0);
....................    
....................    return(value);
.................... }
.................... 
.................... // write a custom character to the ram
.................... // which is 0-7 and specifies which character array we are modifying.
.................... // ptr points to an array of 8 bytes, where each byte is the next row of
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and
.................... //    usually you will want to leave this byte 0x00.
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr)
.................... {
....................    unsigned int i;
.................... 
....................    which <<= 3;
....................    which &= 0x38;
.................... 
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address
.................... 
....................    for(i=0; i<8; i++)
....................    {
....................       lcd_send_byte(1, *ptr++);
....................    }
....................   
....................    #if defined(LCD_EXTENDED_NEWLINE)
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address
....................    #endif
.................... }
.................... 
.................... void lcd_cursor_on(int1 on)
.................... {
....................    if (on)
....................    {
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON
....................    }
....................    else
....................    {
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF
....................    }
.................... }
.................... 
.................... #endif
.................... 
.................... #fuses xt,nowdt,HS,NOWDT,NOPROTECT,NOLVP,BROWNOUT
.................... #use standard_io(a)           //gestion de puertos
.................... #define use_portb_kbd TRUE
.................... #include <kbd.c>          //libreria del teclado
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////                             KBD.C                                 ////
.................... ////                  Generic keypad scan driver                       ////
.................... ////                                                                   ////
.................... ////  kbd_init()   Must be called before any other function.           ////
.................... ////                                                                   ////
.................... ////  c = kbd_getc()  Will return a key value if pressed or /0 if not  ////
.................... ////                   This function should be called frequently so as ////
.................... ////                   not to miss a key press.                        ////
.................... ////                                                                   ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... 
.................... ////////////////// The following defines the keypad layout on port D
.................... 
.................... // Un-comment the following define to use port B
.................... // #define use_portb_kbd TRUE
.................... 
.................... // Make sure the port used has pull-up resistors (or the LCD) on
.................... // the column pins
.................... 
.................... #if defined use_portb_kbd
....................    #byte kbd = getenv("SFR:PORTB")
.................... #else
....................    #byte kbd = getenv("SFR:PORTD")
.................... #endif
.................... 
.................... #if defined use_portb_kbd
....................    #define set_tris_kbd(x) set_tris_b(x)
.................... #else
....................    #define set_tris_kbd(x) set_tris_d(x)
.................... #endif
.................... 
.................... //Keypad connection:   (for example column 0 is B2)
.................... //                Bx:
.................... 
.................... #ifdef blue_keypad  ///////////////////////////////////// For the blue keypad
.................... #define COL0 (1 << 2)
.................... #define COL1 (1 << 3)
.................... #define COL2 (1 << 6)
.................... 
.................... #define ROW0 (1 << 4)
.................... #define ROW1 (1 << 7)
.................... #define ROW2 (1 << 1)
.................... #define ROW3 (1 << 5)
.................... 
.................... #else ////////////////////////////////////////////////// For the black keypad
.................... #define COL0 (1 << 5)
.................... #define COL1 (1 << 6)
.................... #define COL2 (1 << 7)
.................... 
.................... #define ROW0 (1 << 1)
.................... #define ROW1 (1 << 2)
.................... #define ROW2 (1 << 3)
.................... #define ROW3 (1 << 4)
.................... 
.................... #endif
.................... 
.................... #define ALL_ROWS (ROW0|ROW1|ROW2|ROW3)
.................... #define ALL_PINS (ALL_ROWS|COL0|COL1|COL2)
.................... 
.................... // Keypad layout:
.................... char const KEYS[4][3] = {{'1','2','3'},
....................                          {'4','5','6'},
....................                          {'7','8','9'},
....................                          {'*','0','#'}};
.................... 
.................... #define KBD_DEBOUNCE_FACTOR 33    // Set this number to apx n/333 where
....................                                   // n is the number of times you expect
....................                                   // to call kbd_getc each second
.................... 
.................... 
.................... void kbd_init() {
*
0040:  BCF    0A.3
0041:  BCF    0A.4
0042:  GOTO   5BC (RETURN)
.................... }
.................... 
.................... char kbd_getc( ) {
....................    static BYTE kbd_call_count;
*
05B6:  BCF    03.5
05B7:  CLRF   20
....................    static int1 kbd_down;
05B8:  BCF    21.0
....................    static char last_key;
05B9:  CLRF   22
....................    static BYTE col;
05BA:  CLRF   23
.................... 
....................    BYTE kchar;
....................    BYTE row;
.................... 
....................    kchar='\0';
*
0409:  CLRF   35
....................    if(++kbd_call_count>KBD_DEBOUNCE_FACTOR) {
040A:  INCF   20,F
040B:  MOVF   20,W
040C:  SUBLW  21
040D:  BTFSC  03.0
040E:  GOTO   48A
....................        switch (col) {
040F:  MOVF   23,W
0410:  BTFSC  03.2
0411:  GOTO   419
0412:  XORLW  01
0413:  BTFSC  03.2
0414:  GOTO   41F
0415:  XORLW  03
0416:  BTFSC  03.2
0417:  GOTO   425
0418:  GOTO   42A
....................          case 0   : set_tris_kbd(ALL_PINS&~COL0);
0419:  MOVLW  DE
041A:  BSF    03.5
041B:  MOVWF  06
....................                     kbd=~COL0&ALL_PINS;
041C:  BCF    03.5
041D:  MOVWF  06
....................                     break;
041E:  GOTO   42A
....................          case 1   : set_tris_kbd(ALL_PINS&~COL1);
041F:  MOVLW  BE
0420:  BSF    03.5
0421:  MOVWF  06
....................                     kbd=~COL1&ALL_PINS;
0422:  BCF    03.5
0423:  MOVWF  06
....................                     break;
0424:  GOTO   42A
....................          case 2   : set_tris_kbd(ALL_PINS&~COL2);
0425:  MOVLW  7E
0426:  BSF    03.5
0427:  MOVWF  06
....................                     kbd=~COL2&ALL_PINS;
0428:  BCF    03.5
0429:  MOVWF  06
....................                     break;
....................        }
.................... 
....................        if(kbd_down) {
042A:  BTFSS  21.0
042B:  GOTO   436
....................          if((kbd & (ALL_ROWS))==(ALL_ROWS)) {
042C:  MOVF   06,W
042D:  ANDLW  1E
042E:  SUBLW  1E
042F:  BTFSS  03.2
0430:  GOTO   435
....................            kbd_down=FALSE;
0431:  BCF    21.0
....................            kchar=last_key;
0432:  MOVF   22,W
0433:  MOVWF  35
....................            last_key='\0';
0434:  CLRF   22
....................          }
....................        } else {
0435:  GOTO   489
....................           if((kbd & (ALL_ROWS))!=(ALL_ROWS)) {
0436:  MOVF   06,W
0437:  ANDLW  1E
0438:  SUBLW  1E
0439:  BTFSC  03.2
043A:  GOTO   484
....................              if((kbd & ROW0)==0)
043B:  MOVF   06,W
043C:  ANDLW  02
043D:  BTFSS  03.2
043E:  GOTO   441
....................                row=0;
043F:  CLRF   36
0440:  GOTO   455
....................              else if((kbd & ROW1)==0)
0441:  MOVF   06,W
0442:  ANDLW  04
0443:  BTFSS  03.2
0444:  GOTO   448
....................                row=1;
0445:  MOVLW  01
0446:  MOVWF  36
0447:  GOTO   455
....................              else if((kbd & ROW2)==0)
0448:  MOVF   06,W
0449:  ANDLW  08
044A:  BTFSS  03.2
044B:  GOTO   44F
....................                row=2;
044C:  MOVLW  02
044D:  MOVWF  36
044E:  GOTO   455
....................              else if((kbd & ROW3)==0)
044F:  MOVF   06,W
0450:  ANDLW  10
0451:  BTFSS  03.2
0452:  GOTO   455
....................                row=3;
0453:  MOVLW  03
0454:  MOVWF  36
....................              last_key =KEYS[row][col];
0455:  MOVF   36,W
0456:  MOVWF  37
0457:  MOVLW  03
0458:  MOVWF  38
*
047D:  MOVF   23,W
047E:  ADDWF  78,W
047F:  CALL   004
0480:  MOVWF  78
0481:  MOVWF  22
....................              kbd_down = TRUE;
0482:  BSF    21.0
....................           } else {
0483:  GOTO   489
....................              ++col;
0484:  INCF   23,F
....................              if(col==3)
0485:  MOVF   23,W
0486:  SUBLW  03
0487:  BTFSC  03.2
....................                col=0;
0488:  CLRF   23
....................           }
....................        }
....................       kbd_call_count=0;
0489:  CLRF   20
....................    }
....................   set_tris_kbd(ALL_PINS);
048A:  MOVLW  FE
048B:  BSF    03.5
048C:  MOVWF  06
....................   return(kchar);
048D:  BCF    03.5
048E:  MOVF   35,W
048F:  MOVWF  78
0490:  BCF    0A.3
0491:  BCF    0A.4
0492:  GOTO   640 (RETURN)
.................... }
.................... 
.................... //#include <stdlib.h>           //libreria para crear datos de memoria dinamica de datos aleatorios
.................... //#rom 0x2100={'1','2','3','4','5','6','7','8','9','0'}   //posicion 0,1 y 2 de la eeprom con los datos
.................... 
.................... //#fuses XT, NOWDT, NOPROTECT, BROWNOUT, PUT, NOLVP
.................... 
.................... float temperatura;                  //declaramos una variable de tipo flotante,
.................... 
.................... void checkTemp(){
....................     if(temperatura<20)  {
*
04D2:  MOVF   27,W
04D3:  MOVWF  38
04D4:  MOVF   26,W
04D5:  MOVWF  37
04D6:  MOVF   25,W
04D7:  MOVWF  36
04D8:  MOVF   24,W
04D9:  MOVWF  35
04DA:  CLRF   3C
04DB:  CLRF   3B
04DC:  MOVLW  20
04DD:  MOVWF  3A
04DE:  MOVLW  83
04DF:  MOVWF  39
04E0:  CALL   493
04E1:  BTFSS  03.0
04E2:  GOTO   51B
....................         set_pwm1_duty(115);
04E3:  MOVLW  73
04E4:  MOVWF  15
....................         output_high(49); // BUZZER  
04E5:  BSF    03.5
04E6:  BCF    06.1
04E7:  BCF    03.5
04E8:  BSF    06.1
....................         printf(lcd_putc,"\fpuerta abierta");   //compara los datos y la clave
04E9:  MOVLW  14
04EA:  BSF    03.6
04EB:  MOVWF  0D
04EC:  MOVLW  00
04ED:  MOVWF  0F
04EE:  BCF    03.6
04EF:  CALL   124
....................         delay_ms(1000);
04F0:  MOVLW  04
04F1:  MOVWF  35
04F2:  MOVLW  FA
04F3:  MOVWF  43
04F4:  CALL   043
04F5:  DECFSZ 35,F
04F6:  GOTO   4F2
....................         set_pwm1_duty(115);
04F7:  MOVLW  73
04F8:  MOVWF  15
....................         printf(lcd_putc,"\fpuerta cerrada");   //compara los datos y la clave
04F9:  MOVLW  1C
04FA:  BSF    03.6
04FB:  MOVWF  0D
04FC:  MOVLW  00
04FD:  MOVWF  0F
04FE:  BCF    03.6
04FF:  CALL   124
....................         output_low(49); // BUZZER  
0500:  BSF    03.5
0501:  BCF    06.1
0502:  BCF    03.5
0503:  BCF    06.1
....................         delay_ms(1000);
0504:  MOVLW  04
0505:  MOVWF  35
0506:  MOVLW  FA
0507:  MOVWF  43
0508:  CALL   043
0509:  DECFSZ 35,F
050A:  GOTO   506
....................         output_high(PIN_A0);                   //Clave correcta pone en alto el pin RA0
050B:  BSF    03.5
050C:  BCF    05.0
050D:  BCF    03.5
050E:  BSF    05.0
....................         delay_ms(500);
050F:  MOVLW  02
0510:  MOVWF  35
0511:  MOVLW  FA
0512:  MOVWF  43
0513:  CALL   043
0514:  DECFSZ 35,F
0515:  GOTO   511
....................         output_low(PIN_A0);                    //el alto en el pin rA0 esta durante 500ms luego se apaga   
0516:  BSF    03.5
0517:  BCF    05.0
0518:  BCF    03.5
0519:  BCF    05.0
....................     }
051A:  GOTO   5A8
....................     else if(temperatura>=20&&temperatura<=35)  {
051B:  CLRF   38
051C:  CLRF   37
051D:  MOVLW  20
051E:  MOVWF  36
051F:  MOVLW  83
0520:  MOVWF  35
0521:  MOVF   27,W
0522:  MOVWF  3C
0523:  MOVF   26,W
0524:  MOVWF  3B
0525:  MOVF   25,W
0526:  MOVWF  3A
0527:  MOVF   24,W
0528:  MOVWF  39
0529:  CALL   493
052A:  BTFSC  03.0
052B:  GOTO   52E
052C:  BTFSS  03.2
052D:  GOTO   581
052E:  MOVF   27,W
052F:  MOVWF  38
0530:  MOVF   26,W
0531:  MOVWF  37
0532:  MOVF   25,W
0533:  MOVWF  36
0534:  MOVF   24,W
0535:  MOVWF  35
0536:  CLRF   3C
0537:  CLRF   3B
0538:  MOVLW  0C
0539:  MOVWF  3A
053A:  MOVLW  84
053B:  MOVWF  39
053C:  CALL   493
053D:  BTFSC  03.0
053E:  GOTO   541
053F:  BTFSS  03.2
0540:  GOTO   581
....................         set_pwm1_duty(171);
0541:  MOVLW  AB
0542:  MOVWF  15
....................          
....................         lcd_gotoxy(7,2);
0543:  MOVLW  07
0544:  MOVWF  43
0545:  MOVLW  02
0546:  MOVWF  44
0547:  CALL   0E6
....................         printf(lcd_putc,"\fpuerta abierta");   //compara los datos y la clave
0548:  MOVLW  24
0549:  BSF    03.6
054A:  MOVWF  0D
054B:  MOVLW  00
054C:  MOVWF  0F
054D:  BCF    03.6
054E:  CALL   124
....................         output_high(49); // PIN B1 (BUZZER)
054F:  BSF    03.5
0550:  BCF    06.1
0551:  BCF    03.5
0552:  BSF    06.1
....................         delay_ms(5000);
0553:  MOVLW  14
0554:  MOVWF  35
0555:  MOVLW  FA
0556:  MOVWF  43
0557:  CALL   043
0558:  DECFSZ 35,F
0559:  GOTO   555
....................         lcd_gotoxy (1,2);
055A:  MOVLW  01
055B:  MOVWF  43
055C:  MOVLW  02
055D:  MOVWF  44
055E:  CALL   0E6
....................         printf(lcd_putc,"\fpuerta cerrada");   //compara los datos y la clave
055F:  MOVLW  2C
0560:  BSF    03.6
0561:  MOVWF  0D
0562:  MOVLW  00
0563:  MOVWF  0F
0564:  BCF    03.6
0565:  CALL   124
....................         output_low(49); // PIN B1 (BUZZER)
0566:  BSF    03.5
0567:  BCF    06.1
0568:  BCF    03.5
0569:  BCF    06.1
....................         delay_ms(5000);
056A:  MOVLW  14
056B:  MOVWF  35
056C:  MOVLW  FA
056D:  MOVWF  43
056E:  CALL   043
056F:  DECFSZ 35,F
0570:  GOTO   56C
....................         output_high(PIN_A0);                   //Clave correcta pone en alto el pin RA0
0571:  BSF    03.5
0572:  BCF    05.0
0573:  BCF    03.5
0574:  BSF    05.0
....................         delay_ms(500);
0575:  MOVLW  02
0576:  MOVWF  35
0577:  MOVLW  FA
0578:  MOVWF  43
0579:  CALL   043
057A:  DECFSZ 35,F
057B:  GOTO   577
....................         output_low(PIN_A0);                    //el alto en el pin rA0 esta durante 500ms luego se apaga   
057C:  BSF    03.5
057D:  BCF    05.0
057E:  BCF    03.5
057F:  BCF    05.0
....................     }
0580:  GOTO   5A8
....................     else if(temperatura<35)  {
0581:  MOVF   27,W
0582:  MOVWF  38
0583:  MOVF   26,W
0584:  MOVWF  37
0585:  MOVF   25,W
0586:  MOVWF  36
0587:  MOVF   24,W
0588:  MOVWF  35
0589:  CLRF   3C
058A:  CLRF   3B
058B:  MOVLW  0C
058C:  MOVWF  3A
058D:  MOVLW  84
058E:  MOVWF  39
058F:  CALL   493
0590:  BTFSS  03.0
0591:  GOTO   5A8
....................         set_pwm1_duty(228);
0592:  MOVLW  E4
0593:  MOVWF  15
....................         output_low(49); // PIN B1 (BUZZER) 
0594:  BSF    03.5
0595:  BCF    06.1
0596:  BCF    03.5
0597:  BCF    06.1
....................         delay_ms(500);
0598:  MOVLW  02
0599:  MOVWF  35
059A:  MOVLW  FA
059B:  MOVWF  43
059C:  CALL   043
059D:  DECFSZ 35,F
059E:  GOTO   59A
....................         set_pwm1_duty(228);
059F:  MOVLW  E4
05A0:  MOVWF  15
....................         delay_ms(500);
05A1:  MOVLW  02
05A2:  MOVWF  35
05A3:  MOVLW  FA
05A4:  MOVWF  43
05A5:  CALL   043
05A6:  DECFSZ 35,F
05A7:  GOTO   5A3
....................     }
05A8:  RETURN
.................... }
.................... 
.................... int main(int argc, char** argv) {
05A9:  MOVF   03,W
05AA:  ANDLW  1F
05AB:  MOVWF  03
05AC:  CLRF   29
05AD:  CLRF   28
05AE:  MOVLW  FF
05AF:  MOVWF  2A
05B0:  BSF    03.5
05B1:  BSF    1F.0
05B2:  BSF    1F.1
05B3:  BSF    1F.2
05B4:  BCF    1F.3
05B5:  BCF    03.7
....................     char keypad;
....................     int i;
....................     char keys_pressed[5];
....................     kbd_init();
*
05BB:  GOTO   040
....................     port_b_pullups(TRUE);   //habilitan las resistencias pull up para evitar resistencias en el teclado
05BC:  BSF    03.5
05BD:  BCF    01.7
....................     
....................     setup_ccp1(0x0C);                            //configuracion modo pwm cpp_pwn
05BE:  BCF    03.5
05BF:  BCF    2A.2
05C0:  MOVF   2A,W
05C1:  BSF    03.5
05C2:  MOVWF  07
05C3:  BCF    03.5
05C4:  BCF    07.2
05C5:  MOVLW  0C
05C6:  MOVWF  17
....................     setup_timer_2(T2_DIV_BY_16,255,1);              //configuracion del timer 2 y postcaler
05C7:  MOVLW  00
05C8:  MOVWF  78
05C9:  IORLW  06
05CA:  MOVWF  12
05CB:  MOVLW  FF
05CC:  BSF    03.5
05CD:  MOVWF  12
....................     setup_adc_ports (ALL_ANALOG);                  //configuramos todas las entradas analogas
05CE:  BCF    1F.0
05CF:  BCF    1F.1
05D0:  BCF    1F.2
05D1:  BCF    1F.3
....................     setup_adc(ADC_CLOCK_INTERNAL);                 //llamamos el convertidor analogo digital del pic que trabaja con el //reloj interno
05D2:  BCF    03.5
05D3:  BSF    1F.6
05D4:  BSF    1F.7
05D5:  BSF    03.5
05D6:  BSF    1F.7
05D7:  BCF    03.5
05D8:  BSF    1F.0
....................     set_adc_channel(0);
05D9:  MOVLW  00
05DA:  MOVWF  78
05DB:  MOVF   1F,W
05DC:  ANDLW  C7
05DD:  IORWF  78,W
05DE:  MOVWF  1F
.................... 
....................     // Se configura el LCD e imprimer TEMP:
....................     lcd_init();                                  
05DF:  CALL   0AA
....................     lcd_gotoxy(1,1);                             
05E0:  MOVLW  01
05E1:  MOVWF  43
05E2:  MOVWF  44
05E3:  CALL   0E6
....................     printf(lcd_putc,"TEMP: ");             
05E4:  MOVLW  34
05E5:  BSF    03.6
05E6:  MOVWF  0D
05E7:  MOVLW  00
05E8:  MOVWF  0F
05E9:  BCF    03.6
05EA:  CALL   124
....................     delay_ms(300);
05EB:  MOVLW  02
05EC:  MOVWF  35
05ED:  MOVLW  96
05EE:  MOVWF  43
05EF:  CALL   043
05F0:  DECFSZ 35,F
05F1:  GOTO   5ED
....................     lcd_init();                            
05F2:  CALL   0AA
....................     // tambien printf(putc,(\f))  para borrar         
....................     i=0;
05F3:  CLRF   2F
....................     while (TRUE)   {
....................         //Muestra Temperatura
....................         temperatura=(float)read_adc()/2;
05F4:  BSF    1F.2
05F5:  BTFSC  1F.2
05F6:  GOTO   5F5
05F7:  MOVF   1E,W
05F8:  MOVWF  79
05F9:  BSF    03.5
05FA:  MOVF   1E,W
05FB:  MOVWF  78
05FC:  MOVF   79,W
05FD:  MOVWF  7A
05FE:  MOVF   1E,W
05FF:  BCF    03.5
0600:  MOVWF  35
0601:  MOVF   79,W
0602:  MOVWF  36
0603:  GOTO   17A
0604:  MOVF   7A,W
0605:  MOVWF  38
0606:  MOVF   79,W
0607:  MOVWF  37
0608:  MOVF   78,W
0609:  MOVWF  36
060A:  MOVF   77,W
060B:  MOVWF  35
060C:  MOVF   7A,W
060D:  MOVWF  3C
060E:  MOVF   79,W
060F:  MOVWF  3B
0610:  MOVF   78,W
0611:  MOVWF  3A
0612:  MOVF   77,W
0613:  MOVWF  39
0614:  CLRF   40
0615:  CLRF   3F
0616:  CLRF   3E
0617:  MOVLW  80
0618:  MOVWF  3D
0619:  GOTO   199
061A:  MOVF   7A,W
061B:  MOVWF  27
061C:  MOVF   79,W
061D:  MOVWF  26
061E:  MOVF   78,W
061F:  MOVWF  25
0620:  MOVF   77,W
0621:  MOVWF  24
....................         lcd_gotoxy(5,1);           
0622:  MOVLW  05
0623:  MOVWF  43
0624:  MOVLW  01
0625:  MOVWF  44
0626:  CALL   0E6
....................         printf(lcd_putc,"%f",temperatura);
0627:  MOVLW  89
0628:  MOVWF  04
0629:  MOVF   27,W
062A:  MOVWF  38
062B:  MOVF   26,W
062C:  MOVWF  37
062D:  MOVF   25,W
062E:  MOVWF  36
062F:  MOVF   24,W
0630:  MOVWF  35
0631:  MOVLW  02
0632:  MOVWF  39
0633:  GOTO   2B4
....................         lcd_gotoxy(12,1);
0634:  MOVLW  0C
0635:  MOVWF  43
0636:  MOVLW  01
0637:  MOVWF  44
0638:  CALL   0E6
....................         printf (lcd_putc,"C");
0639:  MOVLW  43
063A:  MOVWF  42
063B:  CALL   0F8
....................         delay_ms(200);
063C:  MOVLW  C8
063D:  MOVWF  43
063E:  CALL   043
....................         keypad=kbd_getc();           //lee el treclado
063F:  GOTO   409
0640:  MOVF   78,W
0641:  MOVWF  2E
....................         if(keypad!=0){                //si se pulsa alguna tecla
0642:  MOVF   2E,F
0643:  BTFSC  03.2
0644:  GOTO   64C
....................             keys_pressed[i]=keypad;             //se guarda el dato en la posicion corres. de la matriz
0645:  MOVLW  30
0646:  ADDWF  2F,W
0647:  MOVWF  04
0648:  BCF    03.7
0649:  MOVF   2E,W
064A:  MOVWF  00
....................             i++;   
064B:  INCF   2F,F
....................         }
....................         if(i==4){
064C:  MOVF   2F,W
064D:  SUBLW  04
064E:  BTFSS  03.2
064F:  GOTO   689
....................             if( /*keys_pressed[0]=='1' && 
....................                 keys_pressed[1]=='2' && 
....................                 keys_pressed[2]=='3' &&
....................                 keys_pressed[3]=='4' &&
....................                 keys_pressed[4]=='5' */
....................                 keys_pressed[0]=='1' && 
....................                 keys_pressed[1]=='4' && 
....................                 keys_pressed[2]=='6' &&
....................                 keys_pressed[3]=='9'){
0650:  MOVF   30,W
0651:  SUBLW  31
0652:  BTFSS  03.2
0653:  GOTO   663
0654:  MOVF   31,W
0655:  SUBLW  34
0656:  BTFSS  03.2
0657:  GOTO   663
0658:  MOVF   32,W
0659:  SUBLW  36
065A:  BTFSS  03.2
065B:  GOTO   663
065C:  MOVF   33,W
065D:  SUBLW  39
065E:  BTFSS  03.2
065F:  GOTO   663
....................                 i=0;
0660:  CLRF   2F
....................                 checkTemp();
0661:  CALL   4D2
....................             }
0662:  GOTO   689
....................             else if(keys_pressed[0]=='6' && 
....................                     keys_pressed[1]=='7' && 
....................                     keys_pressed[2]=='8' &&
....................                     keys_pressed[3]=='9' &&
....................                     keys_pressed[4]=='0'){
0663:  MOVF   30,W
0664:  SUBLW  36
0665:  BTFSS  03.2
0666:  GOTO   67A
0667:  MOVF   31,W
0668:  SUBLW  37
0669:  BTFSS  03.2
066A:  GOTO   67A
066B:  MOVF   32,W
066C:  SUBLW  38
066D:  BTFSS  03.2
066E:  GOTO   67A
066F:  MOVF   33,W
0670:  SUBLW  39
0671:  BTFSS  03.2
0672:  GOTO   67A
0673:  MOVF   34,W
0674:  SUBLW  30
0675:  BTFSS  03.2
0676:  GOTO   67A
....................                 i=0;
0677:  CLRF   2F
....................                 checkTemp();
0678:  CALL   4D2
....................             }
0679:  GOTO   689
....................             else {
....................                 printf(lcd_putc,"\fPIN Incorrecto"); //clave errada cuando la clave no es correcta
067A:  MOVLW  38
067B:  BSF    03.6
067C:  MOVWF  0D
067D:  MOVLW  00
067E:  MOVWF  0F
067F:  BCF    03.6
0680:  CALL   124
....................                 i=0;
0681:  CLRF   2F
....................                 delay_ms(2000);
0682:  MOVLW  08
0683:  MOVWF  35
0684:  MOVLW  FA
0685:  MOVWF  43
0686:  CALL   043
0687:  DECFSZ 35,F
0688:  GOTO   684
....................             }
....................         }
0689:  GOTO   5F4
....................     }
....................     return 0;
068A:  MOVLW  00
068B:  MOVWF  78
.................... }
068C:  SLEEP

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
